/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/apps/aifabrics.eda.nokia.com": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description list versions available from aifabrics.eda.nokia.com */
        get: operations["getVersionAifabricsEdaNokiaCom"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/aifabrics.eda.nokia.com/v1alpha1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description list resources available from aifabrics.eda.nokia.com/v1alpha1 */
        get: operations["getResourcesAifabricsEdaNokiaComV1alpha1"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/aifabrics.eda.nokia.com/v1alpha1/_ui/{pathname}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description get UI specification for aifabrics.eda.nokia.com v1alpha1 */
        get: operations["uiAifabricsEdaNokiaComV1alpha1"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/aifabrics.eda.nokia.com/v1alpha1/backends": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list backends
         * @description The resulting resources can optionally be a subset of the resource content by using the "fields" query parameter.
         */
        get: operations["listAifabricsEdaNokiaComV1alpha1Backends"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/aifabrics.eda.nokia.com/v1alpha1/namespaces/{namespace}/backends": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * list backends in namespace
         * @description The resulting resources can optionally be a subset of the resource content by using the "fields" query parameter.
         */
        get: operations["listAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        put?: never;
        /** @description create a Backend */
        post: operations["createAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        /** Delete all instances of Backend in the specified namespace. */
        delete: operations["deleteAllAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/aifabrics.eda.nokia.com/v1alpha1/namespaces/{namespace}/backends/_deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get information about the instances of Backend that have been deleted that existed in the specified namespace. */
        get: operations["getDeletedAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/aifabrics.eda.nokia.com/v1alpha1/namespaces/{namespace}/backends/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description read the specified Backend.  If a git hash query parameter
         *     is supplied, the resource as it existed at the time of the git hash
         *     will be returned. Streaming is not supported when a particular revision
         *     is asked for.
         */
        get: operations["readAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        /** @description replace a Backend */
        put: operations["replaceAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        post?: never;
        /** @description delete the specified Backend */
        delete: operations["deleteAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        options?: never;
        head?: never;
        /** @description patch a Backend */
        patch: operations["patchAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        trace?: never;
    };
    "/apps/aifabrics.eda.nokia.com/v1alpha1/namespaces/{namespace}/backends/{name}/_revs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get revision history for the specified namespaced Backend. */
        get: operations["getHistoryAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/aifabrics.eda.nokia.com/v1alpha1/namespaces/{namespace}/backends/{name}/_targets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get intent targets for the specified namespaced Backend. */
        get: operations["getTargetsAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/aifabrics.eda.nokia.com/v1alpha1/namespaces/{namespace}/backends/{name}/_topology": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @deprecated
         * @description Get the topology for the specified namespaced Backend.  This API is deprecated and the POST
         *     API should be used instead.
         */
        get: operations["getTopologyAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        put?: never;
        /** Retrieve the topology for the specified namespaced Backend. */
        post: operations["postTopologyAifabricsEdaNokiaComV1alpha1NamespaceBackends"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        AppGroup: {
            apiVersion?: string;
            kind?: string;
            name?: string;
            preferredVersion?: components["schemas"]["AppGroupVersion"];
            versions?: components["schemas"]["AppGroupVersion"][];
        };
        AppGroupVersion: {
            groupVersion?: string;
            version?: string;
        };
        /** Wrapper for index information inside an error. */
        ErrorIndex: {
            /** Format: int64 */
            index?: number;
        };
        ErrorItem: {
            error?: Record<string, never>;
            type?: string;
        };
        /** Generic error response for REST APIs. */
        ErrorResponse: {
            /**
             * @description A lower-level set of structured errors.
             *
             *     Only oneOf `causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection` will ever be set.
             */
            causeCollection?: components["schemas"]["ErrorResponse"][];
            /**
             * @description A lower-level set of structured errors.
             *     Each of these errors MUST have index set.
             *
             *     Only oneOf `causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection` will ever be set.
             */
            causeIndexedCollection?: components["schemas"]["ErrorResponse"][];
            /** @description If true, then the cause (`causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection`) should be hidden from the user. */
            causeIsInternal?: boolean;
            /**
             * @description Simple string error type.
             *
             *     Only oneOf `causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection` will ever be set.
             */
            causeSimple?: string;
            causeWrapped?: components["schemas"]["ErrorResponse"];
            /**
             * Format: int64
             * @deprecated
             * @description the numeric HTTP error code for the response.
             *
             *     Deprecated: Prefer to check the request's HTTP response code directly.
             */
            code?: number;
            /**
             * @deprecated
             * @description The optional details of the error response.
             *     Deprecated: Replaced by `causeSimple`.
             */
            details?: string;
            /**
             * @deprecated
             * @description Dictionary/map of associated data/information relevant to the error.
             *     The error "message" may contain {{name}} escapes that should be substituted
             *     with information from this dictionary.
             *
             *     Deprecated: Use "values" instead.
             */
            dictionary?: {
                [key: string]: unknown;
            };
            /**
             * @description The "domain" for the error.  If empty, it is an EDA
             *     core error.  Alternatively it can be an EDA application
             *     "apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)
             *     indicating that the error is specific to that application.
             *     The domain gives the receiver information that they can use
             *     to help them interpret the "type" field.
             */
            domain?: string;
            /**
             * @deprecated
             * @description Collection of errors in cases where more than one exists.
             *     This needs to be flexible so we can support multiple formats.
             *     Deprecated: Replaced by `causeCollection` or `causeIndexedCollection` instead.
             */
            errors?: components["schemas"]["ErrorItem"][];
            index?: components["schemas"]["ErrorIndex"];
            /**
             * Format: int64
             * @deprecated
             * @description Internal error code number.
             *
             *     Deprecated: "type" & "domain" should be used instead to uniquely identify this error.
             */
            internal: number;
            /** @description The basic text error message for the error response. */
            message: string;
            /** @description Reference to the error source. Should typically be the URI of the request. */
            ref?: string;
            /**
             * @description Type defines a unique identifier for the error, within the domain.
             *     This may be used (along with the domain) to find an internationalization translation for the message.
             *
             *     SHOULD be a valid golang identifier, and SHOULD be in UpperCamelCase.
             */
            type: string;
            /**
             * @description Associated data/information.
             *     The error "message" may contain {{name}} escapes that should be substituted with information from this dictionary.
             *
             *     Note that this map MUST NOT contain JSON objects (`{...}`) or arrays (`[...]`), only simple JSON types are permitted.
             */
            values?: {
                [key: string]: Record<string, never>;
            };
        };
        IntentTarget: {
            name?: string;
            namespace?: string;
        };
        IntentTargets: components["schemas"]["IntentTarget"][];
        /** @description The definition for a JSON patch for a resource, as in RFC 6902 */
        K8SPatchOp: {
            /**
             * @description Only applies to a "move" operation, and is the path to the field/value within
             *     the target JSON object that should be moved to the location specified by the "path"
             *     field.
             * @example /a/b/c
             */
            from?: string;
            /**
             * @description The type of operation this patch should perform.
             * @example replace
             * @enum {string}
             */
            op: "add" | "remove" | "replace" | "move" | "copy" | "test";
            /**
             * @description The path to the field within the target JSON object
             *     that should be patched according to the "op" field.
             * @example /a/b/d
             */
            path: string;
            /**
             * @description This field would be set to the value which the user intends to put in the
             *     field referenced by the "path" field.  The type of the value should match
             *     the type of the field as indicated by the schema of the resource being
             *     patched.
             * @example example for a string field
             */
            value?: string | number | boolean | unknown[] | Record<string, never>;
            /**
             * @description For an "add" operation, an already-present field referenced by the "path" will
             *     result in an error unless this field is true.  Similarly for a non-existent
             *     target field of a "remove" operation.
             */
            "x-permissive"?: boolean;
        };
        K8STopologyRequest: {
            filter?: components["schemas"]["TopoStateFilter"];
            recurse?: boolean;
            type?: string;
        };
        OverlayState: {
            link_groups?: {
                [key: string]: components["schemas"]["TopoOverlayLinkGroup"];
            };
            links?: {
                [key: string]: components["schemas"]["TopoOverlayLink"];
            };
            nodes?: {
                [key: string]: components["schemas"]["TopoOverlayNode"];
            };
            nodes_and_groups?: {
                [key: string]: components["schemas"]["TopoOverlayNodeOrGroup"];
            };
        };
        Patch: components["schemas"]["K8SPatchOp"][];
        Resource: {
            kind?: string;
            name?: string;
            namespaced?: boolean;
            readOnly?: boolean;
            singularName?: string;
            uiCategory?: string;
        };
        ResourceHistory: components["schemas"]["ResourceHistoryEntry"][];
        ResourceHistoryEntry: {
            author?: string;
            changeType?: string;
            /** Format: date-time */
            commitTime?: string;
            hash?: string;
            message?: string;
            /** Format: uint64 */
            transactionId?: number;
        };
        ResourceList: {
            apiVersion?: string;
            groupVersion?: string;
            kind?: string;
            resources?: components["schemas"]["Resource"][];
        };
        ResourceTopology: {
            topology?: components["schemas"]["OverlayState"];
            topologyMetadata?: components["schemas"]["Topology"];
        };
        /** Status is a return value for calls that don't return other objects. */
        Status: {
            apiVersion?: string;
            details?: components["schemas"]["StatusDetails"];
            kind?: string;
            string?: string;
        };
        StatusDetails: {
            group?: string;
            kind?: string;
            name?: string;
        };
        TopoAttrMetadata: {
            type?: string;
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
        };
        TopoAttribute: {
            name?: string;
        };
        TopoBoolExpression: {
            endpoint_expression?: components["schemas"]["TopoEndpointBoolExpression"];
            fixed_expression?: components["schemas"]["TopoFixedBoolExpression"];
            has_badge?: components["schemas"]["TopoLiteralStatusOrBadge"];
            label?: components["schemas"]["TopoLabelSelector"];
            literal?: components["schemas"]["TopoBoolLiteral"];
            logical?: components["schemas"]["TopoLogicalExpression"];
            not?: components["schemas"]["TopoBoolExpression"];
            value_expression?: components["schemas"]["TopoValueExpression"];
        };
        TopoBoolLiteral: {
            value?: boolean;
        };
        TopoElemMetadata: {
            attributes?: {
                [key: string]: components["schemas"]["TopoAttrMetadata"];
            };
            schema?: components["schemas"]["TopoSchema"];
            subtitle?: string;
            subtitle_key?: string;
        };
        TopoEndpointBoolExpression: {
            endpoint?: string;
            expression?: components["schemas"]["TopoBoolExpression"];
        };
        TopoField: {
            type?: string;
        };
        TopoFixedBoolExpression: {
            type?: string;
        };
        TopoLabelSelector: {
            selector?: string[];
        };
        TopoLiteralStatusOrBadge: {
            overlay?: string;
            /** Format: int64 */
            value?: number;
        };
        TopoLiteralValue: {
            badge?: components["schemas"]["TopoLiteralStatusOrBadge"];
            bool?: boolean;
            /** Format: double */
            number?: number;
            status?: components["schemas"]["TopoLiteralStatusOrBadge"];
            string?: string;
        };
        TopoLogicalExpression: {
            left?: components["schemas"]["TopoBoolExpression"];
            operation?: string;
            right?: components["schemas"]["TopoBoolExpression"];
        };
        TopoNodeGrouping: {
            group?: string;
            group_key?: string;
            /** Format: int64 */
            tier?: number;
        };
        TopoOverlayEndpoint: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            node?: string;
            node_key?: string;
            overlays?: {
                [key: string]: components["schemas"]["TopoOverlayEndpointState"];
            };
            schema?: components["schemas"]["TopoSchema"];
            ui_name?: string;
        };
        TopoOverlayEndpointState: {
            /** Format: int64 */
            state?: number;
        };
        TopoOverlayLink: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            endpoint_a?: components["schemas"]["TopoOverlayEndpoint"];
            endpoint_a_name?: string;
            endpoint_b?: components["schemas"]["TopoOverlayEndpoint"];
            endpoint_b_name?: string;
            group_key?: string;
            key?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            overlays?: {
                [key: string]: components["schemas"]["TopoOverlayLinkState"];
            };
            schema?: components["schemas"]["TopoSchema"];
            ui_name?: string;
        };
        TopoOverlayLinkGroup: {
            endpoint_a?: components["schemas"]["TopoOverlayLinkGroupEndpoint"];
            endpoint_b?: components["schemas"]["TopoOverlayLinkGroupEndpoint"];
            key?: string;
            overlays?: {
                [key: string]: components["schemas"]["TopoOverlayLinkState"];
            };
        };
        TopoOverlayLinkGroupEndpoint: {
            group_key?: string;
            node_key?: string;
        };
        TopoOverlayLinkState: {
            /** Format: int64 */
            state?: number;
        };
        TopoOverlayNode: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            grouping?: components["schemas"]["TopoNodeGrouping"];
            key?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            overlays?: {
                [key: string]: components["schemas"]["TopoOverlayNodeState"];
            };
            schema?: components["schemas"]["TopoSchema"];
            ui_name?: string;
        };
        TopoOverlayNodeOrGroup: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            grouping?: components["schemas"]["TopoNodeGrouping"];
            key?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            /** Format: int64 */
            num_nodes?: number;
            overlays?: {
                [key: string]: components["schemas"]["TopoOverlayNodeState"];
            };
            schema?: components["schemas"]["TopoSchema"];
            type?: string;
            ui_name?: string;
        };
        TopoOverlayNodeState: {
            badges?: number[];
            /** Format: int64 */
            state?: number;
        };
        TopoOverlayValue: {
            overlay?: string;
        };
        TopoSchema: {
            group?: string;
            kind?: string;
            version?: string;
        };
        TopoStateFilter: {
            expand_all_link_groups?: boolean;
            expand_all_node_groups?: boolean;
            expanded_link_groups?: string[];
            expanded_node_groups?: string[];
            link_filter?: components["schemas"]["TopoBoolExpression"];
            node_filter?: components["schemas"]["TopoBoolExpression"];
        };
        TopoValue: {
            attribute?: components["schemas"]["TopoAttribute"];
            badge?: components["schemas"]["TopoOverlayValue"];
            field?: components["schemas"]["TopoField"];
            literal?: components["schemas"]["TopoLiteralValue"];
            status?: components["schemas"]["TopoOverlayValue"];
        };
        TopoValueExpression: {
            left?: components["schemas"]["TopoValue"];
            operation?: string;
            right?: components["schemas"]["TopoValue"];
        };
        Topology: {
            endpoints?: components["schemas"]["TopoElemMetadata"];
            group?: string;
            grouping?: components["schemas"]["TopoSchema"];
            links?: components["schemas"]["TopoElemMetadata"];
            name?: string;
            nodes?: components["schemas"]["TopoElemMetadata"];
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
            version?: string;
        };
        UIResult: string;
        /** @description Backend is the Schema for the backends API */
        "com.nokia.eda.aifabrics.v1alpha1.Backend": {
            alarms?: components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend_alarms"];
            /** @default aifabrics.eda.nokia.com/v1alpha1 */
            apiVersion: string;
            deviations?: components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend_deviations"];
            /** @default Backend */
            kind: string;
            metadata: components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend_metadata"];
            /**
             * Specification
             * @description BackendSpec defines the desired state of Backend
             */
            spec: {
                /**
                 * Autonomous System Pool
                 * @description Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  Used when eBGP is configured as an underlay protocol.
                 */
                asnPool?: string;
                /**
                 * GPU Isolation Groups
                 * @description GPU Isolation Groups are used to isolate GPU traffic over the network, GPUs in different GPU isolation groups will not be able to communicate with each other.  If all GPUs across all stripes need to be able to communicate with each other, create a single GPUIsolationGroup selecting all GPU facing interfaces.
                 */
                gpuIsolationGroups: {
                    /**
                     * Interface Selector
                     * Format: labelselector
                     */
                    interfaceSelector: string[];
                    /**
                     * Isolation Group
                     * @description Name of the IsolationGroup.
                     */
                    name: string;
                }[];
                /**
                 * IP MTU
                 * @description IP MTU for this fabric. Default is 4136 bytes.
                 * @default 4136
                 */
                ipMTU: number;
                /**
                 * RoCEv2 QoS
                 * @description Set of properties to configure the RoCEv2 QoS.
                 */
                rocev2QoS: {
                    /**
                     * ECN Max Drop Probability Percent
                     * @description If the queue depth is between min and max threshold then this the probability with which packets are dropped or marked.
                     * @default 100
                     */
                    ecnMaxDropProbabilityPercent: number;
                    /**
                     * ECN Max Threshold Percent
                     * @description The maximum threshold parameter for a RED-managed queue in percent. When the average queue length exceeds the max value, all packets are dropped (or marked if ECN is enabled). Mutually exclusive with min-threshold and max-threshold.
                     * @default 80
                     */
                    ecnSlopeMaxThresholdPercent: number;
                    /**
                     * ECN Min Threshold Percent
                     * @description The minimum threshold parameter for a RED-managed queue in percent. When the average queue length is less than min, all packets are admitted to the queue. Mutually exclusive with min-threshold and max-threshold.
                     * @default 5
                     */
                    ecnSlopeMinThresholdPercent: number;
                    /**
                     * PFC Deadlock Detection Timer
                     * @description Number of milliseconds during which outgoing interface is receiving pfc-pause-frames before triggering recovery-timer.
                     * @default 750
                     */
                    pfcDeadlockDetectionTimer: number;
                    /**
                     * PFC Deadlock Recovery Timer
                     * @description Number of milliseconds during which the pfc-pause-frames will be ignored.
                     * @default 750
                     */
                    pfcDeadlockRecoveryTimer: number;
                    /**
                     * Maximum Burst Size
                     * Format: int32
                     * @description Maximum amount of shared buffer memory available to the queue in bytes.
                     * @default 1024000
                     */
                    queueMaximumBurstSize: number;
                };
                /**
                 * Stripe Connector
                 * @description StripeConnector is the spine layer interconnecting multiple stripes.
                 */
                stripeConnector?: {
                    /**
                     * Autonomous System Pool
                     * @description Reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.
                     */
                    asnPool?: string;
                    /**
                     * Link Selector
                     * Format: labelselector
                     * @description Selects TopoLinks to include in this AI Fabric, the selected TopoLinks will be used to create ISLs between the stripe connector devices and the leaf devices.
                     */
                    linkSelector: string[];
                    /**
                     * Stripe Connector Name
                     * @description The name of the Stripe Connector.
                     */
                    name: string;
                    /**
                     * Node Selector
                     * Format: labelselector
                     * @description Node selector to select the nodes to be used for this stripe connector.
                     */
                    nodeSelector: string[];
                    /**
                     * IPv4 Pool - System IP
                     * @description Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces for the stripe connector devices.  If not specified, the system will use the default IPAllocationPool.
                     */
                    systemPoolIPV4?: string;
                };
                /**
                 * Stripes
                 * @description A list of stripes, stripes contain a set of nodes (rails).
                 */
                stripes: {
                    /**
                     * Autonomous System Pool
                     * @description Optional reference to an IndexAllocationPool pool to use for Autonomous System Number allocations.  If left blank, ASN allocation will be done from the ASNAllocationRange.
                     */
                    asnPool?: string;
                    /**
                     * GPU VLAN
                     * @description The VLAN used on interfaces facing the GPU servers.
                     */
                    gpuVlan: number;
                    /**
                     * Stripe Name
                     * @description The name of the Stripe.
                     */
                    name: string;
                    /**
                     * Node Selector
                     * Format: labelselector
                     * @description Node selector to select the nodes to be used for this stripe.
                     */
                    nodeSelector: string[];
                    /**
                     * Stripe ID
                     * @description Unique ID for a stripe
                     */
                    stripeID: number;
                    /**
                     * IPv4 Pool - System IP
                     * @description Optional reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces. If left blank, system IP allocation will be done from the SystemIPV4Subnet.
                     */
                    systemPoolIPV4?: string;
                }[];
                /**
                 * IPv4 Pool - System IP
                 * @description Reference to an IPAllocationPool used to dynamically allocate an IPv4 address to system/lo0 interfaces.  If specified under the Leaf/Spine/Superspine/Borderleaf those will take precedence.
                 */
                systemPoolIPV4?: string;
            };
            /**
             * Status
             * @description BackendStatus defines the observed state of Backend
             */
            readonly status?: {
                /**
                 * Health
                 * @description Indicates the health score of the Fabric.  The health score of the Fabric is determined by the aggregate health score of the resources emitted by the Fabric such as ISL, DefaultRouteReflectors etc.
                 */
                health?: number;
                /**
                 * Health Score Reason
                 * @description Indicates the reason for the health score.
                 */
                healthScoreReason?: string;
                /**
                 * Last Change
                 * Format: date-time
                 * @description The time when the state of the resource last changed.
                 */
                lastChange?: string;
                /**
                 * Operational State
                 * @description Operational state of the Fabric.  The operational state of the fabric is determined by monitoring the operational state of the following resources (if applicable): DefaultRouters, ISLs.
                 */
                operationalState?: string;
                /**
                 * Stripe Connector
                 * @description Stripe connector in the Backend.
                 */
                stripeConnector?: {
                    /**
                     * Stripe Connector Name
                     * @description The name of the Stripe Connector.
                     */
                    name?: string;
                    /**
                     * Leaf Nodes
                     * @description List of stripe connector nodes in the Stripe.
                     */
                    stripeConnectorNodes?: {
                        /**
                         * Node
                         * @description Name of the TopoNode.
                         */
                        node?: string;
                        /**
                         * Operating System
                         * @description Operating system running on the node.
                         */
                        operatingSystem?: string;
                        /**
                         * Operating System Version
                         * @description Operating system version running on the node.
                         */
                        operatingSystemVersion?: string;
                    }[];
                };
                /**
                 * Stripes
                 * @description List of stripes in the Backend.
                 */
                stripes?: {
                    /**
                     * Leaf Nodes
                     * @description List of leaf nodes in the Stripe.
                     */
                    leafNodes?: {
                        /**
                         * Node
                         * @description Name of the TopoNode.
                         */
                        node?: string;
                        /**
                         * Operating System
                         * @description Operating system running on the node.
                         */
                        operatingSystem?: string;
                        /**
                         * Operating System Version
                         * @description Operating system version running on the node.
                         */
                        operatingSystemVersion?: string;
                    }[];
                    /**
                     * Stripe Name
                     * @description The name of the Stripe.
                     */
                    name?: string;
                }[];
            };
        };
        /** @description BackendList is a list of backends */
        "com.nokia.eda.aifabrics.v1alpha1.BackendList": {
            apiVersion: string;
            items?: components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"][];
            kind: string;
        };
        "com.nokia.eda.aifabrics.v1alpha1.Backend_DeletedResourceEntry": {
            /** Format: date-time */
            commitTime?: string;
            hash?: string;
            name?: string;
            namespace?: string;
            /** Format: uint64 */
            transactionId?: number;
        };
        "com.nokia.eda.aifabrics.v1alpha1.Backend_DeletedResources": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend_DeletedResourceEntry"][];
        "com.nokia.eda.aifabrics.v1alpha1.Backend_alarms": {
            /** Format: int64 */
            readonly critical?: number;
            /** Format: int64 */
            readonly major?: number;
            /** Format: int64 */
            readonly minor?: number;
            /** Format: int64 */
            readonly warning?: number;
        };
        "com.nokia.eda.aifabrics.v1alpha1.Backend_deviations": {
            /** Format: int64 */
            readonly count?: number;
        };
        "com.nokia.eda.aifabrics.v1alpha1.Backend_metadata": {
            annotations?: {
                [key: string]: string;
            };
            labels?: {
                [key: string]: string;
            };
            name: string;
            namespace: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getVersionAifabricsEdaNokiaCom: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppGroup"];
                    "application/yaml": components["schemas"]["AppGroup"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getResourcesAifabricsEdaNokiaComV1alpha1: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceList"];
                    "application/yaml": components["schemas"]["ResourceList"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    uiAifabricsEdaNokiaComV1alpha1: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description pathname to the UI specification to retrieve */
                pathname: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UIResult"];
                    "application/yaml": components["schemas"]["UIResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listAifabricsEdaNokiaComV1alpha1Backends: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched. */
                fields?: string;
                /** @description an EQL "where" expression that will be used to filter the set of resources returned. */
                filter?: string;
                /** @description a label selector string to filter the results based on CR labels */
                labelSelector?: string;
                /**
                 * @deprecated
                 * @description Deprecated: a label selector string to filter the results based on CR labels
                 */
                "label-selector"?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.BackendList"];
                    "application/yaml": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.BackendList"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched. */
                fields?: string;
                /** @description an EQL "where" expression that will be used to filter the set of resources returned. */
                filter?: string;
                /** @description a label selector string to filter the results based on CR labels */
                labelSelector?: string;
                /**
                 * @deprecated
                 * @description Deprecated: a label selector string to filter the results based on CR labels
                 */
                "label-selector"?: string;
            };
            header?: never;
            path: {
                /** @description the namespace scope in which to operate */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.BackendList"];
                    "application/yaml": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.BackendList"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description The detail level to keep in the transaction log for the transaction resulting from this request. */
                detailLevel?: "standard" | "detailed";
                /** @description If true, prevents the transaction resulting from this request from being bundled with others. */
                disableBatching?: boolean;
            };
            header?: never;
            path: {
                namespace: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"];
                    "application/yaml": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deleteAllAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description The detail level to keep in the transaction log for the transaction resulting from this request. */
                detailLevel?: "standard" | "detailed";
                /** @description a label selector string to filter the set of CRs deleted based on CR labels */
                labelSelector?: string;
                /**
                 * @deprecated
                 * @description Deprecated: a label selector string to filter the set of CRs deleted based on CR labels
                 */
                "label-selector"?: string;
                /** @description If true, prevents the transaction resulting from this request from being bundled with others. */
                disableBatching?: boolean;
            };
            header?: never;
            path: {
                /** @description the namespace scope from which to perform the delete */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.BackendList"];
                    "application/yaml": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.BackendList"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getDeletedAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description the namespace scope in which to operate */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returns list of deleted resource entries */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend_DeletedResources"];
                    "application/yaml": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend_DeletedResources"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    readAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description resource content will be returned as it was at the time of this git hash */
                hash?: string;
            };
            header?: never;
            path: {
                /** @description name of the Backend */
                name: string;
                /** @description the namespace scope in which to operate */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"];
                    "application/yaml": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    replaceAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description The detail level to keep in the transaction log for the transaction resulting from this request. */
                detailLevel?: "standard" | "detailed";
                /** @description If true, prevents the transaction resulting from this request from being bundled with others. */
                disableBatching?: boolean;
            };
            header?: never;
            path: {
                namespace: string;
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"];
                    "application/yaml": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deleteAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description The detail level to keep in the transaction log for the transaction resulting from this request. */
                detailLevel?: "standard" | "detailed";
                /** @description If true, prevents the transaction resulting from this request from being bundled with others. */
                disableBatching?: boolean;
            };
            header?: never;
            path: {
                /** @description the namespace scope from which to perform the delete */
                namespace: string;
                /** @description name of the Backend to delete */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Status"];
                    "application/yaml": components["schemas"]["Status"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    patchAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description The detail level to keep in the transaction log for the transaction resulting from this request. */
                detailLevel?: "standard" | "detailed";
                /** @description If true, prevents the transaction resulting from this request from being bundled with others. */
                disableBatching?: boolean;
            };
            header?: never;
            path: {
                namespace: string;
                name: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json-patch+json": components["schemas"]["Patch"];
            };
        };
        responses: {
            /** @description The response for a successful EDA resource patch operation. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"];
                    "application/yaml": components["schemas"]["com.nokia.eda.aifabrics.v1alpha1.Backend"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getHistoryAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description maximum number of history entries to return */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description name of the Backend to retrieve */
                name: string;
                /** @description the namespace scope from which to retrieve the result */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returns the change history of the specified resource */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceHistory"];
                    "application/yaml": components["schemas"]["ResourceHistory"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getTargetsAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description name of the Backend */
                name: string;
                /** @description the namespace scope in which to operate */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returns the list of intent targets for the specified Backend resource. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IntentTargets"];
                    "application/yaml": components["schemas"]["IntentTargets"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getTopologyAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description the type of topology to retrieve */
                type?: "children" | "parents" | "childrenAndParents" | "dependentCrs";
                /** @description whether to recursively build the topology to include all layers or just a single layer of the topology */
                recurse?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description name of the Backend to retrieve */
                name: string;
                /** @description the namespace scope from which to retrieve the result */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returns the topology of the specified resource */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceTopology"];
                    "application/yaml": components["schemas"]["ResourceTopology"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    postTopologyAifabricsEdaNokiaComV1alpha1NamespaceBackends: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description name of the Backend to retrieve */
                name: string;
                /** @description the namespace scope from which to retrieve the result */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description the details of topology to retrieve */
        requestBody: {
            content: {
                "application/json": components["schemas"]["K8STopologyRequest"];
            };
        };
        responses: {
            /** @description Returns the topology of the specified resource */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceTopology"];
                    "application/yaml": components["schemas"]["ResourceTopology"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
}
