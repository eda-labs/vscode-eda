/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/core/about/activity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the cluster activity status.
         * @description Unless an error is encountered, it simply returns an "NoContent" (for active)
         *     or "ServiceUnavailable" (for standby) status. In other words, there is no
         *     response body for these cases.
         */
        get: operations["activityGet"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/about/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Returns an indication of the health of the EDA cluster. HTTP status OK
         *     indicates that all is good.  HTTP status ServiceUnavailable indicates that
         *     all of the services of the EDA cluster (other than the API service) are down.
         *     HTTP status InternalServerError indicates that one service is down, but at
         *     least one service (other than the API service) is up.
         */
        get: operations["healthGet"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/about/version": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns version information for the EDA cluster. */
        get: operations["versionGet"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/access/v1/checkAccess": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Checks the current user's access to the various resources, urls and tables provided in the
         *     request body.
         */
        post: operations["accessCheckAccess"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/access/v1/namespaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Gets the list of namespaces the current user can access. If the current user is able to access the
         *     'All Namespaces' option that will be indicated in the response.
         */
        get: operations["accessGetNamespaces"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/federationproviders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the user federation providers configured in EDA.
         * @description Returns a list of federation providers, possibly filtered based on the "name" query parameter.
         */
        get: operations["adminGetProviders"];
        put?: never;
        /**
         * Create an EDA user federation provider.
         * @description Creates an EDA user federation provider using the definition in the body.  The UUID cannot be set, it is
         *     created by the system when the provider is created.
         */
        post: operations["adminCreateProvider"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/federationproviders/{uuid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the EDA user federation provider specified by the uuid in the request URL.
         * @description Returns the definition of the specified EDA federation provider.
         */
        get: operations["adminGetProvider"];
        /**
         * Update an EDA user federation provider.
         * @description Replaces the definition of an EDA user federation provider with the definition in the body.
         *     The UUID cannot be changed.
         */
        put: operations["adminUpdateProvider"];
        post?: never;
        /**
         * Delete an EDA user federation provider.
         * @description Deletes the EDA user federation provider specified by the UUID in the path.
         */
        delete: operations["adminDeleteProvider"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/federationprovidertest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test connection and authentication for an EDA federation provider.
         * @description This endpoint instructs the keycloak server to test a federation provider
         *     on behalf of the requesting user.  If the "name" in the test parameters
         *     is provided by the user for an authentication test, a provider by that
         *     name must exist, and the bind credential (password) saved in that
         *     provider will be used for the test.  Otherwise, the bind credential
         *     must be provided in the test parameters.
         */
        post: operations["adminTestProvider"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns all EDA user-groups.
         * @description Returns the list of defined EDA user-groups.  Query parameters control if
         *     the associated users and roles are returned by name only, or if the full definition
         *     is returned.
         */
        get: operations["adminGetUserGroups"];
        put?: never;
        /**
         * Creates a new EDA user group.
         * @description Creates a new EDA user group using the definition in the request body. The
         *     EDA roles for the new group can be included in the definition, but the users
         *     belonging to the group cannot be specified here.  The users of the group
         *     must be modified via either the "groups of user" membership APIs, or the
         *     "users of group" membership APIs.  Same for the roles.  A uuid definition in
         *     the body will be ignored; the uuid of the group is assigned by the system
         *     when it is created.
         */
        post: operations["adminCreateUserGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/groups/{uuid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a single EDA user-group.
         * @description Returns the single EDA user-group identified by the uuid parameter.  Query parameters control if
         *     the associated users and roles are returned by name only, or if the full definition
         *     is returned.
         */
        get: operations["adminGetUserGroup"];
        /**
         * Updates an EDA user group
         * @description Update the definition of the EDA user group specified by the UUID in the
         *     path. The name and UUID of the group cannot be modified in this manner.  The
         *     roles of the user group will be set to the set of roles in the new
         *     definition.  The users of a user group cannot be modified via this mechanism,
         *     but must be modified via the "groups of user" or "users of group" APIs.
         *     A similar restriction applies to the roles of the user group.
         */
        put: operations["adminUpdateUserGroup"];
        post?: never;
        /**
         * Deletes an EDA user group.
         * @description Deletes the EDA user group identified by the UUID in the path.  Any user which is
         *     currently a member of the group will no longer be a member of the group after this.
         */
        delete: operations["adminDeleteUserGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/groups/{uuid}/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns the roles assigned to an EDA user-group.
         * @description Returns a list of role definitions for the roles assigned to the specified EDA user group.
         */
        get: operations["adminGetRolesOfUserGroup"];
        /**
         * Replace the roles of an EDA user group.
         * @description Replaces the roles of the specified user group with the roles in the body.  This will affect
         *     the roles of any users assigned to the user group.
         */
        put: operations["adminSetRolesOfUserGroup"];
        /**
         * Assign roles to an EDA user group.
         * @description Assigns the specified set of roles to the specified user group (as well as the ones that
         *     were previously assigned to the user group). This means that all the users assigned
         *     to that user group will now have that set of roles, in addition to any roles they already had.
         */
        post: operations["adminAddRolesToUserGroup"];
        /**
         * Remove roles from an EDA user group.
         * @description Removes the roles specified in the body from the user group specified in the path.
         *     This will affect the roles of any users assigned to the user group.
         */
        delete: operations["adminRemoveRolesFromUserGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/namespaces/{namespace}/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get/stream the EDA roles in the specified namespace.
         * @description Either returns or streams the EDA role definitions, depending on query
         *     parameters.
         */
        get: operations["adminGetRoles"];
        put?: never;
        /**
         * Create an EDA namespaced role in the specified namespace.
         * @description Creates a new EDA role using the definition in the request body.
         */
        post: operations["adminCreateRole"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/namespaces/{namespace}/roles/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get/stream a single namespaced EDA role.
         * @description Returns the specifed namespaced EDA role definition, or streams the EDA role and any changes,
         *     depending on the streaming query parameters.
         */
        get: operations["adminGetRole"];
        /**
         * Update an EDA namespaced role with new content.
         * @description Replaces the definition of the specifed EDA role with the definition in the body.
         *     The role name cannot be modified.
         */
        put: operations["adminUpdateRole"];
        post?: never;
        /**
         * Delete an EDA namespaced role.
         * @description Deletes the specified EDA role. This will fail if the role is assigned to any user groups.
         *     You must remove the role from the user groups first.
         */
        delete: operations["adminDeleteRole"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/passwordpolicy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the current EDA password policy parameters.
         * @description Returns the parameters for the currently configured EDA password policy.
         *     If a "get-default=true" query parameter is passed, the default password policy definition
         *     is returned.
         */
        get: operations["adminGetPasswordPolicy"];
        /** Sets the EDA password policy parameters. */
        put: operations["adminUpdatePasswordPolicy"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get/stream the EDA cluster roles.
         * @description Either returns or streams the EDA cluster role definitions, depending on query
         *     parameters.
         */
        get: operations["adminGetClusterRoles"];
        put?: never;
        /**
         * Create an EDA cluster role.
         * @description Creates a new EDA cluster role using the definition in the request body.
         */
        post: operations["adminCreateClusterRole"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/roles/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get/stream a single EDA cluster role.
         * @description Returns the specifed EDA cluster role definition, or streams the EDA role and any changes,
         *     depending on the streaming query parameters.
         */
        get: operations["adminGetClusterRole"];
        /**
         * Update an EDA cluster role with new content.
         * @description Replaces the definition of the specifed EDA role with the definition in the body.
         *     The role name cannot be modified.
         */
        put: operations["adminUpdateClusterRole"];
        post?: never;
        /**
         * Delete an EDA cluster role.
         * @description Deletes the specified EDA role. This will fail if the role is assigned to any user groups.
         *     You must remove the role from the user groups first.
         */
        delete: operations["adminDeleteClusterRole"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Returns EDA users, either all users, or user(s) filtered on username
         *     or email address, based on query parameters.
         */
        get: operations["adminGetUsers"];
        put?: never;
        /**
         * Creates an EDA user with the JSON information in the request body.
         * @description Note that group membership is not changed (the "groups" data in the user
         *     definition is ignored).  The groups of a user must be modified via the
         *     core/admin/users/{uuid}/groups REST endpoint or by modifying the group definitions
         *     using group REST endpoints.
         */
        post: operations["adminCreateUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/users/{uuid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a single EDA user specified by the userid (UUID) parameter in the path. */
        get: operations["adminGetUser"];
        /**
         * Replaces the attributes of an EDA user with the JSON information in the request body.
         * @description Note that the userid/UUID and name cannot be modified.
         *     Note also that group membership is not changed (the "groups" data in the user
         *     definition is ignored).  The groups of a user must be modified via the
         *     core/admin/users/{uuid}/groups REST endpoint or by modifying the group definitions
         *     using group REST endpoints.
         */
        put: operations["adminModifyUser"];
        post?: never;
        /** Deletes the user identified by userid/UUID in the request path. */
        delete: operations["adminDeleteUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/users/{uuid}/actionemails": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Invokes the specified email action for the specified user. */
        put: operations["adminExecuteEmailActions"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/users/{uuid}/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * @description Replaces the group memberships of the specified user to that they are members of only the
         *     groups specified by the group UUIDs in the request body.
         */
        put: operations["adminSetGroupsOfUser"];
        /** Adds the specified user to the groups specified by the group UUIDs in the request body. */
        post: operations["adminAddGroupsToUser"];
        /** Removes the specified user from the groups specified by the group UUIDs in the request body. */
        delete: operations["adminRemoveGroupsFromUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/users/{uuid}/resetpassword": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Sets/updates/replaces the password of the specified user. */
        put: operations["adminSetUserPassword"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/alarms": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets all alarms including namespaced alarms from all namespaces and all non-namespaced alarms.
         * @description This API can get a snapshot of the alarms, or can return a stream of the alarms and the changes to them.
         *     The API does not provide suppressed alarms by default, but the suppressed alarms will be included if the "all" query parameter is set to "true".
         *     The alarm fields returned can optionally be specified using the "fields" query parameter.
         *     The alarm namespace and name fields are never filtered.
         *     The set of alarms returned can be filtered by providing the "filter" query parameter.
         */
        get: operations["alarmGetAlarms"];
        /**
         * @description Performs the specified acknowledgement action provided in the "action" query
         *     on the alarms named in the JSON string array in the body.  The action
         *     can be performed on alarms across multiple namespaces, including non-namespaced
         *     alarms.  It is possible for some actions on alarms to have been successful and
         *     other actions to have failed if an error is returned.
         */
        put: operations["alarmPutAlarms"];
        post?: never;
        /**
         * @description Deletes all the alarms named in the JSON string array in the body.  Deletes
         *     can be performed on alarms across multiple namespaces, including non-namespaced
         *     alarms.  It is possible for some deletes on alarms to have been successful and
         *     other deletes to have failed if an error is returned.
         */
        delete: operations["alarmDeleteAlarms"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/alarms/{alarm-name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets a single non-namespaced alarm, as specified by the alarm-name parameter.
         * @description This API can get a snapshot of the alarm, or a stream of changes to that alarm.
         *     The API does not provide information about a suppressed alarm by default, but the suppressed alarm will be included if the "all" query parameter is set to "true".
         */
        get: operations["alarmGetAlarm"];
        /**
         * @description Performs the specified acknowledgement action provided in the "action" query
         *     on the non-namespaced alarm with the specified name (alarm-name).
         */
        put: operations["alarmPutAlarm"];
        post?: never;
        /**
         * @description Deletes the non-namespaced alarm with the specified name (alarm-name).  If the alarm is not
         *     cleared, the alarm will not be deleted, but there will be no error.
         */
        delete: operations["alarmDeleteAlarm"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/alarms/{alarm-name}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the history of the specified non-namespaced alarm.  This API supports streaming,
         * @description and if requested the history of the alarm will be streamed back on the provided stream,
         *     including any subsequent changes.  If not using streaming, a snapshot of the history
         *     will be returned.
         */
        get: operations["alarmGetAlarmHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/namespaces/{nsName}/alarms": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets all alarms from a specific namespace.
         * @description This API can get a snapshot of the alarms, or can return a stream of the alarms and the changes to them.
         *     The API does not provide suppressed alarms by default, but the suppressed alarms will be included if the "all" query parameter is set to "true".
         *     The alarm fields returned can optionally be specified using the "fields" query parameter.
         *     The alarm namespace and name fields are never filtered.
         *     The set of alarms returned can be filtered by providing the "filter" query parameter.
         */
        get: operations["alarmGetNamespaceAlarms"];
        /**
         * @description Performs the specified acknowledgement action provided in the "action" query
         *     on the alarms named in the JSON string array in the body.  All alarms acted on must be
         *     within a single namespace.  It is possible for some actions on alarms to have been
         *     successful and other actions to have failed if an error is returned.
         */
        put: operations["alarmPutNamespaceAlarms"];
        post?: never;
        /**
         * @description Deletes all the alarms named in the JSON string array in the body.  All alarms acted
         *     on must be within a single namespace.  It is possible for some deletes on alarms to have
         *     been successful and other deletes to have failed if an error is returned.
         */
        delete: operations["alarmDeleteNamespaceAlarms"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/namespaces/{nsName}/alarms/{alarm-name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets a single namespaced alarm, as specified by the nsName and alarm-name parameters.
         * @description This API can get a snapshot of the alarm, or a stream of changes to that alarm.
         *     The API does not provide information about a suppressed alarm by default, but the suppressed alarm will be included if the "all" query parameter is set to "true".
         */
        get: operations["alarmGetNamespaceAlarm"];
        /**
         * @description Performs the specified acknowledgement action provided in the "action" query
         *     on the namespaced alarm with the specified name (alarm-name).
         */
        put: operations["alarmPutNamespaceAlarm"];
        post?: never;
        /**
         * @description Deletes the namespaced alarm with the specified name (alarm-name).  If the alarm is not
         *     cleared, the alarm will not be deleted, but there will be no error.
         */
        delete: operations["alarmDeleteNamespaceAlarm"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/namespaces/{nsName}/alarms/{alarm-name}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the history of the specified alarm in a namespace.  This API supports streaming,
         * @description and if requested the history of the alarm will be streamed back on the provided stream,
         *     including any subsequent changes.  If not using streaming, a snapshot of the history
         *     will be returned.
         */
        get: operations["alarmGetNamespaceAlarmHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/autocomplete/v1/fields": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Gets a list of auto-completions for the field of a table.
         * @description Gets a list of auto-completions for the field whose values begin with the string sent in the 'value' property of the request body, and applicable to the table specified by the 'table' property of the request body.
         */
        post: operations["autoCompleteFieldsRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/autocomplete/v1/gvk": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Gets a list of names for the instances of the specified EDA resource identified by the "kind".
         * @description Fetches a list of names for the instances of the specified EDA resource (identified by the "group", "version" and "kind" in the posted details, the "type" in the details must be "gvk") whose names begin with the string sent in the 'value' property of the request body.
         *     In the completion results for this endpoint, the "completion" fields are replacements, not intended to be appended to the user input.
         */
        post: operations["autoCompleteGVKRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/autocomplete/v1/gvr": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Gets a list of names for the instances of the specified EDA resource identified by the "resource".
         * @description Fetches a list of names for the instances of the specified EDA resource (identified by the "group", "version" and "resource" in the posted details, the "type" in the details must be "gvr") whose names begin with the string sent in the 'value' property of the request body.
         *     In the completion results for this endpoint, the "completion" fields are replacements, not intended to be appended to the user input.
         */
        post: operations["autoCompleteGVRRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/autocomplete/v1/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Gets a list of suggested key/value for labels.
         * @description Gets a list of auto-completions for labels identified by the "gvk" in the posted details whose names begin with the string sent in the 'value' property of the request body.
         */
        post: operations["toolsGetLabelCompletions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/autocomplete/v1/labelselector": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Gets a list of text-completions to help the requestor construct a label-selector.
         * @description Gets a list of text-completions based on the partial label-selector string passed as the value in the request,
         *     in the context of the labels/values on the instances of the resource type indicated in the details.
         */
        post: operations["autoCompleteLabelSelectorRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/autocomplete/v1/table": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Gets a list of auto-completions for a table name.
         * @description Gets a list of auto-completions for a table name. The table names returned in the completion will be table names whose prefix is the contatenation of the "table-prefix" and "value" field from the request.
         */
        post: operations["autoCompleteTableRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/autocomplete/v1/where": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Gets a list of auto-completions for a EQL where clause.
         * @description Gets a list of auto-completions for the EQL where clause whose values begin with the string sent in the 'value' property of the request body, and applicable to the table specified by the 'table' property of the request body.
         */
        post: operations["autoCompleteWhereRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/chat/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Opens a new chat stream with the EDA AI assistants */
        post: operations["chatOpenChat"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/chat/v1/chats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets a list of all saved AI Chat conversations */
        get: operations["chatGetConversationList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/chat/v1/chats/{chatId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets conversation history for the chat with the provided ID */
        get: operations["chatGetConversationHistory"];
        /** Updates the conversation details with the provided */
        put: operations["chatUpdateConversation"];
        post?: never;
        /** Deletes conversation history for the chat with the provided ID */
        delete: operations["chatDeleteConversation"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/db/v1/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Deprecated version of fetching/streaming the rows of the specified EDA database table.
         * @deprecated
         * @description Fetch/stream the rows of the specified EDA database table.
         *     Deprecated: Use /core/db/v2/data instead.
         *
         *     The table path is specified via the "path" parameter in the URL path.
         *     There is a way that keys can be specified for any subtables, allowing restriction
         *     of the returned rows to those having the specified keys.
         *     The key specification is performed by providing query parameters where the parameter name
         *     is the path for the table key the requestor wishes to fix, and the parameter value is the
         *     value of the key.
         *
         *     For example, the user could request only the nodes in the 'my-namespace' EDA namespace by
         *     using a path of "namespace/nodes" and a query parameter of ".namespace.name=my-namespace"
         *
         *     Similarly, the user could request the row for a single node (named 'leaf-1') in the 'eda'
         *     namespace by using a path of "namespace/nodes" and query parameters ".namespace.name=eda&.namespace.node.name=leaf-1"
         *
         *     Access to tables is controlled by the EDA table rules present in cluster roles only. Table rules
         *     in namespaced roles are not consulted for access.
         */
        get: operations["deprecatedGetDB"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/db/v2/data": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch/stream the rows of the specified EDA database table.
         * @description The table path is specified via the "jsPath" query parameter.
         *     Keys optionally can be included inside the specific jsPath.
         *
         *     Access to tables is controlled by the EDA table rules present in cluster roles only. Table rules
         *     in namespaced roles are not consulted for access.
         */
        get: operations["getDB"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/db/v2/schema": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetch the schema of the specified EDA database table.
         * @description The table name is specified via the "tableName" query parameter.
         *
         *     Access to tables is controlled by the EDA table rules present in cluster roles only. Table rules
         *     in namespaced roles are not consulted for access.
         */
        get: operations["getSchema"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/nodeconfig/v2/namespaces/{nsName}/nodes/{nodeName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the node config of a node. */
        get: operations["toolsGetNodeConfig"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/query/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Query request using the EDA query language
         * @description Streaming API:
         *     Initiate a streaming query request using the EDA query language.
         *
         *     Non Streaming API:
         *     REST endpoint supporting one-shot queries.
         *
         *     Whenever the information described by the query parameter changes,
         *     the result of the query will be sent to the requestor/client via the specified stream.
         *     Note that if the namespaces argument is not provided, the user must have cluster role
         *     permission to access the table specified in the query. If one or more namespaces
         *     are supplied, the user must have cluster role permission, or role permission (in all
         *     the specified namespaces) to access the table specified in the query.
         */
        get: operations["queryGetQuery"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/query/v1/convert": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Given a jspath on input, this request returns the table, where clause and
         *     a full EQL query for that jspath.  Any keys in the jspath are converted into
         *     the appropriate conditions in the where clause.
         */
        post: operations["queryConvertRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/query/v1/eql": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Query request using the EDA query language
         * @description Streaming API:
         *     Initiate a streaming query request using the EDA query language.
         *
         *     Non Streaming API:
         *     REST endpoint supporting one-shot queries.
         *
         *     Whenever the information described by the query parameter changes,
         *     the result of the query will be sent to the requestor/client via the specified stream.
         *     Note that if the namespaces argument is not provided, the user must have cluster role
         *     permission to access the table specified in the query. If one or more namespaces
         *     are supplied, the user must have cluster role permission, or role permission (in all
         *     the specified namespaces) to access the table specified in the query.
         */
        get: operations["queryGetEqlQuery"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/query/v1/eql/autocomplete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request auto-completion for the specified EDA query-language string.
         * @description Returns auto-completion information for the given (incomplete) EQA query language query.
         *     The number of results returned can be limited with an optional parameter.
         */
        get: operations["queryGetEqlQueryAutoComplete"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/query/v1/nql": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Query request using the 'natural' query language
         * @description Streaming API:
         *     Initiate a streaming query request using the 'natural' query language.
         *
         *     Non Streaming API:
         *     REST endpoint supporting one-shot queries.
         *
         *     Whenever the information described by the query parameter changes,
         *     the result of the query will be sent to the requestor/client via the specified stream.
         *     Note that if the namespaces argument is not provided, the user must have cluster role
         *     permission to access the table specified in the query. If one or more namespaces
         *     are supplied, the user must have cluster role permission, or role permission (in all
         *     the specified namespaces) to access the table specified in the query.
         */
        get: operations["queryGetNqlQuery"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/store/v1/appsettingsdefinition/catalog/{catalog}/app/{appId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Fetches the application settings definition for the provided appId and version
         * @description The version should be specified by  the semVer query parameter.
         */
        get: operations["storeGetAppSettingsDefinition"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/store/v1/appsummaries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve application summary list
         * @description Retrieve a list of all applications that are discovered by the EDA store in all catalogs.
         *     The list can be optionally filtered based on the installed and upgradable state of the applications.
         */
        get: operations["storeGetAppSummaries"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/store/v1/appsummaries/app/{appId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve application summary for a given appId
         * @description Retrieve an application summary for the application with the provided appId.
         *     Can also be filtered based on the installed and upgradable state of the application
         */
        get: operations["storeGetAppSummary"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/store/v1/categories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve application category list
         * @description Retrieves the list of application categories that are set on all the applications in all the catalogs in the store.
         */
        get: operations["storeGetCategories"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/store/v1/file/catalog/{catalog}/app/{appId}/{path}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * retrieves the contents of the file in the application version specified by the arguments to the request.
         * @description The version should be specified by one or the other (not both) of the semVer and commitHash
         *     query parameters.
         */
        get: operations["storeGetAppFile"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/store/v1/installedsettings/app/{appId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the currently installed settings for the specified application. */
        get: operations["storeGetAppInstalledSettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/store/v1/manifest/catalog/{catalog}/app/{appId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * retrieves the manifest of the specified version of the application from the specified catalog.
         * @description The version should be specified by one or the other (not both) of the semVer and commitHash
         *     query parameters.
         */
        get: operations["storeGetAppManifest"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/store/v1/requirementsgraph/catalog/{catalog}/app/{appId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initiates the calculation of (if necessary) and retrieves the requirements graph for the application version specified specified by the arguments to the request.
         * @description The version should be specified by the semVer query parameter.
         */
        get: operations["storeGetAppRequirementsGraph"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/store/v1/versions/app/{appId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve list of application versions
         * @description Retrieves the versions of the specified application available in the EDA store.
         */
        get: operations["storeGetAppVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description list topologies that have been published in the database */
        get: operations["topologies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1/{topologyName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description get the metadata for a specific topology */
        get: operations["topology"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1/{topologyName}/groupings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Fetch the groupings defined for the specified topology. The result will be in the form of a list of instances of the custom record definition defined for the groupings in the specified topology. */
        get: operations["getTopologyGroupings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1/{topologyName}/groupings/{groupingName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Fetch the named grouping for the specified topology. The result will be an instance of the custom record definition defined for the groupings in the specified topology. */
        get: operations["getTopologyGrouping"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1/{topologyName}/overlay": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description list overlays for a specific topology */
        get: operations["overlays"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1/{topologyName}/overlay/{overlayName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description get the metadata for a specific overlay */
        get: operations["overlay"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1/{topologyName}/state": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description get the state of a specific topology with option to specify the namespace, groupings and overlays */
        post: operations["topologyPostState"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Runs a transaction. */
        post: operations["transPostTransaction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/restore/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Restores the configuration of the system to the state at the time of the transaction identified by the specified transaction id. */
        post: operations["transRestoreTransaction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/diffs/nodecfg/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the diff view of a node configuration change from a transaction. */
        get: operations["transGetNodeConfigDiff"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/diffs/resource/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the diff view of a resource change from a posted transaction. */
        get: operations["transGetResourceDiff"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/execution/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the details of a posted transaction.  This does not include the input resources, which can be retrieved using the transGetResultInputResources operation. */
        get: operations["transGetResultExecution"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/inputresources/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the input resources of a posted transaction.  This list is filtered by the access rights of the requesting user.
         * @description If the user does not have read access to any resources, these resources will not be included in the list, and in this
         *     case the the limitedAccess field in the response will be set to true.
         */
        get: operations["transGetResultInputResources"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/summary": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Gets summarized results of transactions for all users.  These results can be streamed back to the requestor if
         *     the appropriate streaming parameters are supplied.
         */
        get: operations["transGetSummaryResultList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/summary/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets summarized results of a single transaction. */
        get: operations["transGetSummaryResult"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/topology/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets a topology of a transaction.  This API is deprecated.  Use the POST API instead.
         * @deprecated
         */
        get: operations["transGetResultTopology"];
        put?: never;
        /** Returns or streams a topology of a transaction. */
        post: operations["transPostResultTopology"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/revert/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reverts the transaction identified by the transaction id. */
        post: operations["transRevertTransaction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/state/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Gets the state of a posted transaction.  State changes for the transaction
         *     can be streamed back to the requestor if the appropriate streaming parameters are supplied.
         */
        get: operations["transGetState"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validates a list of CRs to check that they are properly formed before later adding them to a transaction. */
        post: operations["transValidateTransaction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/directory": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description gets the content of a user-storage directory */
        get: operations["ussGetDirectory"];
        put?: never;
        post?: never;
        /** @description delete a user-storage directory (and its contents) */
        delete: operations["ussDeleteDirectory"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description returns the content of a single user-storage file */
        get: operations["ussGetFile"];
        /** @description Creates a user-storage file */
        put: operations["ussPutFile"];
        /** @description Creates/writes the content of a user-storage file */
        post: operations["ussPostFile"];
        /** @description deletes a user-storage file */
        delete: operations["ussDeleteFile"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Deletes a number of user-storage files as specified in the JSON body of the request.
         * @description Deletes the user-storage files whose paths are in the JSON string array in the body
         *     of the request.  There is never partial success.  Either all the deletes succeed,
         *     or none of them occur.  i.e. if an error response comes back, no files were
         *     deleted.
         */
        delete: operations["ussDeleteFiles"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/shared/directory": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description gets the content of a user-storage directory from the shared region */
        get: operations["ussGetSharedDirectory"];
        put?: never;
        post?: never;
        /** @description delete a user-storage directory (and its contents) from the shared region */
        delete: operations["ussDeleteSharedDirectory"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/shared/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description returns the content of a single user-storage file from the shared region */
        get: operations["ussGetSharedFile"];
        /** @description Creates a user-storage file to the shared region */
        put: operations["ussPutSharedFile"];
        /** @description Creates/writes the content of a user-storage file to the shared region */
        post: operations["ussPostSharedFile"];
        /** @description deletes a user-storage file from the shared region */
        delete: operations["ussDeleteSharedFile"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/shared/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Deletes a number of user-storage files from the shared region as specified in the JSON
         *     body of the request.
         * @description Deletes the user-storage files whose paths are in the JSON string array in the body
         *     of the request.  There is never partial success.  Either all the deletes succeed,
         *     or none of them occur.  i.e. if an error response comes back, no files were
         *     deleted.
         */
        delete: operations["ussDeleteSharedFiles"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/workflows/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get workflows across all groups, versions, and kinds. */
        get: operations["wfListAllNs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        AccessQuery: {
            gvk?: components["schemas"]["GroupVersionKind"];
            gvr?: components["schemas"]["GroupVersionResource"];
            /** @description The namespace to check. Empty string (or omit) to check for cluster-wide access */
            namespace?: string;
            /** @description Target url or table of the access check. Provided when type is table or url */
            path?: string;
            /**
             * @description The permissions for the requested resource/url/table.
             * @enum {string}
             */
            permissions?: "read" | "readWrite";
            /**
             * @description The type of rule to check for
             * @enum {string}
             */
            type: "gvk" | "gvr" | "url" | "table";
        };
        AccessResult: {
            /** @description Indicates if the user can access the requested resource */
            access?: boolean;
            error?: components["schemas"]["ErrorResponse"];
        };
        /** @description provides the information about a single alarm or alarm history instance */
        AlarmData: {
            /** @description An indication if the alarm has been acknowledged. */
            acknowledged?: boolean;
            /** @description Indicates the end time of the acknowledgement. */
            acknowledgedUntil?: string;
            /** @description adds extra context related to the alarm */
            additionalText?: string;
            /** @description An indication if the alarm has been cleared. */
            cleared?: boolean;
            /**
             * @deprecated
             * @description The cluster member that generated this alarm.  Use clusterName instead.
             *     Deprecated: true
             */
            clusterMember?: string;
            /** @description The name of the cluster member which generated this alarm. */
            clusterName?: string;
            /** @description A description for the alarm. */
            description?: string;
            /** @description Indicates the group of the resource the alarm is present on. */
            group?: string;
            /**
             * @deprecated
             * @description An unnormalized jspath relating to the object in the alarm state. Use jspaths instead.
             *     Deprecated: true
             */
            jsPaths?: string[];
            /**
             * @description An unnormalized jspath relating to the object in the alarm state.
             * @example [
             *       ".node{.name==\"spine-1-1\"}.srl{.version==\"24.10.1\"}.interface{.name==\"ethernet-1-1\"}"
             *     ]
             */
            jspaths?: string[];
            /** @description Indicates the kind of resource the alarm is present on. */
            kind?: string;
            /**
             * @deprecated
             * @description the time this alarm was last acknowledged. Use lastAcknowledgedTime instead.
             *     Deprecated: true
             */
            lastAcknowledged?: string;
            /** @description the user who last acknowledged the alarm */
            lastAcknowledgedBy?: string;
            /** @description the time this alarm was last acknowledged. */
            lastAcknowledgedTime?: string;
            /** @description The last time that the alarm was changed; as provided by the raiser of the alarm. */
            lastChanged?: string;
            /**
             * @deprecated
             * @description the time this alarm was last suppressed. Use lastSuppressedTime instead.
             *     Deprecated: true
             */
            lastSuppressed?: string;
            /** @description the user who last suppressed the alarm */
            lastSuppressedBy?: string;
            /** @description the time this alarm was last suppressed. */
            lastSuppressedTime?: string;
            /** @description The unique name for the alarm, e.g. InterfaceDown-spine-1-1-ethernet-1-1. */
            name?: string;
            /** @description The namespace of the alarm */
            namespace?: string;
            /**
             * Format: int64
             * @description The number of occurrences of this alarm (the number of times it has been raised).
             */
            occurrences?: number;
            /**
             * @description The names of other alarms that are parents of this alarm. This may be used to
             *     filter out alarms that are not a root cause.
             */
            parentAlarms?: string[];
            /**
             * @description the probable cause for raising the alarm. This field is optional, and
             *     should also be a description indicating the primary probable cause of the
             *     alarm, which may be enriched with relevant information from this specific
             *     alarm instance. The complete alarm below contains an example.
             */
            probableCause?: string;
            /**
             * @description any remedial actions the user could try to resolve/clear the alarm. This
             *     field is optional, and may also be enriched with relevant information
             *     from this specific alarm instance. The complete alarm below contains an
             *     example.
             */
            remedialAction?: string;
            /** @description The name of the resource that this alarm is present on. */
            resource?: string;
            /**
             * @description Severity of the alarm
             * @enum {string}
             */
            severity?: "warning" | "minor" | "major" | "critical";
            /** @description Indicates indicates the group of the resource that raised this alarm, e.g. interfaces.eda.nokia.com. */
            sourceGroup?: string;
            /** @description Indicates the Kind of the resource that raised this alarm, e.g. InterfaceState. */
            sourceKind?: string;
            /** @description Indicates the the name of the resource that raised this alarm, e.g. spine-1-1-ethernet-1-1. */
            sourceResource?: string;
            /** @description An indication if the alarm has been suppressed. */
            suppressed?: boolean;
            /** @description Indicates the end time of the suppression. */
            suppressedUntil?: string;
            /** @description List of nodes affected by this alarm. */
            targetsAffected?: components["schemas"]["AlarmTarget"][];
            /** @description A kind for the alarm, e.g. InterfaceDown */
            type?: string;
        };
        AlarmHistoryData: {
            /** @description An indication if the alarm has been acknowledged. */
            acknowledged?: boolean;
            /** @description the user who acknowledged the alarm for this alarm history entry */
            acknowledgedBy?: string;
            /** @description adds extra context related to the alarm */
            additionalText?: string;
            /** @description An indication if the alarm has been cleared. */
            cleared?: boolean;
            /** @description The last time that the alarm was changed; as provided by the raiser of the alarm. */
            lastChanged?: string;
            /** @description The unique name for the alarm, e.g. InterfaceDown-spine-1-1-ethernet-1-1. */
            name?: string;
            /** @description The namespace of the alarm */
            namespace?: string;
            /**
             * @description the probable cause for raising the alarm. This field is optional, and
             *     should also be a description indicating the primary probable cause of the
             *     alarm, which may be enriched with relevant information from this specific
             *     alarm instance. The complete alarm below contains an example.
             */
            probableCause?: string;
            /**
             * @description any remedial actions the user could try to resolve/clear the alarm. This
             *     field is optional, and may also be enriched with relevant information
             *     from this specific alarm instance. The complete alarm below contains an
             *     example.
             */
            remedialAction?: string;
        };
        AlarmHistoryEntry: {
            alarm?: components["schemas"]["AlarmHistoryData"];
            /** @description The index of the history entry within the entries for a single alarm.. */
            index?: string;
        };
        AlarmNamespaceAndName: {
            /** @description The name of an alarm */
            name?: string;
            /** @description The namespace of an alarm */
            namespace?: string;
        };
        AlarmTarget: {
            /** @description Name of the target node. */
            name?: string;
        };
        AuthPasswordPolicy: {
            /** @description If true, prevents passwords from being or containing the user name. */
            allowUserName?: boolean;
            /**
             * Format: int64
             * @description Minimum number of digits required in a password. Can be zero.
             */
            digits?: number;
            /**
             * Format: int64
             * @description The maximum number of days until a password change is enforced.
             *     A value of zero means no change is required.
             */
            forceExpiredPasswordChange?: number;
            /**
             * @description The hashing algorithm to use when hashing stored passwords.
             * @enum {string}
             */
            hashingAlgorithm?: "argon2" | "pbkdf2-sha512" | "pbkdf2-sha256" | "pbkdf2";
            /**
             * Format: int64
             * @description Minimum password length.  This must be at least 1.
             */
            length?: number;
            /**
             * Format: int64
             * @description Minimum number of lower case characters required in a password. Can be zero.
             */
            lowerCase?: number;
            /**
             * Format: int64
             * @description The number of seconds before the users access will be restored, after too many authentication failures.
             */
            maxFailureWaitSeconds?: number;
            /**
             * Format: int64
             * @description The number of login/authentication failures before a lockout policy takes effect. Zero means no enforcement.
             */
            maxLoginFailure?: number;
            /**
             * Format: int64
             * @description The number of passwords remembered to enforce no re-use of passwords. Zero means no re-use enforcement.
             */
            passwordHistory?: number;
            /**
             * @description If true, lockout is permanent and the users access must be re-enabled by an administrator.
             *     If false, the users access will be re-enabled after "maxFailureWaitSeconds" seconds.
             */
            permanentLockout?: boolean;
            /**
             * Format: int64
             * @description When lockout is not permanent, the count of authentication failures for a user will be reset
             *     this many seconds after the last authentication failure.
             */
            resetTimeSeconds?: number;
            /**
             * Format: int64
             * @description Minimum number of special characters required in a password. Can be zero.
             */
            specialChars?: number;
            /**
             * Format: int64
             * @description Minimum number of upper case characters required in a password. Can be zero.
             */
            upperCase?: number;
        };
        AuthProvider: {
            auth?: components["schemas"]["AuthProvider_auth"];
            /** @description If true, checking/syncing this LDAP provider is enabled. */
            enabled?: boolean;
            groupSupport?: components["schemas"]["AuthProvider_groupSupport"];
            /** @description Name of the LDAP attribute, which is used as a unique object identifier (UUID) for objects in LDAP. */
            idAttribute: string;
            /** @description If true, the LDAP information will be imported into the EDA (Keycloak) database. */
            import?: boolean;
            /** @description The name to give to the LDAP provider; must be unique. */
            name: string;
            /** @description Set to true if the LDAP server supports pagination. */
            pagination?: boolean;
            /** @description If true, periodic synchronization of new changed or newly created LDAP users to Keycloak will occur. */
            periodicSync?: boolean;
            /**
             * Format: int64
             * @description If periodic sync is enabled, this is the period in seconds that synchronization will occur.
             */
            periodicSyncSecs?: number;
            /** @description Name of the LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as the Username LDAP attribute, however it is not required. */
            rdnLDAPAttribute: string;
            /**
             * @description If false, changes made to LDAP-mapped attribute via EDA will be synced back to the LDAP server.  Otherwise, changes are not made in LDAP.
             * @default true
             */
            readOnly: boolean;
            /**
             * @description Must be "One Level" or "Subtree".  If "One Level", the search applies only for users in the DNs specified by User DNs. If "Subtree", the search applies to the whole subtree.
             * @enum {string}
             */
            scope?: "One Level" | "Subtree";
            /**
             * Format: int64
             * @description LDAP connection timeout in milliseconds
             */
            timeout?: number;
            /** @description If true, encrypts the connection to LDAP using STARTTLS */
            tls?: boolean;
            /**
             * @description The type of provider.  Currently only "ldap" is supported.
             * @enum {string}
             */
            type: "ldap";
            /** @description Connection URL to your LDAP server */
            url: string;
            /** @description Full DN of LDAP tree where your users are. This DN is the parent of LDAP users. */
            userDN: string;
            /** @description All values of LDAP objectClass attribute for users in LDAP, divided by commas. (e.g. inetOrgPerson, organizationalPerson). */
            userObjectClasses: string;
            /** @description Additional LDAP filter for filtering searched users. Leave this empty if you don't need an additional filter. Make sure that it starts with '(' and ends with ')'. */
            userSearchFilter?: string;
            /** @description Name of the LDAP attribute, which is mapped as EDA username. For many LDAP server vendors it can be 'uid'. */
            usernameAttribute: string;
            /** @description The unique identifier given to the entry when it is created. */
            uuid?: string;
            /** @description LDAP vendor (provider). */
            vendor: string;
        };
        AuthProviderTestParams: {
            /**
             * @description The test action to take.
             * @enum {string}
             */
            action: "connection" | "authentication";
            auth?: components["schemas"]["ProviderAuth"];
            /** @description The name of the provider to test */
            name?: string;
            /**
             * Format: int64
             * @description LDAP connection timeout in milliseconds
             */
            timeout?: number;
            /** @description If true, encrypts the connection to LDAP using STARTTLS */
            tls?: boolean;
            /** @description Connection URL to your LDAP server */
            url: string;
        };
        AuthProviders: components["schemas"]["AuthProvider"][];
        AuthRole: {
            description: string;
            name: string;
            namespace?: string;
            /** @description Rules for access to resources. */
            resourceRules?: components["schemas"]["ResourceRule"][];
            /** @description Rules for access to EDB tables, including via EQL. */
            tableRules?: components["schemas"]["TableRule"][];
            /** @description Rules for access to APIServer routes. */
            urlRules?: components["schemas"]["UrlRule"][];
        };
        AuthRoles: components["schemas"]["AuthRole"][];
        AuthUser: {
            email?: string;
            enabled?: boolean;
            firstName?: string;
            /** @description contains the UUIDs of the groups of which the user is a member. */
            groups?: string[];
            lastName?: string;
            /** Format: int64 */
            maxSessions?: number;
            password?: string;
            status?: components["schemas"]["UserStatus"];
            username?: string;
            uuid?: string;
        };
        AuthUserGroup: {
            description?: string;
            /** @description contains the full user definitions of the users who are members of the group, if requested */
            "full-users"?: components["schemas"]["AuthUser"][];
            /** @description contains the full role definitions of the Roles and ClusterRoles associated with the group, if requested */
            fullRoles?: components["schemas"]["AuthRole"][];
            /** @description if true, indicates that the group was imported from a federated LDAP server */
            isFederated?: boolean;
            name?: string;
            /**
             * @description Contains the names of the ClusterRoles and Roles roles associated with the group.
             *     A Role name has the form "namesspace:rolename", whereas a ClusteRole name is a
             *     simple "rolename", without a colon or a namespace.
             */
            roles?: string[];
            /** @description contains the usernames of the users who are members of the group */
            users?: string[];
            uuid?: string;
        };
        AuthUserGroups: components["schemas"]["AuthUserGroup"][];
        AuthUsers: components["schemas"]["AuthUser"][];
        AutoCompleteDetails: {
            /** @description Accepted and ignored. */
            condition?: string;
            /**
             * @description The group name for a resource.
             *     Valid with gvk, gvr, or label selector autocomplete only.
             */
            group?: string;
            /**
             * @description The kind of the resource.
             *     Valid with gvk or label selector autocomplete only.
             */
            kind?: string;
            /**
             * @description The query input.
             *     Valid with query type autocomplete only.
             */
            query?: string;
            /**
             * @description A resource name.
             *     Valid with gvr autocomplete only.
             */
            resource?: string;
            /** @description Accepted and ignored. */
            subject?: boolean;
            /**
             * @description The table name.
             *     Valid with where or fields autocomplete only.
             */
            table?: string;
            /**
             * @description The table expression.
             *     Accepted and ignored.
             */
            "table-expression"?: string;
            /**
             * @description The table name as prefix.
             *     Valid with table autocomplete only.
             */
            "table-prefix"?: string;
            /**
             * @description The table prefix expression.
             *     Accepted and ignored.
             */
            "table-prefix-expression"?: string;
            /**
             * @description The type of autocompletion request.
             * @enum {string}
             */
            type: "query" | "gvk" | "gvr" | "label" | "table" | "where" | "fields" | "labelselector";
            /**
             * @description A resource version.
             *     Valid with gvk, gvr, or label selector autocomplete only.
             */
            version?: string;
        };
        /** The information which must be POSTed with an auto-complete request to guide the auto-complete process. */
        AutoCompleteRequest: {
            details: components["schemas"]["AutoCompleteDetails"];
            /**
             * Format: uint32
             * @description The maximum number of results to return
             */
            limit?: number;
            /** @description The namespace in which to search for completions */
            namespace?: string;
            /** @description A user input to be autocompleted */
            value: string;
        };
        /** @description The result of an auto-completion request */
        AutoCompleteResponse: {
            /**
             * @description The action to take with the "completion" field of each completion.
             *     Only relevant/present if no "error" is present.
             * @default append
             * @enum {string}
             */
            action: "append" | "replace";
            /** @description A list of possible auto-complete results. Only one of "error" or "completions" will be present. */
            completions?: components["schemas"]["AutoCompletion"][];
            error?: components["schemas"]["ErrorResponse"];
        };
        AutoCompletion: {
            /** @description The completion result.  Depending on the "action" field in the enclosing response, should either be appended-to, or replace the input if the user selects this completion. */
            completion: string;
            /** @description Intended to be displayed to the user as to indicate the result of this completion. */
            token: string;
        };
        /** Format: uint32 */
        ChatResponseType: number;
        /** @description Body of a checkAccess request. Contains a key and AccessQuery for each resource/url/table to be checked for user access */
        CheckAccessRequest: {
            [key: string]: components["schemas"]["AccessQuery"];
        };
        /** @description Body of a access check response. Contains an AccessResult for each of the keys provided in the request */
        CheckAccessResponse: {
            [key: string]: components["schemas"]["AccessResult"];
        };
        ConversationHistory: {
            /**
             * Format: date-time
             * @description Time when the conversation was created
             */
            created?: string;
            /** @description Conversation ID */
            id?: string;
            /**
             * Format: date-time
             * @description Time when the conversation was last updated
             */
            lastUpdated?: string;
            /**
             * Format: int32
             * @description Number of messages in the conversation
             */
            messageCount?: number;
            /** @description List of messages in the conversation */
            messages?: components["schemas"]["ConversationHistoryMessage"][];
            /** @description Conversation name */
            name?: string;
        };
        ConversationHistoryMessage: {
            role?: components["schemas"]["ConversationHistoryRole"];
            type?: components["schemas"]["ChatResponseType"];
            /** @description The content of the message returned from ai */
            value?: Record<string, never>;
        };
        ConversationHistoryRole: string;
        ConversationInfo: {
            /**
             * Format: date-time
             * @description Time when the conversation was created
             */
            created?: string;
            /** @description Conversation ID */
            id?: string;
            /**
             * Format: date-time
             * @description Time when the conversation was last updated
             */
            lastUpdated?: string;
            /**
             * Format: int32
             * @description Number of messages in the conversation
             */
            messageCount?: number;
            /** @description Conversation name */
            name?: string;
        };
        ConversationList: components["schemas"]["ConversationInfo"][];
        CrAnnotation: {
            cr?: components["schemas"]["NsCrGvkName"];
            lines?: components["schemas"]["LineSegment"][];
        };
        /** Credentials (password) for a user. This can never be retrieved from the system. */
        Credentials: {
            /**
             * @description This is true if the password being set is a temporary password.  In this case the user
             *     is required to change the password after they login using the temporary password.
             */
            temporary?: boolean;
            /** @description The new password for the user. */
            value?: string;
        };
        /** Wrapper for index information inside an error. */
        ErrorIndex: {
            /** Format: int64 */
            index?: number;
        };
        ErrorItem: {
            error?: Record<string, never>;
            type?: string;
        };
        /** Generic error response for REST APIs. */
        ErrorResponse: {
            /**
             * @description A lower-level set of structured errors.
             *
             *     Only oneOf `causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection` will ever be set.
             */
            causeCollection?: components["schemas"]["ErrorResponse"][];
            /**
             * @description A lower-level set of structured errors.
             *     Each of these errors MUST have index set.
             *
             *     Only oneOf `causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection` will ever be set.
             */
            causeIndexedCollection?: components["schemas"]["ErrorResponse"][];
            /** @description If true, then the cause (`causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection`) should be hidden from the user. */
            causeIsInternal?: boolean;
            /**
             * @description Simple string error type.
             *
             *     Only oneOf `causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection` will ever be set.
             */
            causeSimple?: string;
            causeWrapped?: components["schemas"]["ErrorResponse"];
            /**
             * Format: int64
             * @deprecated
             * @description the numeric HTTP error code for the response.
             *
             *     Deprecated: Prefer to check the request's HTTP response code directly.
             */
            code?: number;
            /**
             * @deprecated
             * @description The optional details of the error response.
             *     Deprecated: Replaced by `causeSimple`.
             */
            details?: string;
            /**
             * @deprecated
             * @description Dictionary/map of associated data/information relevant to the error.
             *     The error "message" may contain {{name}} escapes that should be substituted
             *     with information from this dictionary.
             *
             *     Deprecated: Use "values" instead.
             */
            dictionary?: {
                [key: string]: unknown;
            };
            /**
             * @description The "domain" for the error.  If empty, it is an EDA
             *     core error.  Alternatively it can be an EDA application
             *     "apiVersion" value (e.g. interfaces.eda.nokia.com/v1alpha1)
             *     indicating that the error is specific to that application.
             *     The domain gives the receiver information that they can use
             *     to help them interpret the "type" field.
             */
            domain?: string;
            /**
             * @deprecated
             * @description Collection of errors in cases where more than one exists.
             *     This needs to be flexible so we can support multiple formats.
             *     Deprecated: Replaced by `causeCollection` or `causeIndexedCollection` instead.
             */
            errors?: components["schemas"]["ErrorItem"][];
            index?: components["schemas"]["ErrorIndex"];
            /**
             * Format: int64
             * @deprecated
             * @description Internal error code number.
             *
             *     Deprecated: "type" & "domain" should be used instead to uniquely identify this error.
             */
            internal: number;
            /** @description The basic text error message for the error response. */
            message: string;
            /** @description Reference to the error source. Should typically be the URI of the request. */
            ref?: string;
            /**
             * @description Type defines a unique identifier for the error, within the domain.
             *     This may be used (along with the domain) to find an internationalization translation for the message.
             *
             *     SHOULD be a valid golang identifier, and SHOULD be in UpperCamelCase.
             */
            type: string;
            /**
             * @description Associated data/information.
             *     The error "message" may contain {{name}} escapes that should be substituted with information from this dictionary.
             *
             *     Note that this map MUST NOT contain JSON objects (`{...}`) or arrays (`[...]`), only simple JSON types are permitted.
             */
            values?: {
                [key: string]: Record<string, never>;
            };
        };
        GetLabelCompletionRequest: {
            gvk?: components["schemas"]["GroupVersionKind"];
            /**
             * Format: uint32
             * @description The maximum number of results to return
             */
            limit?: number;
            /**
             * @description The namespace of the GVK if the CRD is namespaced
             *     required: true if the GVK is namespaced
             */
            namespace?: string;
            /**
             * @description A key value string delimited by =.  If the Value does not include an =
             *     it is assumed to be a Key lookup.  If there is an =, everything before
             *     the = is assumed to be the key and the lookup will be a value lookup
             */
            value: string;
        };
        /** @description The UUID of an EDA user group */
        GroupID: string;
        /** A list of user group identifiers (uuid values). */
        GroupIDs: components["schemas"]["GroupID"][];
        GroupVersionKind: {
            /** @description Name of the API group */
            group?: string;
            /** @description The Kind of the resource */
            kind?: string;
            /** @description Version of the API group */
            version?: string;
        };
        GroupVersionResource: {
            /** @description Name of the API group */
            group?: string;
            /** @description The plural name of the resource */
            resource?: string;
            /** @description Version of the API group */
            version?: string;
        };
        /** Structure containing a health report for the EDA cluster. */
        Health: {
            /**
             * @description Indication of the activity of this cluster.
             * @enum {string}
             */
            mode: "ACTIVE" | "STANDBY";
            /** @description Detailed health of the services comprising the EDA cluster.  Keyed by the name of the service. */
            services?: {
                [key: string]: components["schemas"]["HealthServiceStatus"];
            };
            /**
             * @description Overall health status of the EDA cluster.
             * @enum {string}
             */
            status: "UP" | "DEGRADED" | "DOWN";
            /**
             * Format: date-time
             * @description Time that the health report was generated.
             */
            timestamp: string;
        };
        /** Structure containing a health report for a particular service. */
        HealthServiceStatus: {
            /** @description Detailed status if the service is not up. */
            error?: string;
            /**
             * @description Health status of the given service.  UP or DOWN.
             * @enum {string}
             */
            status: "UP" | "DOWN";
        };
        Identifier: {
            group?: string;
            /** Format: int64 */
            id?: number;
            kind?: string;
            name?: string;
            namespace?: string;
            version?: string;
        };
        /** @description The definition for a JSON patch for a resource, as in RFC 6902 */
        K8SPatchOp: {
            /**
             * @description Only applies to a "move" operation, and is the path to the field/value within
             *     the target JSON object that should be moved to the location specified by the "path"
             *     field.
             * @example /a/b/c
             */
            from?: string;
            /**
             * @description The type of operation this patch should perform.
             * @example replace
             * @enum {string}
             */
            op: "add" | "remove" | "replace" | "move" | "copy" | "test";
            /**
             * @description The path to the field within the target JSON object
             *     that should be patched according to the "op" field.
             * @example /a/b/d
             */
            path: string;
            /**
             * @description This field would be set to the value which the user intends to put in the
             *     field referenced by the "path" field.  The type of the value should match
             *     the type of the field as indicated by the schema of the resource being
             *     patched.
             * @example example for a string field
             */
            value?: string | number | boolean | unknown[] | Record<string, never>;
            /**
             * @description For an "add" operation, an already-present field referenced by the "path" will
             *     result in an error unless this field is true.  Similarly for a non-existent
             *     target field of a "remove" operation.
             */
            "x-permissive"?: boolean;
        };
        LabelCompletionResponse: {
            results?: string[];
        };
        LineSegment: {
            /** Format: uint32 */
            endLine?: number;
            /** Format: uint32 */
            startLine?: number;
        };
        Metadata: {
            annotations?: {
                [key: string]: string;
            };
            labels?: {
                [key: string]: string;
            };
            name: string;
            namespace?: string;
        };
        /** @description Information about an individual namespace */
        NamespaceData: {
            /** @description The description of the namespace */
            description?: string;
            /** @description The namespace name */
            name?: string;
        };
        /** @description Body of the non streaming namespace get request */
        NamespaceGetResponse: {
            /** @description If true, the requestor is considered to have permission to access all namespaces */
            allNamesapces?: boolean;
            /** @description The list of namespaces */
            namespaces?: components["schemas"]["NamespaceData"][];
        };
        NodeConfigResponse: {
            /** @description The the list of annotations for the node configuration */
            annotations?: components["schemas"]["CrAnnotation"][];
            /** @description The current node configuration for the node */
            running?: string;
        };
        NsCrGvkName: {
            gvk?: components["schemas"]["GroupVersionKind"];
            name?: string;
            namespace?: string;
        };
        OperationType: string;
        Overlay: {
            endpoint_attr_queries?: components["schemas"]["TopoOverlayAttrQuery"][];
            endpoint_state?: components["schemas"]["TopoOverlayStateMetadata"][];
            endpoint_state_heading?: string;
            endpoint_state_heading_key?: string;
            group?: string;
            link_attr_queries?: components["schemas"]["TopoOverlayAttrQuery"][];
            link_state?: components["schemas"]["TopoOverlayStateMetadata"][];
            link_state_heading?: string;
            link_state_heading_key?: string;
            name?: string;
            node_attr_queries?: components["schemas"]["TopoOverlayAttrQuery"][];
            node_badge?: components["schemas"]["TopoOverlayBadgeMetadata"][];
            node_state?: components["schemas"]["TopoOverlayStateMetadata"][];
            node_state_heading?: string;
            node_state_heading_key?: string;
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
            version?: string;
        };
        OverlayState: {
            link_groups?: {
                [key: string]: components["schemas"]["TopoOverlayLinkGroup"];
            };
            links?: {
                [key: string]: components["schemas"]["TopoOverlayLink"];
            };
            nodes?: {
                [key: string]: components["schemas"]["TopoOverlayNode"];
            };
            nodes_and_groups?: {
                [key: string]: components["schemas"]["TopoOverlayNodeOrGroup"];
            };
        };
        Overlays: components["schemas"]["Overlay"][];
        Patch: components["schemas"]["K8SPatchOp"][];
        ProviderAuth: {
            /** @description Credentials to use when binding to an LDAP provider */
            bindCredential: string;
            /** @description DN to use when binding to an LDAP provider */
            bindDN: string;
        };
        QueryCompletion: {
            completion?: string;
            token?: string;
        };
        /** @description The result of a successful query auto-completion request */
        QueryCompletionResponse: {
            /** @description Array of possible auto-completion results. */
            completions?: components["schemas"]["QueryCompletion"][];
        };
        QueryConvertRequest: {
            jsPath?: string;
        };
        QueryConvertResponse: {
            query?: string;
            table?: string;
            whereClause?: string;
        };
        /** @description The response for a non-streaming query request */
        QueryResponse: {
            data?: Record<string, never>[];
            /** @description The JSON schema definition for the query data being returned. */
            jsonSchema?: Record<string, never>;
        };
        /** A role rule controlling access to a kubernetes resource. */
        ResourceRule: {
            /**
             * @description The API groups for the resources controlled by the rule.
             *     An API group consists of an apiGroup and a version, e.g. "apigroup/version".
             *     The API group can be a wildcard ("*"), in which case it will match any API group.
             *     In addition, the version can be a wildcard.
             */
            apiGroups: string[];
            /**
             * @description Permissions for resources specified by the rule.
             * @enum {string}
             */
            permissions?: "none" | "read" | "readWrite";
            /**
             * @description Names for the resources controlled by the rule.
             *     It can be a wildcard ("*"), in which case it will match any resource
             *     in the matching API groups.
             */
            resources: string[];
        };
        StoreAppInstalledSettings: {
            /** @description The application identifier. */
            appId?: string;
            /** @description The settings for the application as a JSON object. */
            settings?: {
                [key: string]: Record<string, never>;
            };
        };
        StoreAppManifest: {
            /** @description The application manifest as JSON */
            manifest?: {
                [key: string]: Record<string, never>;
            };
            metadata?: components["schemas"]["StoreAppVersionMetadata"];
            version?: components["schemas"]["StoreAppVersion"];
        };
        StoreAppRequirementsGraph: {
            /** @description The items in the requirements graph resulting from the request.  Only present if the state is FINISHED. */
            graphItems?: components["schemas"]["StoreAppRequirementsGraphItem"][];
            /**
             * @description The state of the requirements graph generation request.
             * @enum {string}
             */
            state?: "UNKNOWN" | "RUNNING" | "FINISHED" | "FAILED";
        };
        StoreAppRequirementsGraphItem: {
            /** @description The application identifier to which the 'requires' elements of graph items will refer. */
            appId: string;
            installedAppVersion?: components["schemas"]["StoreAppRequirementsGraphItem_installedAppVersion"];
            /** @description The identifiers for the applications on which this application version depends. */
            requires?: string[];
            targetAppVersion: components["schemas"]["StoreAppRequirementsGraphItem_targetAppVersion"];
        };
        StoreAppSettingsDefinition: {
            /** @description The application identifier */
            appId?: string;
            /** @description The settings definition for the application as a JSON object. */
            definition?: {
                [key: string]: Record<string, never>;
            };
        };
        StoreAppSummary: {
            /** @description Unique ID identifying this application */
            appId?: string;
            /** @description Catalogs where this app was found */
            catalogs?: string[];
            /** @description Application categories. */
            categories?: string[];
            /** @description Application description that can be used for user display purposes */
            description?: string;
            /** @description Application has settings */
            hasSettings?: boolean;
            infoVersion?: components["schemas"]["StoreAppVersion"];
            infoVersionMetadata?: components["schemas"]["StoreAppVersionMetadata"];
            /** @description "true" if the app is installed */
            installed?: boolean;
            installedVersion?: components["schemas"]["StoreAppVersion"];
            installedVersionMetadata?: components["schemas"]["StoreAppVersionMetadata"];
            latestVersion?: components["schemas"]["StoreAppVersion"];
            latestVersionMetadata?: components["schemas"]["StoreAppVersionMetadata"];
            /** @description Application supported endpoints. */
            supportedEndpoints?: string[];
            /** @description Application title that can be used for user display purposes */
            title?: string;
            /** @description "true" if there is a new version that can be installed */
            upgradable?: boolean;
            /** @description Name of the vendor for this app */
            vendor?: string;
        };
        StoreAppSummaryList: components["schemas"]["StoreAppSummary"][];
        /**
         * Application version information
         * @description The information about an application version available from a catalog.
         *     At least one of "semVer" or "commitHash" must/will be defined.
         */
        StoreAppVersion: {
            /** @description The identifier for the application */
            appId?: string;
            /** @description The catalog in which this application version was found */
            catalog?: string;
            /** @description The commit hash for the application version. */
            commitHash?: string;
            /** @description The semantic version for the application version. */
            semVer?: string;
        };
        StoreAppVersionList: components["schemas"]["StoreAppVersionWithMetadata"][];
        /** The metadata associated with an application version. */
        StoreAppVersionMetadata: {
            /**
             * Format: date-time
             * @description The date and time when the application version was published.
             */
            publishedTime?: string;
        };
        StoreAppVersionWithMetadata: {
            metadata?: components["schemas"]["StoreAppVersionMetadata"];
            version?: components["schemas"]["StoreAppVersion"];
        };
        StoreCategoryList: string[];
        /**
         * @description A role rule controlling access to a EDB table.  Note that
         *     there is never write access to EDB.
         */
        TableRule: {
            /**
             * @description EDB path to which this rule applies. It can end in ".*"
             *     in which case the final portion of the table path can be anything, if the
             *     prefix matches. It can end in ".**" in which case the table path can be
             *     anything if the prefix matches.
             */
            path: string;
            /**
             * @description Permissions for the given EDB path.
             * @enum {string}
             */
            permissions: "none" | "read";
        };
        TopoAttrMetadata: {
            type?: string;
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
        };
        TopoAttribute: {
            name?: string;
        };
        TopoBoolExpression: {
            endpoint_expression?: components["schemas"]["TopoEndpointBoolExpression"];
            fixed_expression?: components["schemas"]["TopoFixedBoolExpression"];
            has_badge?: components["schemas"]["TopoLiteralStatusOrBadge"];
            label?: components["schemas"]["TopoLabelSelector"];
            literal?: components["schemas"]["TopoBoolLiteral"];
            logical?: components["schemas"]["TopoLogicalExpression"];
            not?: components["schemas"]["TopoBoolExpression"];
            value_expression?: components["schemas"]["TopoValueExpression"];
        };
        TopoBoolLiteral: {
            value?: boolean;
        };
        TopoElemMetadata: {
            attributes?: {
                [key: string]: components["schemas"]["TopoAttrMetadata"];
            };
            schema?: components["schemas"]["TopoSchema"];
            subtitle?: string;
            subtitle_key?: string;
        };
        TopoEndpointBoolExpression: {
            endpoint?: string;
            expression?: components["schemas"]["TopoBoolExpression"];
        };
        TopoField: {
            type?: string;
        };
        TopoFixedBoolExpression: {
            type?: string;
        };
        TopoGroupingStateRequest: {
            name?: string;
            spec?: components["schemas"]["TopologyStateGroupingBase"];
        };
        TopoLabelSelector: {
            selector?: string[];
        };
        TopoLiteralStatusOrBadge: {
            overlay?: string;
            /** Format: int64 */
            value?: number;
        };
        TopoLiteralValue: {
            badge?: components["schemas"]["TopoLiteralStatusOrBadge"];
            bool?: boolean;
            /** Format: double */
            number?: number;
            status?: components["schemas"]["TopoLiteralStatusOrBadge"];
            string?: string;
        };
        TopoLogicalExpression: {
            left?: components["schemas"]["TopoBoolExpression"];
            operation?: string;
            right?: components["schemas"]["TopoBoolExpression"];
        };
        TopoNodeGrouping: {
            group?: string;
            group_key?: string;
            /** Format: int64 */
            tier?: number;
        };
        TopoOverlayAttrMetadata: {
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
        };
        TopoOverlayAttrQuery: {
            attributes?: {
                [key: string]: components["schemas"]["TopoOverlayAttrMetadata"];
            };
            query?: string;
        };
        TopoOverlayBadgeMetadata: {
            badge_name?: string;
            badge_path?: string;
            color?: string;
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
            /** Format: int64 */
            value?: number;
        };
        TopoOverlayEndpoint: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            node?: string;
            node_key?: string;
            overlays?: {
                [key: string]: components["schemas"]["TopoOverlayEndpointState"];
            };
            schema?: components["schemas"]["TopoSchema"];
            ui_name?: string;
        };
        TopoOverlayEndpointState: {
            /** Format: int64 */
            state?: number;
        };
        TopoOverlayLink: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            endpoint_a?: components["schemas"]["TopoOverlayEndpoint"];
            endpoint_a_name?: string;
            endpoint_b?: components["schemas"]["TopoOverlayEndpoint"];
            endpoint_b_name?: string;
            group_key?: string;
            key?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            overlays?: {
                [key: string]: components["schemas"]["TopoOverlayLinkState"];
            };
            schema?: components["schemas"]["TopoSchema"];
            ui_name?: string;
        };
        TopoOverlayLinkGroup: {
            endpoint_a?: components["schemas"]["TopoOverlayLinkGroupEndpoint"];
            endpoint_b?: components["schemas"]["TopoOverlayLinkGroupEndpoint"];
            key?: string;
            overlays?: {
                [key: string]: components["schemas"]["TopoOverlayLinkState"];
            };
        };
        TopoOverlayLinkGroupEndpoint: {
            group_key?: string;
            node_key?: string;
        };
        TopoOverlayLinkState: {
            /** Format: int64 */
            state?: number;
        };
        TopoOverlayNode: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            grouping?: components["schemas"]["TopoNodeGrouping"];
            key?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            overlays?: {
                [key: string]: components["schemas"]["TopoOverlayNodeState"];
            };
            schema?: components["schemas"]["TopoSchema"];
            ui_name?: string;
        };
        TopoOverlayNodeOrGroup: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            grouping?: components["schemas"]["TopoNodeGrouping"];
            key?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            /** Format: int64 */
            num_nodes?: number;
            overlays?: {
                [key: string]: components["schemas"]["TopoOverlayNodeState"];
            };
            schema?: components["schemas"]["TopoSchema"];
            type?: string;
            ui_name?: string;
        };
        TopoOverlayNodeState: {
            badges?: number[];
            /** Format: int64 */
            state?: number;
        };
        TopoOverlayStateMetadata: {
            color?: string;
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
            /** Format: int64 */
            value?: number;
        };
        TopoOverlayValue: {
            overlay?: string;
        };
        TopoSchema: {
            group?: string;
            kind?: string;
            version?: string;
        };
        TopoStateFilter: {
            expand_all_link_groups?: boolean;
            expand_all_node_groups?: boolean;
            expanded_link_groups?: string[];
            expanded_node_groups?: string[];
            link_filter?: components["schemas"]["TopoBoolExpression"];
            node_filter?: components["schemas"]["TopoBoolExpression"];
        };
        TopoStateRequest: {
            filter?: components["schemas"]["TopoStateFilter"];
            grouping?: components["schemas"]["TopoGroupingStateRequest"];
            namespace?: string;
            overlays?: string[];
        };
        TopoValue: {
            attribute?: components["schemas"]["TopoAttribute"];
            badge?: components["schemas"]["TopoOverlayValue"];
            field?: components["schemas"]["TopoField"];
            literal?: components["schemas"]["TopoLiteralValue"];
            status?: components["schemas"]["TopoOverlayValue"];
        };
        TopoValueExpression: {
            left?: components["schemas"]["TopoValue"];
            operation?: string;
            right?: components["schemas"]["TopoValue"];
        };
        Topologies: components["schemas"]["Topology"][];
        Topology: {
            endpoints?: components["schemas"]["TopoElemMetadata"];
            group?: string;
            grouping?: components["schemas"]["TopoSchema"];
            links?: components["schemas"]["TopoElemMetadata"];
            name?: string;
            nodes?: components["schemas"]["TopoElemMetadata"];
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
            version?: string;
        };
        TopologyGroupingInstance: {
            /** @description The group/version for the topology grouping data. */
            apiVersion?: string;
            /** @description The kind for the topology grouping data. */
            kind?: string;
            metadata?: components["schemas"]["TopologyGroupingInstance_metadata"];
            spec?: {
                [key: string]: Record<string, never>;
            };
            status?: {
                [key: string]: Record<string, never>;
            };
        };
        TopologyGroupingsList: {
            /** @description The group/version for the topology grouping data. */
            apiVersion?: string;
            /** @description The metadata kind for the topology grouping data. */
            items?: components["schemas"]["TopologyGroupingInstance"][];
            /** @description The kind for the topology grouping data. */
            kind?: string;
        };
        TopologyStateGroupSelector: {
            /**
             * @description The group to assign to nodes that match the selector.
             *     +eda:ui:title="Group"
             */
            group?: string;
            /**
             * @description +kubebuilder:validation:Optional
             *     +eda:ui:title="Node Selector"
             *     +eda:ui:format="labelselector"
             *     Label selector to use to match nodes that should be assigned to this group.
             */
            nodeSelector?: string[];
        };
        /**
         * @description Embed this type inside your topology tier CRD spec to determine the tiers and the
         *     groups of the nodes in the topology.
         */
        TopologyStateGroupingBase: {
            /**
             * @description The set of selectors for assigning nodes to groups
             *     +eda:ui:title="Group Selectors"
             */
            groupSelectors?: components["schemas"]["TopologyStateGroupSelector"][];
            /**
             * @description The set of selectors for assigning nodes to tiers
             *     +eda:ui:title="Tier Selectors"
             */
            tierSelectors?: components["schemas"]["TopologyStateTierSelector"][];
            /**
             * @description A description of the topology grouping to expose in the UI
             *     +eda:ui:title="UI Description"
             */
            uiDescription?: string;
            /**
             * @description The translation key for the description of the topology grouping to expose in the UI
             *     +eda:ui:title="UI Description Key"
             */
            uiDescriptionKey?: string;
            /**
             * @description The name of the topology grouping to expose in the UI
             *     +eda:ui:title="UI Name"
             */
            uiName?: string;
            /**
             * @description The translation key for the name of the topology grouping to expose in the UI
             *     +eda:ui:title="UI Name Key"
             */
            uiNameKey?: string;
        };
        TopologyStateTierSelector: {
            /**
             * @description +kubebuilder:validation:Optional
             *     +eda:ui:title="Node Selector"
             *     +eda:ui:format="labelselector"
             *     Label selector to use to match nodes that should be assigned to this tier.
             */
            nodeSelector?: string[];
            /**
             * Format: uint32
             * @description The tier to assign to nodes that match the selector.
             *     +eda:ui:title="Tier"
             */
            tier?: number;
        };
        /** Request body content for a POST transaction request. */
        Transaction: {
            /** @description List of CRs to include in the transaction */
            crs: components["schemas"]["TransactionCr"][];
            /** @description Description/commit message for the transaction */
            description: string;
            /**
             * @description The detail level requested for transaction results.
             * @default standard
             * @enum {string}
             */
            detailLevel: "standard" | "detailed";
            /**
             * @description If true the transaction will not be allowed to be batched with other transactions.
             *
             *     Note that setting this to true can have an adverse impact on performance.
             * @default false
             */
            disableBatching: boolean;
            /**
             * @description If true the transaction will not be committed and will run in dry run mode.  If false the
             *     transaction will be committed
             */
            dryRun: boolean;
            /**
             * @deprecated
             * @description The type of results requested.
             *     Deprecated: "detailLevel" should be used instead.
             * @enum {string}
             */
            resultType?: "errors_only" | "normal" | "debug";
            /**
             * @deprecated
             * @description Deprecated: retain after results fetched - e.g. after call to get transaction result
             * @default false
             */
            retain: boolean;
        };
        TransactionAppError: {
            rawError?: string;
            structuredError?: components["schemas"]["TransactionStructuredAppError"];
        };
        TransactionContent: {
            apiVersion?: string;
            kind?: string;
            metadata?: components["schemas"]["Metadata"];
            spec?: Record<string, never>;
        };
        TransactionCr: {
            type?: components["schemas"]["TransactionType"];
        };
        TransactionExecutionResult: {
            /** @description List of changed CRs as part of the transaction */
            changedCrs?: components["schemas"]["TransactionNsCrGvkNames"][];
            /** @description Information about time taken during processing */
            executionSummary?: string;
            /** @description List of general errors while running the transaction */
            generalErrors?: string[];
            /** @description List of intents which ran as part of the transaction */
            intentsRun?: components["schemas"]["TransactionIntentResult"][];
            /** @description List of nodes with configuration changes from the transaction */
            nodesWithConfigChanges?: components["schemas"]["TransactionNodeResult"][];
            /** @description Whether a topology representation of this transaction is supported */
            topologySupported?: boolean;
        };
        TransactionId: {
            /**
             * Format: uint64
             * @description A transaction identifier; these are assigned by the system to a posted transaction.
             */
            id?: number;
        };
        TransactionInputResource: {
            data?: {
                [key: string]: Record<string, never>;
            };
            isDelete?: boolean;
            name?: components["schemas"]["NsCrGvkName"];
            operation?: components["schemas"]["OperationType"];
        };
        TransactionIntentResult: {
            errors?: components["schemas"]["TransactionAppError"][];
            intentName?: components["schemas"]["NsCrGvkName"];
            outputCrs?: components["schemas"]["NsCrGvkName"][];
            script?: components["schemas"]["TransactionScriptResults"];
        };
        /**
         * @description The name of a node with changes from a transaction, and a list
         *     of errors that occurred for the node
         */
        TransactionNodeResult: {
            /** @description Resulting errors for the node */
            errors?: string[];
            /** @description The name of the node */
            name?: string;
            /** @description The namespace of the node */
            namespace?: string;
        };
        TransactionNsCrGvkNames: {
            gvk?: components["schemas"]["GroupVersionKind"];
            names?: string[];
            namespace?: string;
        };
        TransactionPatch: {
            patchOps: components["schemas"]["Patch"];
            target: components["schemas"]["NsCrGvkName"];
        };
        TransactionResultInputResources: {
            /** @description List of input resources from the transaction */
            inputCrs?: components["schemas"]["TransactionInputResource"][];
            /** @description This field is true if the list returned here is not the complete list of input resources in the transaction because the user does not have read-access to some of them */
            limitedAccess?: boolean;
        };
        TransactionResultObject: {
            after?: components["schemas"]["TransactionResultObjectString"];
            before?: components["schemas"]["TransactionResultObjectString"];
            /** @description True if there is no data available for the result */
            dataUnavailable?: boolean;
            /** @description The format of the response - Text or YAML */
            format?: string;
        };
        TransactionResultObjectString: {
            data?: string;
        };
        TransactionRevertRestoreRequest: {
            /**
             * @description The detail level requested for transaction results for the transaction resulting from the revert/restore.
             * @default standard
             * @enum {string}
             */
            detailLevel: "standard" | "detailed";
            /**
             * @description If true the operation will not be committed and will run in dry run mode.  If false the
             *     operation will be committed
             */
            dryRun?: boolean;
        };
        TransactionScriptResults: {
            /** Format: uint32 */
            executionTime?: number;
        };
        TransactionState: {
            /**
             * @description The state of the transaction
             * @enum {string}
             */
            state?: "unknownTid" | "queued" | "running" | "complete";
        };
        TransactionStructuredAppError: {
            message?: string;
            messageKey?: string;
            values?: {
                [key: string]: Record<string, never>;
            };
        };
        /** @description Summary of the result of a transaction */
        TransactionSummaryResult: {
            /**
             * Format: uint64
             * @description If present (and non-zero) indicates that the execution of this transaction was bundled into the transaction with this identifier.
             */
            bundledTransactionId?: number;
            /** @description The git commit hash for the transaction */
            commitHash?: string;
            /** @description The description of the transaction, as posted in the transaction request. */
            description?: string;
            /**
             * @description The level of detail available in the transaction details.
             * @enum {string}
             */
            detailLevel?: "basic" | "standard" | "detailed";
            /**
             * @deprecated
             * @description The type of details available for the transaction, as posted in the transaction request.
             *     Deprecated: use "detailLevel" instead.
             * @enum {string}
             */
            details?: "errors_only" | "normal" | "debug";
            /** @description If true the transaction was not committed and ran in dry run mode. */
            dryRun?: boolean;
            /**
             * Format: uint64
             * @description The transaction identifier
             */
            id?: number;
            /** @description The time that the transaction completed. */
            lastChangeTimestamp?: string;
            /** @description The state of the transaction. */
            state?: string;
            /** @description True if the transaction was successful. */
            success?: boolean;
            /** @description The user who posted the transaction. */
            username?: string;
        };
        TransactionSummaryResults: {
            /** @description array of summary-results for transactions */
            results?: components["schemas"]["TransactionSummaryResult"][];
        };
        TransactionTopologyResult: {
            overlayMetadata?: components["schemas"]["Overlay"];
            topology?: components["schemas"]["OverlayState"];
            topologyMetadata?: components["schemas"]["Topology"];
        };
        TransactionType: {
            create?: components["schemas"]["TransactionValue"];
            delete?: components["schemas"]["NsCrGvkName"];
            modify?: components["schemas"]["TransactionValue"];
            patch?: components["schemas"]["TransactionPatch"];
            replace?: components["schemas"]["TransactionValue"];
        };
        TransactionValue: {
            value?: components["schemas"]["TransactionContent"];
        };
        /** A role rule controlling access to an API server endpoint/route. */
        UrlRule: {
            /**
             * @description The API server URL path to which this rule applies. It can end in "/*"
             *     in which case the final portion of the URL path can be anything, if the
             *     prefix matches. It can end in "/**" in which case the URL path can be
             *     anything if the prefix matches.",
             */
            path: string;
            /**
             * @description The permissions for the API server URL for the rule.
             * @enum {string}
             */
            permissions?: "none" | "read" | "readWrite";
        };
        UserStatus: {
            /** Format: int64 */
            failedLoginSinceSuccessfulLogin?: number;
            /** @description The name of the federation provider for this user. Absent if the user is not federated */
            federationProviderName?: string;
            /** @description The UUID of the federation provider for this user. Absent if the user is not federated */
            federationProviderUUID?: string;
            /** @description True if the user comes from a federated LDAP server */
            isFederatedUser?: boolean;
            lastFailedLogin?: string;
            lastSuccessfulLogin?: string;
            temporarilyDisabled?: boolean;
        };
        /** request body contents for a PUT/POST file user-storage request. */
        UserStorageInFileContent: {
            /** @description The desired content of the user-storage file. This will be base64 decoded before storing if the request indicates that the content is base64 encoded. */
            "file-content": string;
        };
        /** The data returned to the client from a GET directory user-storage request. */
        UserStorageOutDirContent: {
            /** @description path for the directory within the users storage */
            "directory-path": string;
            /** @description array of entries for the items in the directory */
            entries: components["schemas"]["UserStorageOutDirEntry"][];
        };
        /** @description user-storage directory entry */
        UserStorageOutDirEntry: {
            /**
             * Format: date-time
             * @description modification type of the item, if a file
             */
            "modification-time"?: string;
            /** @description name of the item within the directory */
            name: string;
            /** @description type of the item; "file" or "directory" */
            type: string;
        };
        UserStorageOutFileContent: {
            /** @description content of the file, will be base64 encoded if the request asked for this */
            "file-content"?: string;
            /**
             * @description if present and true, indicates the file has been deleted; used for
             *     streamed responses
             */
            "file-deleted"?: boolean;
            /** @description name of the file */
            "file-name": string;
            /**
             * Format: date-time
             * @description UTC modification time of the file, as an RFC 3339 date/time.
             *     Not valid if file-deleted is true (in a streamed response)
             */
            "modification-time"?: string;
        };
        WorkflowStatusSummary: {
            creationTime?: string;
            group?: string;
            /** Format: int64 */
            id?: number;
            kind?: string;
            lastUpdate?: string;
            name?: string;
            namespace?: string;
            parent?: components["schemas"]["Identifier"];
            rootWorkflow?: components["schemas"]["Identifier"];
            /** @enum {string} */
            state?: "OK" | "Failed" | "Terminated" | "WaitingForInput" | "Running" | "WaitingToStart" | "SubflowWaitingForInput" | "Completed";
            username?: string;
            version?: string;
        };
        /**
         * DB get endpoint result
         * @description Each key is the "jsPath" of the table row, and each value is the data for that row.
         */
        dbGetResult: {
            [key: string]: Record<string, never>;
        };
        /** Version information for a single component. */
        singleVersionInfo: {
            /** @description The build-time for the component. */
            builtDate?: string;
            /** @description The version string for the component. */
            version?: string;
        };
        transactionTopologyRequest: {
            filter?: components["schemas"]["TopoStateFilter"];
        };
        /** Version information for subsystems and the overall EDA product. */
        versionInfo: {
            [key: string]: components["schemas"]["singleVersionInfo"];
        };
        /** @description If present, bind to LDAP server with the given credentials.  Otherwise do not bind. */
        AuthProvider_auth: {
            /** @description Credentials to use when binding to an LDAP provider */
            bindCredential: string;
            /** @description DN to use when binding to an LDAP provider */
            bindDN: string;
        };
        /** @description Configuration for group import/sync with LDAP.  If not present, groups will not synchronized with EDA. */
        AuthProvider_groupSupport: {
            /** @description The LDAP group name attribute */
            NameLDAPAttribute: string;
            /** @description Further for filtering when retrieving LDAP groups. Ensure starts and ends with parentheses if using. */
            filter?: string;
            /** @description The LDAP DN where groups are found. */
            groupLDAPDN: string;
            /** @description The group attribute for a members.  Usually "member" or "memberUid". */
            memberAttribute?: string;
            /** @description If retrievalStrategy is "memberOf", this is the LDAP user attribute for group memberships. */
            memberOfAttribute?: string;
            /**
             * @description How users are identified in a group member entry: either DN or UID.
             * @enum {string}
             */
            membershipAttributeType?: "DN" | "UID";
            /** @description Only required if membershipAttributeType is UID; then it is the user attribute that should match the group member value. */
            membershipUserAttribute?: string;
            /** @description The LDAP object class or classes used for groups. If more than one, they must be comma-separated. */
            objectClasses: string;
            /**
             * @description The strategy for retrieving groups.  Should be "member" to get group membership from the group, or "memberOf" to get group membership from the user.
             * @enum {string}
             */
            retrievalStrategy?: "member" | "memberOf";
        };
        /** @description The application version installed in the cluster, if installed. */
        StoreAppRequirementsGraphItem_installedAppVersion: {
            /** @description The identifier for the application */
            appId?: string;
            /** @description The catalog in which this application version was found */
            catalog?: string;
            /** @description The commit hash for the application version. */
            commitHash?: string;
            /** @description The semantic version for the application version. */
            semVer?: string;
        };
        /** @description This graph item instance contains the dependencies for this particular application version. */
        StoreAppRequirementsGraphItem_targetAppVersion: {
            /** @description The identifier for the application */
            appId?: string;
            /** @description The catalog in which this application version was found */
            catalog?: string;
            /** @description The commit hash for the application version. */
            commitHash?: string;
            /** @description The semantic version for the application version. */
            semVer?: string;
        };
        /** @description The metadata kind for the topology grouping data. */
        TopologyGroupingInstance_metadata: {
            annotations?: {
                [key: string]: string;
            };
            labels?: {
                [key: string]: string;
            };
            name: string;
            namespace?: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    activityGet: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Response when cluster is active. There is no body. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Response when cluster is standby. There is no body. */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    healthGet: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a GET health request when fully healthy. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Health"];
                    "application/yaml": components["schemas"]["Health"];
                };
            };
            /** @description The response for a GET health request when degraded. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Health"];
                    "application/yaml": components["schemas"]["Health"];
                };
            };
            /** @description The response for a GET health request when non-healthy. */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Health"];
                    "application/yaml": components["schemas"]["Health"];
                };
            };
        };
    };
    versionGet: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /**
             * @description The response for a successful GET version request.
             *     A map of version information for various components,
             *     including an overall version for the "eda" component.
             */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["versionInfo"];
                    "application/yaml": components["schemas"]["versionInfo"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    accessCheckAccess: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The set of resources/urls/tables to check for user access levels. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CheckAccessRequest"];
            };
        };
        responses: {
            /** @description The response for a successful non-streaming POST request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckAccessResponse"];
                    "application/yaml": components["schemas"]["CheckAccessResponse"];
                };
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    accessGetNamespaces: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET namespaces request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NamespaceGetResponse"];
                    "application/yaml": components["schemas"]["NamespaceGetResponse"];
                };
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetProviders: {
        parameters: {
            query?: {
                /** @description The result will be limited to providers whose name is this parameter. */
                name?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The EDA federation providers. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthProviders"];
                    "application/yaml": components["schemas"]["AuthProviders"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateProvider: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The definition the EDA provider to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthProvider"];
            };
        };
        responses: {
            /** @description The definition of the newly created EDA federation provider. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthProvider"];
                    "application/yaml": components["schemas"]["AuthProvider"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetProvider: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA provider whose definition should be retrieved. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The definition of the specified EDA federation provider. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthProvider"];
                    "application/yaml": components["schemas"]["AuthProvider"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdateProvider: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA provider whose definition should be updated. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The definition the EDA provider to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthProvider"];
            };
        };
        responses: {
            /** @description The new definition of the EDA federation provider. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthProvider"];
                    "application/yaml": components["schemas"]["AuthProvider"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminDeleteProvider: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA provider to be deleted. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminTestProvider: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The definition of the test parameters */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthProviderTestParams"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetUserGroups: {
        parameters: {
            query?: {
                /**
                 * @description If true, the full definitions of the roles associated with the group
                 *     are returned, rather than just the role names.
                 */
                "full-roles"?: boolean;
                /**
                 * @description If true, the full definitions of the users which are members of the group
                 *     are returned, rather than just the user names.
                 */
                "full-users"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The resulting set of EDA user-groups. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUserGroups"];
                    "application/yaml": components["schemas"]["AuthUserGroups"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The definition for the user group to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthUserGroup"];
            };
        };
        responses: {
            /** @description The resulting user-group definition. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUserGroup"];
                    "application/yaml": components["schemas"]["AuthUserGroup"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetUserGroup: {
        parameters: {
            query?: {
                /**
                 * @description If true, the full definitions of the roles associated with the group
                 *     are returned, rather than just the role names.
                 */
                "full-roles"?: boolean;
                /**
                 * @description If true, the full definitions of the users which are members of the group
                 *     are returned, rather than just the user names.
                 */
                "full-users"?: boolean;
            };
            header?: never;
            path: {
                /** @description The UUID of the EDA user group whose definition should be retrieved. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The group definition for the requested EDA user group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUserGroup"];
                    "application/yaml": components["schemas"]["AuthUserGroup"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdateUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group which should be updated.. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The new definition for the user group. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthUserGroup"];
            };
        };
        responses: {
            /** @description The new definition for the EDA user group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUserGroup"];
                    "application/yaml": components["schemas"]["AuthUserGroup"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminDeleteUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group which should be deleted. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetRolesOfUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group whose roles should be retrieved. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The resulting set of EDA roles. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRoles"];
                    "application/yaml": components["schemas"]["AuthRoles"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminSetRolesOfUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group whose roles should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of role names to be added-to/set-on/removed-from the EDA user group. */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminAddRolesToUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group whose roles should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of role names to be added-to/set-on/removed-from the EDA user group. */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminRemoveRolesFromUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group whose roles should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of role names to be added-to/set-on/removed-from the EDA user group. */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetRoles: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description namespace whose roles should be retrieved */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The requested set of EDA users */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRoles"];
                    "application/yaml": components["schemas"]["AuthRoles"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace in which to create the role */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The definition of the EDA role to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthRole"];
            };
        };
        responses: {
            /** @description The resulting role definition. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                    "application/yaml": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetRole: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The namespace from which to retrieve the role. */
                namespace: string;
                /** @description The name of the EDA role whose definition should be retrieved/streamed. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role definition for the specified role. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                    "application/yaml": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdateRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace in which the role resides */
                namespace: string;
                /** @description The name of the EDA role whose definition should be updated. */
                name: string;
            };
            cookie?: never;
        };
        /** @description The new definition of the EDA role. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthRole"];
            };
        };
        responses: {
            /** @description The updated role definition. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                    "application/yaml": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminDeleteRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace from which to delete the role */
                namespace: string;
                /** @description The name of the EDA role whose definition should be updated. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetPasswordPolicy: {
        parameters: {
            query?: {
                /** @description if set to true, the default password policy definition is returned, rather than the current password policy. */
                "get-default"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The current EDA password policy parameters. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthPasswordPolicy"];
                    "application/yaml": components["schemas"]["AuthPasswordPolicy"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdatePasswordPolicy: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The new password policy parameters. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthPasswordPolicy"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetClusterRoles: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The requested set of EDA users */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRoles"];
                    "application/yaml": components["schemas"]["AuthRoles"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateClusterRole: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The definition of the EDA role to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthRole"];
            };
        };
        responses: {
            /** @description The resulting role definition. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                    "application/yaml": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetClusterRole: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the EDA role whose definition should be retrieved/streamed. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role definition for the specified role. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                    "application/yaml": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdateClusterRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the EDA role whose definition should be updated. */
                name: string;
            };
            cookie?: never;
        };
        /** @description The new definition of the EDA role. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthRole"];
            };
        };
        responses: {
            /** @description The updated role definition. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                    "application/yaml": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminDeleteClusterRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the EDA role whose definition should be updated. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetUsers: {
        parameters: {
            query?: {
                /** @description username of the user whose user record should be retrieved. */
                username?: string;
                /** @description email address of the user whose user record should be retrieved. */
                email?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The requested set of EDA users */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUsers"];
                    "application/yaml": components["schemas"]["AuthUsers"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The attributes of the user to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthUser"];
            };
        };
        responses: {
            /** @description The resulting user, includes the uuid assigned to the new user */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUser"];
                    "application/yaml": components["schemas"]["AuthUser"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose user record should be retrieved. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The information about the EDA user identified the the uuid */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUser"];
                    "application/yaml": components["schemas"]["AuthUser"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminModifyUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose user record should be replaced. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The new attributes for the user. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthUser"];
            };
        };
        responses: {
            /** @description The new attributes of the updated user. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUser"];
                    "application/yaml": components["schemas"]["AuthUser"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminDeleteUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose user record should be deleted. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminExecuteEmailActions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user for which the email actions should be applied. */
                uuid: string;
            };
            cookie?: never;
        };
        /**
         * @description The list of email actions to execute.  Each action is a single string.
         *     Currently the only supported action is the UPDATE_PASSWORD action, which results
         *     in an email being sent to the user requiring them to update their password via
         *     an embedded link.
         */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminSetGroupsOfUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose group memberships should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of group identifiers (uuid values) applied during the operation. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupIDs"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminAddGroupsToUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose group memberships should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of group identifiers (uuid values) applied during the operation. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupIDs"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminRemoveGroupsFromUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose group memberships should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of group identifiers (uuid values) applied during the operation. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupIDs"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminSetUserPassword: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose password should be set. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The new credentials for the user. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Credentials"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetAlarms: {
        parameters: {
            query?: {
                /**
                 * @description requests all alarms; the default is to filter-out suppressed alarms.
                 *     Value must be "true" to get all alarms.
                 */
                all?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description a comma-separated list of alarm fields to fetch/return.  If unspecified, all fields are fetched.  If an empty list, only the alarm name and namespace will be returned. */
                fields?: string;
                /** @description an EDA-query-language "where" expression that will be used to filter the list of alarms fetched. */
                filter?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET alarms request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmData"][];
                    "application/yaml": components["schemas"]["AlarmData"][];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmPutAlarms: {
        parameters: {
            query: {
                /** @description Type of action to take for the alarm. */
                action: "acknowledge" | "unacknowledge" | "suppress" | "unsuppress";
                /** @description The duration (in milliseconds) for the specified acknowledge or suppress action. */
                duration?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The namespace/name of the alarms on which the action should be taken. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlarmNamespaceAndName"][];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Any failures will be returned as error-items in the resulting body:ErrorResponse. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmDeleteAlarms: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The names of the alarms to be deleted. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlarmNamespaceAndName"][];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Any failures will be returned as error-items in the resulting body:ErrorResponse. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetAlarm: {
        parameters: {
            query?: {
                /**
                 * @description requests all alarms; the default is to filter-out suppressed alarms.
                 *     Value must be "true" to get information about a suppressed alarm.
                 */
                all?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the alarm to retrieve */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET single alarm request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmData"];
                    "application/yaml": components["schemas"]["AlarmData"];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmPutAlarm: {
        parameters: {
            query: {
                /** @description Type of action to take for the alarm. */
                action: "acknowledge" | "unacknowledge" | "suppress" | "unsuppress";
                /** @description The duration (in milliseconds) for the specified acknowledge or suppress action. */
                duration?: number;
            };
            header?: never;
            path: {
                /** @description The name of the alarm on which the action is taken. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmDeleteAlarm: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the alarm to delete. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetAlarmHistory: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description name of the alarm whose history should be retrieved. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET alarm history request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmHistoryEntry"][];
                    "application/yaml": components["schemas"]["AlarmHistoryEntry"][];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetNamespaceAlarms: {
        parameters: {
            query?: {
                /**
                 * @description requests all alarms; the default is to filter-out suppressed alarms.
                 *     Value must be "true" to get all alarms.
                 */
                all?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description a comma-separated list of alarm fields to fetch/return.  If unspecified, all fields are fetched.  If an empty list, only the alarm name and namespace will be returned. */
                fields?: string;
                /** @description an EDA-query-language "where" expression that will be used to filter the list of alarms fetched. */
                filter?: string;
            };
            header?: never;
            path: {
                /** @description The namespace to fetch the alarms from */
                nsName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET alarms request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmData"][];
                    "application/yaml": components["schemas"]["AlarmData"][];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmPutNamespaceAlarms: {
        parameters: {
            query: {
                /** @description Type of action to take for the alarm. */
                action: "acknowledge" | "unacknowledge" | "suppress" | "unsuppress";
                /** @description The duration (in milliseconds) for the specified acknowledge or suppress action. */
                duration?: number;
            };
            header?: never;
            path: {
                /** @description The namespace in which to perform the actions. */
                nsName: string;
            };
            cookie?: never;
        };
        /** @description The namespace/name of the alarms on which the action should be taken. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlarmNamespaceAndName"][];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Any failures will be returned as error-items in the resulting body:ErrorResponse. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmDeleteNamespaceAlarms: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace in which to delete alarms. */
                nsName: string;
            };
            cookie?: never;
        };
        /** @description The names of the alarms to be deleted. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlarmNamespaceAndName"][];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Any failures will be returned as error-items in the resulting body:ErrorResponse. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetNamespaceAlarm: {
        parameters: {
            query?: {
                /**
                 * @description requests all alarms; the default is to filter-out suppressed alarms.
                 *     Value must be "true" to get information about a suppressed alarm.
                 */
                all?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The namespace to fetch the alarm from */
                nsName: string;
                /** @description The name of the alarm to retrieve */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET single alarm request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmData"];
                    "application/yaml": components["schemas"]["AlarmData"];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmPutNamespaceAlarm: {
        parameters: {
            query: {
                /** @description Type of action to take for the alarm. */
                action: "acknowledge" | "unacknowledge" | "suppress" | "unsuppress";
                /** @description The duration (in milliseconds) for the specified acknowledge or suppress action. */
                duration?: number;
            };
            header?: never;
            path: {
                /** @description The namespace of the alarm on which the action is taken. */
                nsName: string;
                /** @description The name of the alarm on which the action is taken. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmDeleteNamespaceAlarm: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace of the alarm to delete. */
                nsName: string;
                /** @description The name of the alarm to delete. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetNamespaceAlarmHistory: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description the name of the namespace for the alarm */
                nsName: string;
                /** @description name of the alarm whose history should be retrieved. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET alarm history request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmHistoryEntry"][];
                    "application/yaml": components["schemas"]["AlarmHistoryEntry"][];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    autoCompleteFieldsRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AutoCompleteRequest"];
            };
        };
        responses: {
            /** @description The response for a successful POST label selector completion request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AutoCompleteResponse"];
                    "application/yaml": components["schemas"]["AutoCompleteResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    autoCompleteGVKRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AutoCompleteRequest"];
            };
        };
        responses: {
            /** @description The response for a successful POST label selector completion request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AutoCompleteResponse"];
                    "application/yaml": components["schemas"]["AutoCompleteResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    autoCompleteGVRRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AutoCompleteRequest"];
            };
        };
        responses: {
            /** @description The response for a successful POST label selector completion request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AutoCompleteResponse"];
                    "application/yaml": components["schemas"]["AutoCompleteResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    toolsGetLabelCompletions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The type of label completion - key, value, or gvks */
        requestBody: {
            content: {
                "application/json": components["schemas"]["GetLabelCompletionRequest"];
            };
        };
        responses: {
            /** @description The potential label completions from the request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LabelCompletionResponse"];
                    "application/yaml": components["schemas"]["LabelCompletionResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    autoCompleteLabelSelectorRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AutoCompleteRequest"];
            };
        };
        responses: {
            /** @description The response for a successful POST label selector completion request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AutoCompleteResponse"];
                    "application/yaml": components["schemas"]["AutoCompleteResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    autoCompleteTableRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AutoCompleteRequest"];
            };
        };
        responses: {
            /** @description The response for a successful POST label selector completion request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AutoCompleteResponse"];
                    "application/yaml": components["schemas"]["AutoCompleteResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    autoCompleteWhereRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AutoCompleteRequest"];
            };
        };
        responses: {
            /** @description The response for a successful POST label selector completion request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AutoCompleteResponse"];
                    "application/yaml": components["schemas"]["AutoCompleteResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    chatOpenChat: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    chatGetConversationList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful conversation list GET request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationList"];
                    "application/yaml": components["schemas"]["ConversationList"];
                };
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    chatGetConversationHistory: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the requested chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful conversation history GET request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationHistory"];
                    "application/yaml": components["schemas"]["ConversationHistory"];
                };
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    chatUpdateConversation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the requested chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ConversationInfo"];
            };
        };
        responses: {
            /** @description The response for a successful conversation info POST request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConversationInfo"];
                    "application/yaml": components["schemas"]["ConversationInfo"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    chatDeleteConversation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the requested chat */
                chatId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deprecatedGetDB: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description a comma-separated list of table fields to fetch/return.  If unspecified, all fields are fetched.  If empty, no data for a row will be returned; only the JSON path for the table row. */
                fields?: string;
                /** @description an EQL "where" expression that will be used to filter the set of table rows returned. */
                filter?: string;
                /** @description if true/present, only send updates to the table rows, not the current rows.  Only applicable if streaming the results. */
                "updates-only"?: boolean;
                /** @description if true/present, the keys of the table are included in the table data. */
                includeKeys?: boolean;
            };
            header?: never;
            path: {
                /** @description the path for the table to retrieve from the DB, specified as slash-separated table-name components */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful EDA database get operation. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["dbGetResult"];
                    "application/yaml": components["schemas"]["dbGetResult"];
                    "text/csv": unknown;
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getDB: {
        parameters: {
            query: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description a comma-separated list of table fields to fetch/return.  If unspecified, all fields are fetched.  If empty, no data for a row will be returned; only the JSON path for the table row. */
                fields?: string;
                /** @description an EQL "where" expression that will be used to filter the set of table rows returned. */
                filter?: string;
                /** @description if true/present, only send updates to the table rows, not the current rows.  Only applicable if streaming the results. */
                "updates-only"?: boolean;
                /** @description if true/present, the keys of the table are included in the table data. */
                includeKeys?: boolean;
                /** @description the jsPath for the table to retrieve from the DB, with or without keys embedded in the path */
                jsPath: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful EDA database get operation. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["dbGetResult"];
                    "application/yaml": components["schemas"]["dbGetResult"];
                    "text/csv": unknown;
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getSchema: {
        parameters: {
            query: {
                /** @description the name of the table to retrieve the schema from the database */
                tableName: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful EDA database get schema operation. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["dbGetResult"];
                    "application/yaml": components["schemas"]["dbGetResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    toolsGetNodeConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace of the node whose config are being requested */
                nsName: string;
                /** @description The name of the node whose config are being requested */
                nodeName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET node config request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NodeConfigResponse"];
                    "application/yaml": components["schemas"]["NodeConfigResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    queryGetQuery: {
        parameters: {
            query: {
                /** @description the information being queried, in the EDA query language */
                query: string;
                /** @description the comma-separated list of namespaces against which the query should be executed */
                namespaces?: string;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response returned for a non-streamed query. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryResponse"];
                    "application/yaml": components["schemas"]["QueryResponse"];
                    "text/csv": unknown;
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    queryConvertRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description the */
        requestBody: {
            content: {
                "application/json": components["schemas"]["QueryConvertRequest"];
            };
        };
        responses: {
            /** @description The response for a successful query conversion POST request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryConvertResponse"];
                    "application/yaml": components["schemas"]["QueryConvertResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    queryGetEqlQuery: {
        parameters: {
            query: {
                /** @description the information being queried, in the EDA query language */
                query: string;
                /** @description the comma-separated list of namespaces against which the query should be executed */
                namespaces?: string;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response returned for a non-streamed query. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryResponse"];
                    "application/yaml": components["schemas"]["QueryResponse"];
                    "text/csv": unknown;
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    queryGetEqlQueryAutoComplete: {
        parameters: {
            query: {
                /** @description the EDA query language request string */
                query: string;
                /** @description limit on the number of auto-completion results returned by the request */
                completion_limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful query auto-completion GET request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryCompletionResponse"];
                    "application/yaml": components["schemas"]["QueryCompletionResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    queryGetNqlQuery: {
        parameters: {
            query: {
                /** @description the information being queried, in the natural query language */
                query: string;
                /** @description the comma-separated list of namespaces against which the query should be executed */
                namespaces?: string;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response returned for a non-streamed query. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryResponse"];
                    "application/yaml": components["schemas"]["QueryResponse"];
                    "text/csv": unknown;
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    storeGetAppSettingsDefinition: {
        parameters: {
            query?: {
                /** @description The semantic version for the application version. */
                semVer?: string;
                /** @description The commit hash for the application version. */
                commitHash?: string;
            };
            header?: never;
            path: {
                /** @description The catalog where the application version resides */
                catalog: string;
                /** @description application ID of the application version */
                appId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The application settings definition corresponding to the request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreAppSettingsDefinition"];
                    "application/yaml": components["schemas"]["StoreAppSettingsDefinition"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    storeGetAppSummaries: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description If present and true, and the application is installed, the application information will be derived from the installed application version. */
                prioritizeInstalledInfo?: boolean;
                /** @description If present, this causes only installed(if true)/uninstalled(if false) applications to be returned. */
                installed?: boolean;
                /** @description If present, this causes only upgradable(if true)/up-to-date(if false) applications to be returned. */
                upgradable?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of application summaries from the EDA store */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreAppSummaryList"];
                    "application/yaml": components["schemas"]["StoreAppSummaryList"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    storeGetAppSummary: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description If present and true, and the application is installed, the application information will be derived from the installed application version. */
                prioritizeInstalledInfo?: boolean;
                /** @description When true, only return the summary for the specified application if the application is installed */
                installed?: boolean;
                /** @description When true, only return the summary for the specified application if the application is upgradable */
                upgradable?: boolean;
            };
            header?: never;
            path: {
                /** @description Application ID of the application summary to be returned */
                appId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The application summary for the specified appId */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreAppSummary"];
                    "application/yaml": components["schemas"]["StoreAppSummary"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    storeGetCategories: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of application category strings from the EDA store */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreCategoryList"];
                    "application/yaml": components["schemas"]["StoreCategoryList"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    storeGetAppFile: {
        parameters: {
            query?: {
                /** @description The semantic version for the application version. */
                semVer?: string;
                /** @description The commit hash for the application version. */
                commitHash?: string;
            };
            header?: never;
            path: {
                /** @description The catalog where the application version resides */
                catalog: string;
                /** @description application ID of the application version */
                appId: string;
                /** @description the path in the application for the requested file */
                path: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The binary content of the requested file */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": string;
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    storeGetAppInstalledSettings: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description application ID of the application whose settings should be retrieved. */
                appId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The currently installed settings for the application. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreAppInstalledSettings"];
                    "application/yaml": components["schemas"]["StoreAppInstalledSettings"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    storeGetAppManifest: {
        parameters: {
            query?: {
                /** @description The semantic version for the application version. */
                semVer?: string;
                /** @description The commit hash for the application version. */
                commitHash?: string;
            };
            header?: never;
            path: {
                /** @description The catalog where the application version resides */
                catalog: string;
                /** @description application ID of the application version */
                appId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Application manifest */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreAppManifest"];
                    "application/yaml": components["schemas"]["StoreAppManifest"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    storeGetAppRequirementsGraph: {
        parameters: {
            query?: {
                /** @description The semantic version for the application version. */
                semVer?: string;
                /** @description The commit hash for the application version. */
                commitHash?: string;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The catalog where the application version resides */
                catalog: string;
                /** @description application ID of the application version */
                appId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The requirements graph information corresponding to the request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreAppRequirementsGraph"];
                    "application/yaml": components["schemas"]["StoreAppRequirementsGraph"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    storeGetAppVersions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description application ID of the application whose versions should be retrieved */
                appId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of versions of the application */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreAppVersionList"];
                    "application/yaml": components["schemas"]["StoreAppVersionList"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    topologies: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Topologies"];
                    "application/yaml": components["schemas"]["Topologies"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    topology: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the topology to retrieve */
                topologyName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Topology"];
                    "application/yaml": components["schemas"]["Topology"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getTopologyGroupings: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description the name of the topology whose grouping(s) should be retrieved */
                topologyName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopologyGroupingsList"];
                    "application/yaml": components["schemas"]["TopologyGroupingsList"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getTopologyGrouping: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description the name of the topology whose grouping(s) should be retrieved */
                topologyName: string;
                /** @description the name of the grouping to retrieve */
                groupingName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopologyGroupingInstance"];
                    "application/yaml": components["schemas"]["TopologyGroupingInstance"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    overlays: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the topology on which to list overlays */
                topologyName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Overlays"];
                    "application/yaml": components["schemas"]["Overlays"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    overlay: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the topology to that owns this overlay */
                topologyName: string;
                /** @description The name of the overlay to retrieve */
                overlayName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Overlay"];
                    "application/yaml": components["schemas"]["Overlay"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    topologyPostState: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the topology from which to get the state */
                topologyName: string;
            };
            cookie?: never;
        };
        /** @description The options to specify the namespace, grouping and overlays for the topology. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TopoStateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OverlayState"];
                    "application/yaml": components["schemas"]["OverlayState"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transPostTransaction: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Details of the transaction */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Transaction"];
            };
        };
        responses: {
            /** @description The response for a successful POST transaction request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionId"];
                    "application/yaml": components["schemas"]["TransactionId"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transRestoreTransaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The identifier for the transaction being reverted or restored. */
                transactionId: number;
            };
            cookie?: never;
        };
        /** @description Options for describing how to revert or restore this transaction */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["TransactionRevertRestoreRequest"];
            };
        };
        responses: {
            /** @description The identifier for the transaction ID used to restore to the state of the specified transaction. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionId"];
                    "application/yaml": components["schemas"]["TransactionId"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetNodeConfigDiff: {
        parameters: {
            query: {
                /** @description Name of the node for the configuration diff being requested */
                node: string;
                /** @description Namespace of the node for the configuration diff being requested. */
                namespace: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose resource diff is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-diffs request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionResultObject"];
                    "application/yaml": components["schemas"]["TransactionResultObject"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetResourceDiff: {
        parameters: {
            query: {
                /** @description Group information for the resource diff being requested.  Group is required but can be empty for non-EDA resources */
                group: string;
                /** @description Version information for the resource diff being requested.  Version is required */
                version: string;
                /** @description kind information for the resource diff being requested.  Kind is required */
                kind: string;
                /** @description Name information for the resource diff being requested.  Name is required */
                name: string;
                /**
                 * @description Namespace information for the resource diff being requested.  Namespace is
                 *     required if the resource is namespaced or is a non-EDA resource
                 */
                namespace: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose resource diff is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-diffs request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionResultObject"];
                    "application/yaml": components["schemas"]["TransactionResultObject"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetResultExecution: {
        parameters: {
            query?: {
                /** @description Flag for the request to wait until the transaction is complete before returning.  By default it returns the current state. */
                waitForComplete?: boolean;
                /** @description Flag to tell the request to fail if the transaction has errors.  By default it will not fail. */
                failOnErrors?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose details are being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-result-execution request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionExecutionResult"];
                    "application/yaml": components["schemas"]["TransactionExecutionResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetResultInputResources: {
        parameters: {
            query?: {
                /** @description If true the response will contain the full resource body for each input resource */
                full?: boolean;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose list of input resources is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-result-inputresources request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionResultInputResources"];
                    "application/yaml": components["schemas"]["TransactionResultInputResources"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetSummaryResultList: {
        parameters: {
            query: {
                /** @description Maximum number of transaction results to return */
                size: number;
                /** @description When provided, the liast of transactions is limited to those initiated by the specified user. */
                username?: string;
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-result-summary-list request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionSummaryResults"];
                    "application/yaml": components["schemas"]["TransactionSummaryResults"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetSummaryResult: {
        parameters: {
            query?: {
                /** @description Flag for the request to wait until the transaction is complete before returning.  By default it returns the current state. */
                waitForComplete?: boolean;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose state is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /**
             * @description The response for a successful GET transaction-result-summary request.
             *     This request returns the summary for a single, specified transaction.
             */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionSummaryResult"];
                    "application/yaml": components["schemas"]["TransactionSummaryResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetResultTopology: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The identifier for the transaction whose topology is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-result-topology request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionTopologyResult"];
                    "application/yaml": components["schemas"]["TransactionTopologyResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transPostResultTopology: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose topology is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        /** @description The filter to apply to the topology */
        requestBody: {
            content: {
                "application/json": components["schemas"]["transactionTopologyRequest"];
            };
        };
        responses: {
            /** @description The response for a successful GET transaction-result-topology request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionTopologyResult"];
                    "application/yaml": components["schemas"]["TransactionTopologyResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transRevertTransaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The identifier for the transaction being reverted or restored. */
                transactionId: number;
            };
            cookie?: never;
        };
        /** @description Options for describing how to revert or restore this transaction */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["TransactionRevertRestoreRequest"];
            };
        };
        responses: {
            /** @description The identifier for the transaction ID used to revert the transaction. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionId"];
                    "application/yaml": components["schemas"]["TransactionId"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetState: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose state is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-state request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionState"];
                    "application/yaml": components["schemas"]["TransactionState"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transValidateTransaction: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The CRs to validate */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TransactionCr"][];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussGetDirectory: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
                /** @description if true, file content will be base64-encoded before being returned */
                "base64-encode"?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET directory user-storage request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserStorageOutDirContent"];
                    "application/yaml": components["schemas"]["UserStorageOutDirContent"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteDirectory: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussGetFile: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
                /** @description if true, file content will be base64-encoded before being returned */
                "base64-encode"?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET file user-storage request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserStorageOutFileContent"];
                    "application/yaml": components["schemas"]["UserStorageOutFileContent"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussPutFile: {
        parameters: {
            query: {
                /** @description path for the file whose contents should be written */
                path: string;
                /** @description true if the content was base64-encoded before being sent. */
                "base64-encoded"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description content for the file */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserStorageInFileContent"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussPostFile: {
        parameters: {
            query: {
                /** @description path for the file whose contents should be written */
                path: string;
                /** @description true if the content was base64-encoded before being sent. */
                "base64-encoded"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description content for the file */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserStorageInFileContent"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteFile: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteFiles: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description paths for the files being deleted */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussGetSharedDirectory: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
                /** @description if true, file content will be base64-encoded before being returned */
                "base64-encode"?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET directory user-storage request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserStorageOutDirContent"];
                    "application/yaml": components["schemas"]["UserStorageOutDirContent"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteSharedDirectory: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussGetSharedFile: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
                /** @description if true, file content will be base64-encoded before being returned */
                "base64-encode"?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET file user-storage request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserStorageOutFileContent"];
                    "application/yaml": components["schemas"]["UserStorageOutFileContent"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussPutSharedFile: {
        parameters: {
            query: {
                /** @description path for the file whose contents should be written */
                path: string;
                /** @description true if the content was base64-encoded before being sent. */
                "base64-encoded"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description content for the file */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserStorageInFileContent"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussPostSharedFile: {
        parameters: {
            query: {
                /** @description path for the file whose contents should be written */
                path: string;
                /** @description true if the content was base64-encoded before being sent. */
                "base64-encoded"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description content for the file */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserStorageInFileContent"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteSharedFile: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteSharedFiles: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description paths for the files being deleted */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    wfListAllNs: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
                /** @description a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched. */
                fields?: string;
                /** @description an EQL "where" expression that will be used to filter the set of resources returned. */
                filter?: string;
                /** @description a label selector string to filter the results based on CR labels */
                labelSelector?: string;
                /**
                 * @deprecated
                 * @description Deprecated: a label selector string to filter the results based on CR labels
                 */
                "label-selector"?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List containing a summary of each workflow's status. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkflowStatusSummary"][];
                    "application/yaml": components["schemas"]["WorkflowStatusSummary"][];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
}
