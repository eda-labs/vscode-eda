{
  "openapi": "3.0.1",
  "info": {
    "description": "This spec describes the basic core functionality of the EDA API server.",
    "title": "API-server openapi functions",
    "version": "0.0.1"
  },
  "security": [
    {
      "bearerAuth": []
    }
  ],
  "paths": {
    "/core/about/activity": {
      "get": {
        "description": "Unless an error is encountered, it simply returns an \"NoContent\" (for active)\nor \"ServiceUnavailable\" (for standby) status. In other words, there is no\nresponse body for these cases.",
        "operationId": "activityGet",
        "responses": {
          "204": {
            "description": "Response when cluster is active. There is no body."
          },
          "503": {
            "content": {},
            "description": "Response when cluster is standby. There is no body."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "security": [],
        "summary": "Gets the cluster activity status.",
        "tags": [
          "coreAbout"
        ]
      }
    },
    "/core/about/health": {
      "get": {
        "description": "Returns an indication of the health of the EDA cluster. HTTP status OK\nindicates that all is good.  HTTP status ServiceUnavailable indicates that\nall of the services of the EDA cluster (other than the API service) are down.\nHTTP status InternalServerError indicates that one service is down, but at\nleast one service (other than the API service) is up.",
        "operationId": "healthGet",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Health"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/Health"
                }
              }
            },
            "description": "The response for a GET health request when fully healthy."
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Health"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/Health"
                }
              }
            },
            "description": "The response for a GET health request when degraded."
          },
          "503": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Health"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/Health"
                }
              }
            },
            "description": "The response for a GET health request when non-healthy."
          }
        },
        "security": [],
        "tags": [
          "coreAbout"
        ]
      }
    },
    "/core/about/version": {
      "get": {
        "operationId": "versionGet",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/versionInfo"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/versionInfo"
                }
              }
            },
            "description": "The response for a successful GET version request.\nA map of version information for various components,\nincluding an overall version for the \"eda\" component."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Returns version information for the EDA cluster.",
        "tags": [
          "coreAbout"
        ]
      }
    },
    "/core/access/v1/checkAccess": {
      "post": {
        "description": "Checks the current user's access to the various resources, urls and tables provided in the\nrequest body.",
        "operationId": "accessCheckAccess",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckAccessRequest"
              }
            }
          },
          "description": "The set of resources/urls/tables to check for user access levels.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckAccessResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/CheckAccessResponse"
                }
              }
            },
            "description": "The response for a successful non-streaming POST request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "tags": [
          "coreAccess"
        ]
      }
    },
    "/core/access/v1/namespaces": {
      "get": {
        "description": "Gets the list of namespaces the current user can access. If the current user is able to access the\n'All Namespaces' option that will be indicated in the response.",
        "operationId": "accessGetNamespaces",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NamespaceGetResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/NamespaceGetResponse"
                }
              }
            },
            "description": "The response for a successful non-streaming GET namespaces request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "tags": [
          "coreAccess"
        ]
      }
    },
    "/core/admin/federationproviders": {
      "get": {
        "description": "Returns a list of federation providers, possibly filtered based on the \"name\" query parameter.",
        "operationId": "adminGetProviders",
        "parameters": [
          {
            "description": "The result will be limited to providers whose name is this parameter.",
            "in": "query",
            "name": "name",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthProviders"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthProviders"
                }
              }
            },
            "description": "The EDA federation providers."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Get the user federation providers configured in EDA.",
        "tags": [
          "coreAdmin"
        ]
      },
      "post": {
        "description": "Creates an EDA user federation provider using the definition in the body.  The UUID cannot be set, it is\ncreated by the system when the provider is created.",
        "operationId": "adminCreateProvider",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthProvider"
              }
            }
          },
          "description": "The definition the EDA provider to be created.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthProvider"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthProvider"
                }
              }
            },
            "description": "The definition of the newly created EDA federation provider."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Create an EDA user federation provider.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/federationproviders/{uuid}": {
      "delete": {
        "description": "Deletes the EDA user federation provider specified by the UUID in the path.",
        "operationId": "adminDeleteProvider",
        "parameters": [
          {
            "description": "The UUID of the EDA provider to be deleted.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Delete an EDA user federation provider.",
        "tags": [
          "coreAdmin"
        ]
      },
      "get": {
        "description": "Returns the definition of the specified EDA federation provider.",
        "operationId": "adminGetProvider",
        "parameters": [
          {
            "description": "The UUID of the EDA provider whose definition should be retrieved.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthProvider"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthProvider"
                }
              }
            },
            "description": "The definition of the specified EDA federation provider."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Get the EDA user federation provider specified by the uuid in the request URL.",
        "tags": [
          "coreAdmin"
        ]
      },
      "put": {
        "description": "Replaces the definition of an EDA user federation provider with the definition in the body.\nThe UUID cannot be changed.",
        "operationId": "adminUpdateProvider",
        "parameters": [
          {
            "description": "The UUID of the EDA provider whose definition should be updated.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthProvider"
              }
            }
          },
          "description": "The definition the EDA provider to be created.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthProvider"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthProvider"
                }
              }
            },
            "description": "The new definition of the EDA federation provider."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Update an EDA user federation provider.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/federationprovidertest": {
      "post": {
        "description": "This endpoint instructs the keycloak server to test a federation provider\non behalf of the requesting user.  If the \"name\" in the test parameters\nis provided by the user for an authentication test, a provider by that\nname must exist, and the bind credential (password) saved in that\nprovider will be used for the test.  Otherwise, the bind credential\nmust be provided in the test parameters.",
        "operationId": "adminTestProvider",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthProviderTestParams"
              }
            }
          },
          "description": "The definition of the test parameters",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Test connection and authentication for an EDA federation provider.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/groups": {
      "get": {
        "description": "Returns the list of defined EDA user-groups.  Query parameters control if\nthe associated users and roles are returned by name only, or if the full definition\nis returned.",
        "operationId": "adminGetUserGroups",
        "parameters": [
          {
            "description": "If true, the full definitions of the roles associated with the group\nare returned, rather than just the role names.",
            "in": "query",
            "name": "full-roles",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "If true, the full definitions of the users which are members of the group\nare returned, rather than just the user names.",
            "in": "query",
            "name": "full-users",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUserGroups"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUserGroups"
                }
              }
            },
            "description": "The resulting set of EDA user-groups."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Returns all EDA user-groups.",
        "tags": [
          "coreAdmin"
        ]
      },
      "post": {
        "description": "Creates a new EDA user group using the definition in the request body. The\nEDA roles for the new group can be included in the definition, but the users\nbelonging to the group cannot be specified here.  The users of the group\nmust be modified via either the \"groups of user\" membership APIs, or the\n\"users of group\" membership APIs.  Same for the roles.  A uuid definition in\nthe body will be ignored; the uuid of the group is assigned by the system\nwhen it is created.",
        "operationId": "adminCreateUserGroup",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthUserGroup"
              }
            }
          },
          "description": "The definition for the user group to be created.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUserGroup"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUserGroup"
                }
              }
            },
            "description": "The resulting user-group definition."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Creates a new EDA user group.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/groups/{uuid}": {
      "delete": {
        "description": "Deletes the EDA user group identified by the UUID in the path.  Any user which is\ncurrently a member of the group will no longer be a member of the group after this.",
        "operationId": "adminDeleteUserGroup",
        "parameters": [
          {
            "description": "The UUID of the EDA user group which should be deleted.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Deletes an EDA user group.",
        "tags": [
          "coreAdmin"
        ]
      },
      "get": {
        "description": "Returns the single EDA user-group identified by the uuid parameter.  Query parameters control if\nthe associated users and roles are returned by name only, or if the full definition\nis returned.",
        "operationId": "adminGetUserGroup",
        "parameters": [
          {
            "description": "The UUID of the EDA user group whose definition should be retrieved.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If true, the full definitions of the roles associated with the group\nare returned, rather than just the role names.",
            "in": "query",
            "name": "full-roles",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "If true, the full definitions of the users which are members of the group\nare returned, rather than just the user names.",
            "in": "query",
            "name": "full-users",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUserGroup"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUserGroup"
                }
              }
            },
            "description": "The group definition for the requested EDA user group."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Returns a single EDA user-group.",
        "tags": [
          "coreAdmin"
        ]
      },
      "put": {
        "description": "Update the definition of the EDA user group specified by the UUID in the\npath. The name and UUID of the group cannot be modified in this manner.  The\nroles of the user group will be set to the set of roles in the new\ndefinition.  The users of a user group cannot be modified via this mechanism,\nbut must be modified via the \"groups of user\" or \"users of group\" APIs.\nA similar restriction applies to the roles of the user group.",
        "operationId": "adminUpdateUserGroup",
        "parameters": [
          {
            "description": "The UUID of the EDA user group which should be updated..",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthUserGroup"
              }
            }
          },
          "description": "The new definition for the user group.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUserGroup"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUserGroup"
                }
              }
            },
            "description": "The new definition for the EDA user group."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Updates an EDA user group",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/groups/{uuid}/roles": {
      "delete": {
        "description": "Removes the roles specified in the body from the user group specified in the path.\nThis will affect the roles of any users assigned to the user group.",
        "operationId": "adminRemoveRolesFromUserGroup",
        "parameters": [
          {
            "description": "The UUID of the EDA user group whose roles should be modified.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            }
          },
          "description": "The set of role names to be added-to/set-on/removed-from the EDA user group.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Remove roles from an EDA user group.",
        "tags": [
          "coreAdmin"
        ]
      },
      "get": {
        "description": "Returns a list of role definitions for the roles assigned to the specified EDA user group.",
        "operationId": "adminGetRolesOfUserGroup",
        "parameters": [
          {
            "description": "The UUID of the EDA user group whose roles should be retrieved.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRoles"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRoles"
                }
              }
            },
            "description": "The resulting set of EDA roles."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Returns the roles assigned to an EDA user-group.",
        "tags": [
          "coreAdmin"
        ]
      },
      "post": {
        "description": "Assigns the specified set of roles to the specified user group (as well as the ones that\nwere previously assigned to the user group). This means that all the users assigned\nto that user group will now have that set of roles, in addition to any roles they already had.",
        "operationId": "adminAddRolesToUserGroup",
        "parameters": [
          {
            "description": "The UUID of the EDA user group whose roles should be modified.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            }
          },
          "description": "The set of role names to be added-to/set-on/removed-from the EDA user group.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Assign roles to an EDA user group.",
        "tags": [
          "coreAdmin"
        ]
      },
      "put": {
        "description": "Replaces the roles of the specified user group with the roles in the body.  This will affect\nthe roles of any users assigned to the user group.",
        "operationId": "adminSetRolesOfUserGroup",
        "parameters": [
          {
            "description": "The UUID of the EDA user group whose roles should be modified.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            }
          },
          "description": "The set of role names to be added-to/set-on/removed-from the EDA user group.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Replace the roles of an EDA user group.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/namespaces/{namespace}/roles": {
      "get": {
        "description": "Either returns or streams the EDA role definitions, depending on query\nparameters.",
        "operationId": "adminGetRoles",
        "parameters": [
          {
            "description": "namespace whose roles should be retrieved",
            "in": "path",
            "name": "namespace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRoles"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRoles"
                }
              }
            },
            "description": "The requested set of EDA users"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Get/stream the EDA roles in the specified namespace.",
        "tags": [
          "coreAdmin"
        ]
      },
      "post": {
        "description": "Creates a new EDA role using the definition in the request body.",
        "operationId": "adminCreateRole",
        "parameters": [
          {
            "description": "The namespace in which to create the role",
            "in": "path",
            "name": "namespace",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthRole"
              }
            }
          },
          "description": "The definition of the EDA role to be created.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              }
            },
            "description": "The resulting role definition."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Create an EDA namespaced role in the specified namespace.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/namespaces/{namespace}/roles/{name}": {
      "delete": {
        "description": "Deletes the specified EDA role. This will fail if the role is assigned to any user groups.\nYou must remove the role from the user groups first.",
        "operationId": "adminDeleteRole",
        "parameters": [
          {
            "description": "The namespace from which to delete the role",
            "in": "path",
            "name": "namespace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the EDA role whose definition should be updated.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Delete an EDA namespaced role.",
        "tags": [
          "coreAdmin"
        ]
      },
      "get": {
        "description": "Returns the specifed namespaced EDA role definition, or streams the EDA role and any changes,\ndepending on the streaming query parameters.",
        "operationId": "adminGetRole",
        "parameters": [
          {
            "description": "The namespace from which to retrieve the role.",
            "in": "path",
            "name": "namespace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the EDA role whose definition should be retrieved/streamed.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              }
            },
            "description": "The role definition for the specified role."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Get/stream a single namespaced EDA role.",
        "tags": [
          "coreAdmin"
        ]
      },
      "put": {
        "description": "Replaces the definition of the specifed EDA role with the definition in the body.\nThe role name cannot be modified.",
        "operationId": "adminUpdateRole",
        "parameters": [
          {
            "description": "The namespace in which the role resides",
            "in": "path",
            "name": "namespace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the EDA role whose definition should be updated.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthRole"
              }
            }
          },
          "description": "The new definition of the EDA role.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              }
            },
            "description": "The updated role definition."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Update an EDA namespaced role with new content.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/passwordpolicy": {
      "get": {
        "description": "Returns the parameters for the currently configured EDA password policy.\nIf a \"get-default=true\" query parameter is passed, the default password policy definition\nis returned.",
        "operationId": "adminGetPasswordPolicy",
        "parameters": [
          {
            "description": "if set to true, the default password policy definition is returned, rather than the current password policy.",
            "in": "query",
            "name": "get-default",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthPasswordPolicy"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthPasswordPolicy"
                }
              }
            },
            "description": "The current EDA password policy parameters."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets the current EDA password policy parameters.",
        "tags": [
          "coreAdmin"
        ]
      },
      "put": {
        "operationId": "adminUpdatePasswordPolicy",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthPasswordPolicy"
              }
            }
          },
          "description": "The new password policy parameters.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Sets the EDA password policy parameters.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/roles": {
      "get": {
        "description": "Either returns or streams the EDA cluster role definitions, depending on query\nparameters.",
        "operationId": "adminGetClusterRoles",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRoles"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRoles"
                }
              }
            },
            "description": "The requested set of EDA users"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Get/stream the EDA cluster roles.",
        "tags": [
          "coreAdmin"
        ]
      },
      "post": {
        "description": "Creates a new EDA cluster role using the definition in the request body.",
        "operationId": "adminCreateClusterRole",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthRole"
              }
            }
          },
          "description": "The definition of the EDA role to be created.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              }
            },
            "description": "The resulting role definition."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Create an EDA cluster role.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/roles/{name}": {
      "delete": {
        "description": "Deletes the specified EDA role. This will fail if the role is assigned to any user groups.\nYou must remove the role from the user groups first.",
        "operationId": "adminDeleteClusterRole",
        "parameters": [
          {
            "description": "The name of the EDA role whose definition should be updated.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Delete an EDA cluster role.",
        "tags": [
          "coreAdmin"
        ]
      },
      "get": {
        "description": "Returns the specifed EDA cluster role definition, or streams the EDA role and any changes,\ndepending on the streaming query parameters.",
        "operationId": "adminGetClusterRole",
        "parameters": [
          {
            "description": "The name of the EDA role whose definition should be retrieved/streamed.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              }
            },
            "description": "The role definition for the specified role."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Get/stream a single EDA cluster role.",
        "tags": [
          "coreAdmin"
        ]
      },
      "put": {
        "description": "Replaces the definition of the specifed EDA role with the definition in the body.\nThe role name cannot be modified.",
        "operationId": "adminUpdateClusterRole",
        "parameters": [
          {
            "description": "The name of the EDA role whose definition should be updated.",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthRole"
              }
            }
          },
          "description": "The new definition of the EDA role.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthRole"
                }
              }
            },
            "description": "The updated role definition."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Update an EDA cluster role with new content.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/users": {
      "get": {
        "description": "Returns EDA users, either all users, or user(s) filtered on username\nor email address, based on query parameters.",
        "operationId": "adminGetUsers",
        "parameters": [
          {
            "description": "username of the user whose user record should be retrieved.",
            "in": "query",
            "name": "username",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "email address of the user whose user record should be retrieved.",
            "in": "query",
            "name": "email",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUsers"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUsers"
                }
              }
            },
            "description": "The requested set of EDA users"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreAdmin"
        ]
      },
      "post": {
        "description": "Note that group membership is not changed (the \"groups\" data in the user\ndefinition is ignored).  The groups of a user must be modified via the\ncore/admin/users/{uuid}/groups REST endpoint or by modifying the group definitions\nusing group REST endpoints.",
        "operationId": "adminCreateUser",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthUser"
              }
            }
          },
          "description": "The attributes of the user to be created.",
          "required": true
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUser"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUser"
                }
              }
            },
            "description": "The resulting user, includes the uuid assigned to the new user"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Creates an EDA user with the JSON information in the request body.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/users/{uuid}": {
      "delete": {
        "operationId": "adminDeleteUser",
        "parameters": [
          {
            "description": "The UUID or userid of the user whose user record should be deleted.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Deletes the user identified by userid/UUID in the request path.",
        "tags": [
          "coreAdmin"
        ]
      },
      "get": {
        "operationId": "adminGetUser",
        "parameters": [
          {
            "description": "The UUID or userid of the user whose user record should be retrieved.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUser"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUser"
                }
              }
            },
            "description": "The information about the EDA user identified the the uuid"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Returns a single EDA user specified by the userid (UUID) parameter in the path.",
        "tags": [
          "coreAdmin"
        ]
      },
      "put": {
        "description": "Note that the userid/UUID and name cannot be modified.\nNote also that group membership is not changed (the \"groups\" data in the user\ndefinition is ignored).  The groups of a user must be modified via the\ncore/admin/users/{uuid}/groups REST endpoint or by modifying the group definitions\nusing group REST endpoints.",
        "operationId": "adminModifyUser",
        "parameters": [
          {
            "description": "The UUID or userid of the user whose user record should be replaced.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthUser"
              }
            }
          },
          "description": "The new attributes for the user.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUser"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AuthUser"
                }
              }
            },
            "description": "The new attributes of the updated user."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Replaces the attributes of an EDA user with the JSON information in the request body.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/users/{uuid}/actionemails": {
      "put": {
        "operationId": "adminExecuteEmailActions",
        "parameters": [
          {
            "description": "The UUID or userid of the user for which the email actions should be applied.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            }
          },
          "description": "The list of email actions to execute.  Each action is a single string.\nCurrently the only supported action is the UPDATE_PASSWORD action, which results\nin an email being sent to the user requiring them to update their password via\nan embedded link.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Invokes the specified email action for the specified user.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/users/{uuid}/groups": {
      "delete": {
        "operationId": "adminRemoveGroupsFromUser",
        "parameters": [
          {
            "description": "The UUID or userid of the user whose group memberships should be modified.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GroupIDs"
              }
            }
          },
          "description": "The set of group identifiers (uuid values) applied during the operation.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Removes the specified user from the groups specified by the group UUIDs in the request body.",
        "tags": [
          "coreAdmin"
        ]
      },
      "post": {
        "operationId": "adminAddGroupsToUser",
        "parameters": [
          {
            "description": "The UUID or userid of the user whose group memberships should be modified.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GroupIDs"
              }
            }
          },
          "description": "The set of group identifiers (uuid values) applied during the operation.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Adds the specified user to the groups specified by the group UUIDs in the request body.",
        "tags": [
          "coreAdmin"
        ]
      },
      "put": {
        "description": "Replaces the group memberships of the specified user to that they are members of only the\ngroups specified by the group UUIDs in the request body.",
        "operationId": "adminSetGroupsOfUser",
        "parameters": [
          {
            "description": "The UUID or userid of the user whose group memberships should be modified.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GroupIDs"
              }
            }
          },
          "description": "The set of group identifiers (uuid values) applied during the operation.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/admin/users/{uuid}/resetpassword": {
      "put": {
        "operationId": "adminSetUserPassword",
        "parameters": [
          {
            "description": "The UUID or userid of the user whose password should be set.",
            "in": "path",
            "name": "uuid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Credentials"
              }
            }
          },
          "description": "The new credentials for the user.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Sets/updates/replaces the password of the specified user.",
        "tags": [
          "coreAdmin"
        ]
      }
    },
    "/core/alarm/v2/alarms": {
      "delete": {
        "description": "Deletes all the alarms named in the JSON string array in the body.  Deletes\ncan be performed on alarms across multiple namespaces, including non-namespaced\nalarms.  It is possible for some deletes on alarms to have been successful and\nother deletes to have failed if an error is returned.",
        "operationId": "alarmDeleteAlarms",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/AlarmNamespaceAndName"
                },
                "type": "array"
              }
            }
          },
          "description": "The names of the alarms to be deleted.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Any failures will be returned as error-items in the resulting body:ErrorResponse."
          }
        },
        "tags": [
          "coreAlarms"
        ]
      },
      "get": {
        "description": "This API can get a snapshot of the alarms, or can return a stream of the alarms and the changes to them.\nThe API does not provide suppressed alarms by default, but the suppressed alarms will be included if the \"all\" query parameter is set to \"true\".\nThe alarm fields returned can optionally be specified using the \"fields\" query parameter.\nThe alarm namespace and name fields are never filtered.\nThe set of alarms returned can be filtered by providing the \"filter\" query parameter.",
        "operationId": "alarmGetAlarms",
        "parameters": [
          {
            "description": "requests all alarms; the default is to filter-out suppressed alarms.\nValue must be \"true\" to get all alarms.",
            "in": "query",
            "name": "all",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "a comma-separated list of alarm fields to fetch/return.  If unspecified, all fields are fetched.  If an empty list, only the alarm name and namespace will be returned.",
            "in": "query",
            "name": "fields",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "an EDA-query-language \"where\" expression that will be used to filter the list of alarms fetched.",
            "in": "query",
            "name": "filter",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/AlarmData"
                  },
                  "type": "array"
                }
              },
              "application/yaml": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/AlarmData"
                  },
                  "type": "array"
                }
              }
            },
            "description": "The response for a successful non-streaming GET alarms request."
          },
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "summary": "Gets all alarms including namespaced alarms from all namespaces and all non-namespaced alarms.",
        "tags": [
          "coreAlarms"
        ]
      },
      "put": {
        "description": "Performs the specified acknowledgement action provided in the \"action\" query\non the alarms named in the JSON string array in the body.  The action\ncan be performed on alarms across multiple namespaces, including non-namespaced\nalarms.  It is possible for some actions on alarms to have been successful and\nother actions to have failed if an error is returned.",
        "operationId": "alarmPutAlarms",
        "parameters": [
          {
            "description": "Type of action to take for the alarm.",
            "in": "query",
            "name": "action",
            "required": true,
            "schema": {
              "enum": [
                "acknowledge",
                "unacknowledge",
                "suppress",
                "unsuppress"
              ],
              "type": "string"
            }
          },
          {
            "description": "The duration (in milliseconds) for the specified acknowledge or suppress action.",
            "in": "query",
            "name": "duration",
            "schema": {
              "format": "int64",
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/AlarmNamespaceAndName"
                },
                "type": "array"
              }
            }
          },
          "description": "The namespace/name of the alarms on which the action should be taken.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Any failures will be returned as error-items in the resulting body:ErrorResponse."
          }
        },
        "tags": [
          "coreAlarms"
        ]
      }
    },
    "/core/alarm/v2/alarms/{alarm-name}": {
      "delete": {
        "description": "Deletes the non-namespaced alarm with the specified name (alarm-name).  If the alarm is not\ncleared, the alarm will not be deleted, but there will be no error.",
        "operationId": "alarmDeleteAlarm",
        "parameters": [
          {
            "description": "The name of the alarm to delete.",
            "in": "path",
            "name": "alarm-name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "tags": [
          "coreAlarms"
        ]
      },
      "get": {
        "description": "This API can get a snapshot of the alarm, or a stream of changes to that alarm.\nThe API does not provide information about a suppressed alarm by default, but the suppressed alarm will be included if the \"all\" query parameter is set to \"true\".",
        "operationId": "alarmGetAlarm",
        "parameters": [
          {
            "description": "The name of the alarm to retrieve",
            "in": "path",
            "name": "alarm-name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "requests all alarms; the default is to filter-out suppressed alarms.\nValue must be \"true\" to get information about a suppressed alarm.",
            "in": "query",
            "name": "all",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlarmData"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AlarmData"
                }
              }
            },
            "description": "The response for a successful non-streaming GET single alarm request."
          },
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "summary": "Gets a single non-namespaced alarm, as specified by the alarm-name parameter.",
        "tags": [
          "coreAlarms"
        ]
      },
      "put": {
        "description": "Performs the specified acknowledgement action provided in the \"action\" query\non the non-namespaced alarm with the specified name (alarm-name).",
        "operationId": "alarmPutAlarm",
        "parameters": [
          {
            "description": "Type of action to take for the alarm.",
            "in": "query",
            "name": "action",
            "required": true,
            "schema": {
              "enum": [
                "acknowledge",
                "unacknowledge",
                "suppress",
                "unsuppress"
              ],
              "type": "string"
            }
          },
          {
            "description": "The duration (in milliseconds) for the specified acknowledge or suppress action.",
            "in": "query",
            "name": "duration",
            "schema": {
              "format": "int64",
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "The name of the alarm on which the action is taken.",
            "in": "path",
            "name": "alarm-name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "tags": [
          "coreAlarms"
        ]
      }
    },
    "/core/alarm/v2/alarms/{alarm-name}/history": {
      "get": {
        "description": "and if requested the history of the alarm will be streamed back on the provided stream,\nincluding any subsequent changes.  If not using streaming, a snapshot of the history\nwill be returned.",
        "operationId": "alarmGetAlarmHistory",
        "parameters": [
          {
            "description": "name of the alarm whose history should be retrieved.",
            "in": "path",
            "name": "alarm-name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/AlarmHistoryEntry"
                  },
                  "type": "array"
                }
              },
              "application/yaml": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/AlarmHistoryEntry"
                  },
                  "type": "array"
                }
              }
            },
            "description": "The response for a successful non-streaming GET alarm history request."
          },
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "summary": "Gets the history of the specified non-namespaced alarm.  This API supports streaming,",
        "tags": [
          "coreAlarms"
        ]
      }
    },
    "/core/alarm/v2/namespaces/{nsName}/alarms": {
      "delete": {
        "description": "Deletes all the alarms named in the JSON string array in the body.  All alarms acted\non must be within a single namespace.  It is possible for some deletes on alarms to have\nbeen successful and other deletes to have failed if an error is returned.",
        "operationId": "alarmDeleteNamespaceAlarms",
        "parameters": [
          {
            "description": "The namespace in which to delete alarms.",
            "in": "path",
            "name": "nsName",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/AlarmNamespaceAndName"
                },
                "type": "array"
              }
            }
          },
          "description": "The names of the alarms to be deleted.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Any failures will be returned as error-items in the resulting body:ErrorResponse."
          }
        },
        "tags": [
          "coreAlarms"
        ]
      },
      "get": {
        "description": "This API can get a snapshot of the alarms, or can return a stream of the alarms and the changes to them.\nThe API does not provide suppressed alarms by default, but the suppressed alarms will be included if the \"all\" query parameter is set to \"true\".\nThe alarm fields returned can optionally be specified using the \"fields\" query parameter.\nThe alarm namespace and name fields are never filtered.\nThe set of alarms returned can be filtered by providing the \"filter\" query parameter.",
        "operationId": "alarmGetNamespaceAlarms",
        "parameters": [
          {
            "description": "The namespace to fetch the alarms from",
            "in": "path",
            "name": "nsName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "requests all alarms; the default is to filter-out suppressed alarms.\nValue must be \"true\" to get all alarms.",
            "in": "query",
            "name": "all",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "a comma-separated list of alarm fields to fetch/return.  If unspecified, all fields are fetched.  If an empty list, only the alarm name and namespace will be returned.",
            "in": "query",
            "name": "fields",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "an EDA-query-language \"where\" expression that will be used to filter the list of alarms fetched.",
            "in": "query",
            "name": "filter",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/AlarmData"
                  },
                  "type": "array"
                }
              },
              "application/yaml": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/AlarmData"
                  },
                  "type": "array"
                }
              }
            },
            "description": "The response for a successful non-streaming GET alarms request."
          },
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "summary": "Gets all alarms from a specific namespace.",
        "tags": [
          "coreAlarms"
        ]
      },
      "put": {
        "description": "Performs the specified acknowledgement action provided in the \"action\" query\non the alarms named in the JSON string array in the body.  All alarms acted on must be\nwithin a single namespace.  It is possible for some actions on alarms to have been\nsuccessful and other actions to have failed if an error is returned.",
        "operationId": "alarmPutNamespaceAlarms",
        "parameters": [
          {
            "description": "The namespace in which to perform the actions.",
            "in": "path",
            "name": "nsName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Type of action to take for the alarm.",
            "in": "query",
            "name": "action",
            "required": true,
            "schema": {
              "enum": [
                "acknowledge",
                "unacknowledge",
                "suppress",
                "unsuppress"
              ],
              "type": "string"
            }
          },
          {
            "description": "The duration (in milliseconds) for the specified acknowledge or suppress action.",
            "in": "query",
            "name": "duration",
            "schema": {
              "format": "int64",
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/AlarmNamespaceAndName"
                },
                "type": "array"
              }
            }
          },
          "description": "The namespace/name of the alarms on which the action should be taken.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Any failures will be returned as error-items in the resulting body:ErrorResponse."
          }
        },
        "tags": [
          "coreAlarms"
        ]
      }
    },
    "/core/alarm/v2/namespaces/{nsName}/alarms/{alarm-name}": {
      "delete": {
        "description": "Deletes the namespaced alarm with the specified name (alarm-name).  If the alarm is not\ncleared, the alarm will not be deleted, but there will be no error.",
        "operationId": "alarmDeleteNamespaceAlarm",
        "parameters": [
          {
            "description": "The namespace of the alarm to delete.",
            "in": "path",
            "name": "nsName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the alarm to delete.",
            "in": "path",
            "name": "alarm-name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "tags": [
          "coreAlarms"
        ]
      },
      "get": {
        "description": "This API can get a snapshot of the alarm, or a stream of changes to that alarm.\nThe API does not provide information about a suppressed alarm by default, but the suppressed alarm will be included if the \"all\" query parameter is set to \"true\".",
        "operationId": "alarmGetNamespaceAlarm",
        "parameters": [
          {
            "description": "The namespace to fetch the alarm from",
            "in": "path",
            "name": "nsName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the alarm to retrieve",
            "in": "path",
            "name": "alarm-name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "requests all alarms; the default is to filter-out suppressed alarms.\nValue must be \"true\" to get information about a suppressed alarm.",
            "in": "query",
            "name": "all",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlarmData"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AlarmData"
                }
              }
            },
            "description": "The response for a successful non-streaming GET single alarm request."
          },
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "summary": "Gets a single namespaced alarm, as specified by the nsName and alarm-name parameters.",
        "tags": [
          "coreAlarms"
        ]
      },
      "put": {
        "description": "Performs the specified acknowledgement action provided in the \"action\" query\non the namespaced alarm with the specified name (alarm-name).",
        "operationId": "alarmPutNamespaceAlarm",
        "parameters": [
          {
            "description": "Type of action to take for the alarm.",
            "in": "query",
            "name": "action",
            "required": true,
            "schema": {
              "enum": [
                "acknowledge",
                "unacknowledge",
                "suppress",
                "unsuppress"
              ],
              "type": "string"
            }
          },
          {
            "description": "The duration (in milliseconds) for the specified acknowledge or suppress action.",
            "in": "query",
            "name": "duration",
            "schema": {
              "format": "int64",
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "The namespace of the alarm on which the action is taken.",
            "in": "path",
            "name": "nsName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the alarm on which the action is taken.",
            "in": "path",
            "name": "alarm-name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "tags": [
          "coreAlarms"
        ]
      }
    },
    "/core/alarm/v2/namespaces/{nsName}/alarms/{alarm-name}/history": {
      "get": {
        "description": "and if requested the history of the alarm will be streamed back on the provided stream,\nincluding any subsequent changes.  If not using streaming, a snapshot of the history\nwill be returned.",
        "operationId": "alarmGetNamespaceAlarmHistory",
        "parameters": [
          {
            "description": "the name of the namespace for the alarm",
            "in": "path",
            "name": "nsName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "name of the alarm whose history should be retrieved.",
            "in": "path",
            "name": "alarm-name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/AlarmHistoryEntry"
                  },
                  "type": "array"
                }
              },
              "application/yaml": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/AlarmHistoryEntry"
                  },
                  "type": "array"
                }
              }
            },
            "description": "The response for a successful non-streaming GET alarm history request."
          },
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "summary": "Gets the history of the specified alarm in a namespace.  This API supports streaming,",
        "tags": [
          "coreAlarms"
        ]
      }
    },
    "/core/autocomplete/v1/fields": {
      "post": {
        "description": "Gets a list of auto-completions for the field whose values begin with the string sent in the 'value' property of the request body, and applicable to the table specified by the 'table' property of the request body.",
        "operationId": "autoCompleteFieldsRequest",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AutoCompleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              }
            },
            "description": "The response for a successful POST label selector completion request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets a list of auto-completions for the field of a table.",
        "tags": [
          "coreAutoComplete"
        ]
      }
    },
    "/core/autocomplete/v1/gvk": {
      "post": {
        "description": "Fetches a list of names for the instances of the specified EDA resource (identified by the \"group\", \"version\" and \"kind\" in the posted details, the \"type\" in the details must be \"gvk\") whose names begin with the string sent in the 'value' property of the request body.\nIn the completion results for this endpoint, the \"completion\" fields are replacements, not intended to be appended to the user input.",
        "operationId": "autoCompleteGVKRequest",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AutoCompleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              }
            },
            "description": "The response for a successful POST label selector completion request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets a list of names for the instances of the specified EDA resource identified by the \"kind\".",
        "tags": [
          "coreAutoComplete"
        ]
      }
    },
    "/core/autocomplete/v1/gvr": {
      "post": {
        "description": "Fetches a list of names for the instances of the specified EDA resource (identified by the \"group\", \"version\" and \"resource\" in the posted details, the \"type\" in the details must be \"gvr\") whose names begin with the string sent in the 'value' property of the request body.\nIn the completion results for this endpoint, the \"completion\" fields are replacements, not intended to be appended to the user input.",
        "operationId": "autoCompleteGVRRequest",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AutoCompleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              }
            },
            "description": "The response for a successful POST label selector completion request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets a list of names for the instances of the specified EDA resource identified by the \"resource\".",
        "tags": [
          "coreAutoComplete"
        ]
      }
    },
    "/core/autocomplete/v1/labels": {
      "post": {
        "description": "Gets a list of auto-completions for labels identified by the \"gvk\" in the posted details whose names begin with the string sent in the 'value' property of the request body.",
        "operationId": "toolsGetLabelCompletions",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLabelCompletionRequest"
              }
            }
          },
          "description": "The type of label completion - key, value, or gvks",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LabelCompletionResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/LabelCompletionResponse"
                }
              }
            },
            "description": "The potential label completions from the request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets a list of suggested key/value for labels.",
        "tags": [
          "coreAutoComplete"
        ]
      }
    },
    "/core/autocomplete/v1/labelselector": {
      "post": {
        "description": "Gets a list of text-completions based on the partial label-selector string passed as the value in the request,\nin the context of the labels/values on the instances of the resource type indicated in the details.",
        "operationId": "autoCompleteLabelSelectorRequest",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AutoCompleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              }
            },
            "description": "The response for a successful POST label selector completion request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets a list of text-completions to help the requestor construct a label-selector.",
        "tags": [
          "coreAutoComplete"
        ]
      }
    },
    "/core/autocomplete/v1/table": {
      "post": {
        "description": "Gets a list of auto-completions for a table name. The table names returned in the completion will be table names whose prefix is the contatenation of the \"table-prefix\" and \"value\" field from the request.",
        "operationId": "autoCompleteTableRequest",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AutoCompleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              }
            },
            "description": "The response for a successful POST label selector completion request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets a list of auto-completions for a table name.",
        "tags": [
          "coreAutoComplete"
        ]
      }
    },
    "/core/autocomplete/v1/where": {
      "post": {
        "description": "Gets a list of auto-completions for the EQL where clause whose values begin with the string sent in the 'value' property of the request body, and applicable to the table specified by the 'table' property of the request body.",
        "operationId": "autoCompleteWhereRequest",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AutoCompleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/AutoCompleteResponse"
                }
              }
            },
            "description": "The response for a successful POST label selector completion request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets a list of auto-completions for a EQL where clause.",
        "tags": [
          "coreAutoComplete"
        ]
      }
    },
    "/core/chat/v1": {
      "post": {
        "operationId": "chatOpenChat",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {},
            "description": ""
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "summary": "Opens a new chat stream with the EDA AI assistants",
        "tags": [
          "coreChat"
        ]
      }
    },
    "/core/chat/v1/chats": {
      "get": {
        "operationId": "chatGetConversationList",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConversationList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/ConversationList"
                }
              }
            },
            "description": "The response for a successful conversation list GET request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "summary": "Gets a list of all saved AI Chat conversations",
        "tags": [
          "coreChat"
        ]
      }
    },
    "/core/chat/v1/chats/{chatId}": {
      "delete": {
        "operationId": "chatDeleteConversation",
        "parameters": [
          {
            "description": "The ID of the requested chat",
            "in": "path",
            "name": "chatId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "summary": "Deletes conversation history for the chat with the provided ID",
        "tags": [
          "coreChat"
        ]
      },
      "get": {
        "operationId": "chatGetConversationHistory",
        "parameters": [
          {
            "description": "The ID of the requested chat",
            "in": "path",
            "name": "chatId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConversationHistory"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/ConversationHistory"
                }
              }
            },
            "description": "The response for a successful conversation history GET request"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "ErrorResponse"
          }
        },
        "summary": "Gets conversation history for the chat with the provided ID",
        "tags": [
          "coreChat"
        ]
      },
      "put": {
        "operationId": "chatUpdateConversation",
        "parameters": [
          {
            "description": "The ID of the requested chat",
            "in": "path",
            "name": "chatId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConversationInfo"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConversationInfo"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/ConversationInfo"
                }
              }
            },
            "description": "The response for a successful conversation info POST request"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Updates the conversation details with the provided",
        "tags": [
          "coreChat"
        ]
      }
    },
    "/core/db/v1/{path}": {
      "get": {
        "description": "Fetch/stream the rows of the specified EDA database table.\nDeprecated: Use /core/db/v2/data instead.\n\nThe table path is specified via the \"path\" parameter in the URL path.\nThere is a way that keys can be specified for any subtables, allowing restriction\nof the returned rows to those having the specified keys.\nThe key specification is performed by providing query parameters where the parameter name\nis the path for the table key the requestor wishes to fix, and the parameter value is the\nvalue of the key.\n\nFor example, the user could request only the nodes in the 'my-namespace' EDA namespace by\nusing a path of \"namespace/nodes\" and a query parameter of \".namespace.name=my-namespace\"\n\nSimilarly, the user could request the row for a single node (named 'leaf-1') in the 'eda'\nnamespace by using a path of \"namespace/nodes\" and query parameters \".namespace.name=eda&.namespace.node.name=leaf-1\"\n\nAccess to tables is controlled by the EDA table rules present in cluster roles only. Table rules\nin namespaced roles are not consulted for access.",
        "operationId": "deprecatedGetDB",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "a comma-separated list of table fields to fetch/return.  If unspecified, all fields are fetched.  If empty, no data for a row will be returned; only the JSON path for the table row.",
            "in": "query",
            "name": "fields",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "an EQL \"where\" expression that will be used to filter the set of table rows returned.",
            "in": "query",
            "name": "filter",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "if true/present, only send updates to the table rows, not the current rows.  Only applicable if streaming the results.",
            "in": "query",
            "name": "updates-only",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "if true/present, the keys of the table are included in the table data.",
            "in": "query",
            "name": "includeKeys",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "the path for the table to retrieve from the DB, specified as slash-separated table-name components",
            "in": "path",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dbGetResult"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/dbGetResult"
                }
              },
              "text/csv": {
                "schema": {}
              }
            },
            "description": "The response for a successful EDA database get operation."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Deprecated version of fetching/streaming the rows of the specified EDA database table.",
        "tags": [
          "coreDB"
        ],
        "deprecated": true
      }
    },
    "/core/db/v2/data": {
      "get": {
        "description": "The table path is specified via the \"jsPath\" query parameter.\nKeys optionally can be included inside the specific jsPath.\n\nAccess to tables is controlled by the EDA table rules present in cluster roles only. Table rules\nin namespaced roles are not consulted for access.",
        "operationId": "getDB",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "a comma-separated list of table fields to fetch/return.  If unspecified, all fields are fetched.  If empty, no data for a row will be returned; only the JSON path for the table row.",
            "in": "query",
            "name": "fields",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "an EQL \"where\" expression that will be used to filter the set of table rows returned.",
            "in": "query",
            "name": "filter",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "if true/present, only send updates to the table rows, not the current rows.  Only applicable if streaming the results.",
            "in": "query",
            "name": "updates-only",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "if true/present, the keys of the table are included in the table data.",
            "in": "query",
            "name": "includeKeys",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "the jsPath for the table to retrieve from the DB, with or without keys embedded in the path",
            "in": "query",
            "name": "jsPath",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dbGetResult"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/dbGetResult"
                }
              },
              "text/csv": {
                "schema": {}
              }
            },
            "description": "The response for a successful EDA database get operation."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Fetch/stream the rows of the specified EDA database table.",
        "tags": [
          "coreDB"
        ]
      }
    },
    "/core/db/v2/schema": {
      "get": {
        "description": "The table name is specified via the \"tableName\" query parameter.\n\nAccess to tables is controlled by the EDA table rules present in cluster roles only. Table rules\nin namespaced roles are not consulted for access.",
        "operationId": "getSchema",
        "parameters": [
          {
            "description": "the name of the table to retrieve the schema from the database",
            "in": "query",
            "name": "tableName",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dbGetResult"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/dbGetResult"
                }
              }
            },
            "description": "The response for a successful EDA database get schema operation."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Fetch the schema of the specified EDA database table.",
        "tags": [
          "coreDB"
        ]
      }
    },
    "/core/nodeconfig/v2/namespaces/{nsName}/nodes/{nodeName}": {
      "get": {
        "operationId": "toolsGetNodeConfig",
        "parameters": [
          {
            "description": "The namespace of the node whose config are being requested",
            "in": "path",
            "name": "nsName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the node whose config are being requested",
            "in": "path",
            "name": "nodeName",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NodeConfigResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/NodeConfigResponse"
                }
              }
            },
            "description": "The response for a successful GET node config request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets the node config of a node.",
        "tags": [
          "coreNodeconfig"
        ]
      }
    },
    "/core/query/v1": {
      "get": {
        "description": "Streaming API:\nInitiate a streaming query request using the EDA query language.\n\nNon Streaming API:\nREST endpoint supporting one-shot queries.\n\nWhenever the information described by the query parameter changes,\nthe result of the query will be sent to the requestor/client via the specified stream.\nNote that if the namespaces argument is not provided, the user must have cluster role\npermission to access the table specified in the query. If one or more namespaces\nare supplied, the user must have cluster role permission, or role permission (in all\nthe specified namespaces) to access the table specified in the query.",
        "operationId": "queryGetQuery",
        "parameters": [
          {
            "description": "the information being queried, in the EDA query language",
            "in": "query",
            "name": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "the comma-separated list of namespaces against which the query should be executed",
            "in": "query",
            "name": "namespaces",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/QueryResponse"
                }
              },
              "text/csv": {
                "schema": {}
              }
            },
            "description": "The response returned for a non-streamed query."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Query request using the EDA query language",
        "tags": [
          "coreQuery"
        ]
      }
    },
    "/core/query/v1/convert": {
      "post": {
        "description": "Given a jspath on input, this request returns the table, where clause and\na full EQL query for that jspath.  Any keys in the jspath are converted into\nthe appropriate conditions in the where clause.",
        "operationId": "queryConvertRequest",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryConvertRequest"
              }
            }
          },
          "description": "the",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryConvertResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/QueryConvertResponse"
                }
              }
            },
            "description": "The response for a successful query conversion POST request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreQuery"
        ]
      }
    },
    "/core/query/v1/eql": {
      "get": {
        "description": "Streaming API:\nInitiate a streaming query request using the EDA query language.\n\nNon Streaming API:\nREST endpoint supporting one-shot queries.\n\nWhenever the information described by the query parameter changes,\nthe result of the query will be sent to the requestor/client via the specified stream.\nNote that if the namespaces argument is not provided, the user must have cluster role\npermission to access the table specified in the query. If one or more namespaces\nare supplied, the user must have cluster role permission, or role permission (in all\nthe specified namespaces) to access the table specified in the query.",
        "operationId": "queryGetEqlQuery",
        "parameters": [
          {
            "description": "the information being queried, in the EDA query language",
            "in": "query",
            "name": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "the comma-separated list of namespaces against which the query should be executed",
            "in": "query",
            "name": "namespaces",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/QueryResponse"
                }
              },
              "text/csv": {
                "schema": {}
              }
            },
            "description": "The response returned for a non-streamed query."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Query request using the EDA query language",
        "tags": [
          "coreQuery"
        ]
      }
    },
    "/core/query/v1/eql/autocomplete": {
      "get": {
        "description": "Returns auto-completion information for the given (incomplete) EQA query language query.\nThe number of results returned can be limited with an optional parameter.",
        "operationId": "queryGetEqlQueryAutoComplete",
        "parameters": [
          {
            "description": "the EDA query language request string",
            "in": "query",
            "name": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "limit on the number of auto-completion results returned by the request",
            "in": "query",
            "name": "completion_limit",
            "schema": {
              "format": "uint32",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryCompletionResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/QueryCompletionResponse"
                }
              }
            },
            "description": "The response for a successful query auto-completion GET request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Request auto-completion for the specified EDA query-language string.",
        "tags": [
          "coreQuery"
        ]
      }
    },
    "/core/query/v1/nql": {
      "get": {
        "description": "Streaming API:\nInitiate a streaming query request using the 'natural' query language.\n\nNon Streaming API:\nREST endpoint supporting one-shot queries.\n\nWhenever the information described by the query parameter changes,\nthe result of the query will be sent to the requestor/client via the specified stream.\nNote that if the namespaces argument is not provided, the user must have cluster role\npermission to access the table specified in the query. If one or more namespaces\nare supplied, the user must have cluster role permission, or role permission (in all\nthe specified namespaces) to access the table specified in the query.",
        "operationId": "queryGetNqlQuery",
        "parameters": [
          {
            "description": "the information being queried, in the natural query language",
            "in": "query",
            "name": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "the comma-separated list of namespaces against which the query should be executed",
            "in": "query",
            "name": "namespaces",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryResponse"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/QueryResponse"
                }
              },
              "text/csv": {
                "schema": {}
              }
            },
            "description": "The response returned for a non-streamed query."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Query request using the 'natural' query language",
        "tags": [
          "coreQuery"
        ]
      }
    },
    "/core/store/v1/appsettingsdefinition/catalog/{catalog}/app/{appId}": {
      "get": {
        "description": "The version should be specified by  the semVer query parameter.",
        "operationId": "storeGetAppSettingsDefinition",
        "parameters": [
          {
            "description": "The catalog where the application version resides",
            "in": "path",
            "name": "catalog",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "application ID of the application version",
            "in": "path",
            "name": "appId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The semantic version for the application version.",
            "in": "query",
            "name": "semVer",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The commit hash for the application version.",
            "in": "query",
            "name": "commitHash",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppSettingsDefinition"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppSettingsDefinition"
                }
              }
            },
            "description": "The application settings definition corresponding to the request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Fetches the application settings definition for the provided appId and version",
        "tags": [
          "coreStore"
        ]
      }
    },
    "/core/store/v1/appsummaries": {
      "get": {
        "description": "Retrieve a list of all applications that are discovered by the EDA store in all catalogs.\nThe list can be optionally filtered based on the installed and upgradable state of the applications.",
        "operationId": "storeGetAppSummaries",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If present and true, and the application is installed, the application information will be derived from the installed application version.",
            "in": "query",
            "name": "prioritizeInstalledInfo",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "If present, this causes only installed(if true)/uninstalled(if false) applications to be returned.",
            "in": "query",
            "name": "installed",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "If present, this causes only upgradable(if true)/up-to-date(if false) applications to be returned.",
            "in": "query",
            "name": "upgradable",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppSummaryList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppSummaryList"
                }
              }
            },
            "description": "List of application summaries from the EDA store"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Retrieve application summary list",
        "tags": [
          "coreStore"
        ]
      }
    },
    "/core/store/v1/appsummaries/app/{appId}": {
      "get": {
        "description": "Retrieve an application summary for the application with the provided appId.\nCan also be filtered based on the installed and upgradable state of the application",
        "operationId": "storeGetAppSummary",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If present and true, and the application is installed, the application information will be derived from the installed application version.",
            "in": "query",
            "name": "prioritizeInstalledInfo",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "When true, only return the summary for the specified application if the application is installed",
            "in": "query",
            "name": "installed",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "When true, only return the summary for the specified application if the application is upgradable",
            "in": "query",
            "name": "upgradable",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "Application ID of the application summary to be returned",
            "in": "path",
            "name": "appId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppSummary"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppSummary"
                }
              }
            },
            "description": "The application summary for the specified appId"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Retrieve application summary for a given appId",
        "tags": [
          "coreStore"
        ]
      }
    },
    "/core/store/v1/categories": {
      "get": {
        "description": "Retrieves the list of application categories that are set on all the applications in all the catalogs in the store.",
        "operationId": "storeGetCategories",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoreCategoryList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/StoreCategoryList"
                }
              }
            },
            "description": "Array of application category strings from the EDA store"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Retrieve application category list",
        "tags": [
          "coreStore"
        ]
      }
    },
    "/core/store/v1/file/catalog/{catalog}/app/{appId}/{path}": {
      "get": {
        "description": "The version should be specified by one or the other (not both) of the semVer and commitHash\nquery parameters.",
        "operationId": "storeGetAppFile",
        "parameters": [
          {
            "description": "The catalog where the application version resides",
            "in": "path",
            "name": "catalog",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "application ID of the application version",
            "in": "path",
            "name": "appId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The semantic version for the application version.",
            "in": "query",
            "name": "semVer",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The commit hash for the application version.",
            "in": "query",
            "name": "commitHash",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "the path in the application for the requested file",
            "in": "path",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/octet-stream": {
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              }
            },
            "description": "The binary content of the requested file"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "retrieves the contents of the file in the application version specified by the arguments to the request.",
        "tags": [
          "coreStore"
        ]
      }
    },
    "/core/store/v1/installedsettings/app/{appId}": {
      "get": {
        "operationId": "storeGetAppInstalledSettings",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "application ID of the application whose settings should be retrieved.",
            "in": "path",
            "name": "appId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppInstalledSettings"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppInstalledSettings"
                }
              }
            },
            "description": "The currently installed settings for the application."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets the currently installed settings for the specified application.",
        "tags": [
          "coreStore"
        ]
      }
    },
    "/core/store/v1/manifest/catalog/{catalog}/app/{appId}": {
      "get": {
        "description": "The version should be specified by one or the other (not both) of the semVer and commitHash\nquery parameters.",
        "operationId": "storeGetAppManifest",
        "parameters": [
          {
            "description": "The catalog where the application version resides",
            "in": "path",
            "name": "catalog",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "application ID of the application version",
            "in": "path",
            "name": "appId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The semantic version for the application version.",
            "in": "query",
            "name": "semVer",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The commit hash for the application version.",
            "in": "query",
            "name": "commitHash",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppManifest"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppManifest"
                }
              }
            },
            "description": "Application manifest"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "retrieves the manifest of the specified version of the application from the specified catalog.",
        "tags": [
          "coreStore"
        ]
      }
    },
    "/core/store/v1/requirementsgraph/catalog/{catalog}/app/{appId}": {
      "get": {
        "description": "The version should be specified by the semVer query parameter.",
        "operationId": "storeGetAppRequirementsGraph",
        "parameters": [
          {
            "description": "The catalog where the application version resides",
            "in": "path",
            "name": "catalog",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "application ID of the application version",
            "in": "path",
            "name": "appId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The semantic version for the application version.",
            "in": "query",
            "name": "semVer",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The commit hash for the application version.",
            "in": "query",
            "name": "commitHash",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppRequirementsGraph"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppRequirementsGraph"
                }
              }
            },
            "description": "The requirements graph information corresponding to the request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Initiates the calculation of (if necessary) and retrieves the requirements graph for the application version specified specified by the arguments to the request.",
        "tags": [
          "coreStore"
        ]
      }
    },
    "/core/store/v1/versions/app/{appId}": {
      "get": {
        "description": "Retrieves the versions of the specified application available in the EDA store.",
        "operationId": "storeGetAppVersions",
        "parameters": [
          {
            "description": "application ID of the application whose versions should be retrieved",
            "in": "path",
            "name": "appId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppVersionList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/StoreAppVersionList"
                }
              }
            },
            "description": "List of versions of the application"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Retrieve list of application versions",
        "tags": [
          "coreStore"
        ]
      }
    },
    "/core/topology/v1": {
      "get": {
        "description": "list topologies that have been published in the database",
        "operationId": "topologies",
        "parameters": [
          {
            "description": "Client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Topologies"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/Topologies"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreTopology"
        ]
      }
    },
    "/core/topology/v1/{topologyName}": {
      "get": {
        "description": "get the metadata for a specific topology",
        "operationId": "topology",
        "parameters": [
          {
            "description": "The name of the topology to retrieve",
            "in": "path",
            "name": "topologyName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Topology"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/Topology"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreTopology"
        ]
      }
    },
    "/core/topology/v1/{topologyName}/groupings": {
      "get": {
        "operationId": "getTopologyGroupings",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "the name of the topology whose grouping(s) should be retrieved",
            "in": "path",
            "name": "topologyName",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TopologyGroupingsList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TopologyGroupingsList"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Fetch the groupings defined for the specified topology. The result will be in the form of a list of instances of the custom record definition defined for the groupings in the specified topology.",
        "tags": [
          "coreTopology"
        ]
      }
    },
    "/core/topology/v1/{topologyName}/groupings/{groupingName}": {
      "get": {
        "operationId": "getTopologyGrouping",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "the name of the topology whose grouping(s) should be retrieved",
            "in": "path",
            "name": "topologyName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "the name of the grouping to retrieve",
            "in": "path",
            "name": "groupingName",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TopologyGroupingInstance"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TopologyGroupingInstance"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Fetch the named grouping for the specified topology. The result will be an instance of the custom record definition defined for the groupings in the specified topology.",
        "tags": [
          "coreTopology"
        ]
      }
    },
    "/core/topology/v1/{topologyName}/overlay": {
      "get": {
        "description": "list overlays for a specific topology",
        "operationId": "overlays",
        "parameters": [
          {
            "description": "The name of the topology on which to list overlays",
            "in": "path",
            "name": "topologyName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Overlays"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/Overlays"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreTopology"
        ]
      }
    },
    "/core/topology/v1/{topologyName}/overlay/{overlayName}": {
      "get": {
        "description": "get the metadata for a specific overlay",
        "operationId": "overlay",
        "parameters": [
          {
            "description": "The name of the topology to that owns this overlay",
            "in": "path",
            "name": "topologyName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The name of the overlay to retrieve",
            "in": "path",
            "name": "overlayName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Overlay"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/Overlay"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreTopology"
        ]
      }
    },
    "/core/topology/v1/{topologyName}/state": {
      "post": {
        "description": "get the state of a specific topology with option to specify the namespace, groupings and overlays",
        "operationId": "topologyPostState",
        "parameters": [
          {
            "description": "The name of the topology from which to get the state",
            "in": "path",
            "name": "topologyName",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TopoStateRequest"
              }
            }
          },
          "description": "The options to specify the namespace, grouping and overlays for the topology.",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OverlayState"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/OverlayState"
                }
              }
            },
            "description": "OK"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreTopology"
        ]
      }
    },
    "/core/transaction/v2": {
      "post": {
        "operationId": "transPostTransaction",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Transaction"
              }
            }
          },
          "description": "Details of the transaction",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionId"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionId"
                }
              }
            },
            "description": "The response for a successful POST transaction request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Runs a transaction.",
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/restore/{transactionId}": {
      "post": {
        "operationId": "transRestoreTransaction",
        "parameters": [
          {
            "description": "The identifier for the transaction being reverted or restored.",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransactionRevertRestoreRequest"
              }
            }
          },
          "description": "Options for describing how to revert or restore this transaction",
          "required": false
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionId"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionId"
                }
              }
            },
            "description": "The identifier for the transaction ID used to restore to the state of the specified transaction."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Restores the configuration of the system to the state at the time of the transaction identified by the specified transaction id.",
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/result/diffs/nodecfg/{transactionId}": {
      "get": {
        "operationId": "transGetNodeConfigDiff",
        "parameters": [
          {
            "description": "The identifier for the transaction whose resource diff is being requested",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          },
          {
            "description": "Name of the node for the configuration diff being requested",
            "in": "query",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Namespace of the node for the configuration diff being requested.",
            "in": "query",
            "name": "namespace",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionResultObject"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionResultObject"
                }
              }
            },
            "description": "The response for a successful GET transaction-diffs request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Get the diff view of a node configuration change from a transaction.",
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/result/diffs/resource/{transactionId}": {
      "get": {
        "operationId": "transGetResourceDiff",
        "parameters": [
          {
            "description": "The identifier for the transaction whose resource diff is being requested",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          },
          {
            "description": "Group information for the resource diff being requested.  Group is required but can be empty for non-EDA resources",
            "in": "query",
            "name": "group",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Version information for the resource diff being requested.  Version is required",
            "in": "query",
            "name": "version",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "kind information for the resource diff being requested.  Kind is required",
            "in": "query",
            "name": "kind",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Name information for the resource diff being requested.  Name is required",
            "in": "query",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Namespace information for the resource diff being requested.  Namespace is\nrequired if the resource is namespaced or is a non-EDA resource",
            "in": "query",
            "name": "namespace",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionResultObject"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionResultObject"
                }
              }
            },
            "description": "The response for a successful GET transaction-diffs request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets the diff view of a resource change from a posted transaction.",
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/result/execution/{transactionId}": {
      "get": {
        "operationId": "transGetResultExecution",
        "parameters": [
          {
            "description": "The identifier for the transaction whose details are being requested",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          },
          {
            "description": "Flag for the request to wait until the transaction is complete before returning.  By default it returns the current state.",
            "in": "query",
            "name": "waitForComplete",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "Flag to tell the request to fail if the transaction has errors.  By default it will not fail.",
            "in": "query",
            "name": "failOnErrors",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionExecutionResult"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionExecutionResult"
                }
              }
            },
            "description": "The response for a successful GET transaction-result-execution request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets the details of a posted transaction.  This does not include the input resources, which can be retrieved using the transGetResultInputResources operation.",
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/result/inputresources/{transactionId}": {
      "get": {
        "description": "If the user does not have read access to any resources, these resources will not be included in the list, and in this\ncase the the limitedAccess field in the response will be set to true.",
        "operationId": "transGetResultInputResources",
        "parameters": [
          {
            "description": "The identifier for the transaction whose list of input resources is being requested",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          },
          {
            "description": "If true the response will contain the full resource body for each input resource",
            "in": "query",
            "name": "full",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionResultInputResources"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionResultInputResources"
                }
              }
            },
            "description": "The response for a successful GET transaction-result-inputresources request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets the input resources of a posted transaction.  This list is filtered by the access rights of the requesting user.",
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/result/summary": {
      "get": {
        "description": "Gets summarized results of transactions for all users.  These results can be streamed back to the requestor if\nthe appropriate streaming parameters are supplied.",
        "operationId": "transGetSummaryResultList",
        "parameters": [
          {
            "description": "Maximum number of transaction results to return",
            "in": "query",
            "name": "size",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          },
          {
            "description": "When provided, the liast of transactions is limited to those initiated by the specified user.",
            "in": "query",
            "name": "username",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionSummaryResults"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionSummaryResults"
                }
              }
            },
            "description": "The response for a successful GET transaction-result-summary-list request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/result/summary/{transactionId}": {
      "get": {
        "operationId": "transGetSummaryResult",
        "parameters": [
          {
            "description": "The identifier for the transaction whose state is being requested",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          },
          {
            "description": "Flag for the request to wait until the transaction is complete before returning.  By default it returns the current state.",
            "in": "query",
            "name": "waitForComplete",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionSummaryResult"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionSummaryResult"
                }
              }
            },
            "description": "The response for a successful GET transaction-result-summary request.\nThis request returns the summary for a single, specified transaction."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets summarized results of a single transaction.",
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/result/topology/{transactionId}": {
      "get": {
        "deprecated": true,
        "operationId": "transGetResultTopology",
        "parameters": [
          {
            "description": "The identifier for the transaction whose topology is being requested",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionTopologyResult"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionTopologyResult"
                }
              }
            },
            "description": "The response for a successful GET transaction-result-topology request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Gets a topology of a transaction.  This API is deprecated.  Use the POST API instead.",
        "tags": [
          "coreTransaction"
        ]
      },
      "post": {
        "operationId": "transPostResultTopology",
        "parameters": [
          {
            "description": "The identifier for the transaction whose topology is being requested",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          },
          {
            "description": "Client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/transactionTopologyRequest"
              }
            }
          },
          "description": "The filter to apply to the topology",
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionTopologyResult"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionTopologyResult"
                }
              }
            },
            "description": "The response for a successful GET transaction-result-topology request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Returns or streams a topology of a transaction.",
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/revert/{transactionId}": {
      "post": {
        "operationId": "transRevertTransaction",
        "parameters": [
          {
            "description": "The identifier for the transaction being reverted or restored.",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransactionRevertRestoreRequest"
              }
            }
          },
          "description": "Options for describing how to revert or restore this transaction",
          "required": false
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionId"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionId"
                }
              }
            },
            "description": "The identifier for the transaction ID used to revert the transaction."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Reverts the transaction identified by the transaction id.",
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/state/{transactionId}": {
      "get": {
        "description": "Gets the state of a posted transaction.  State changes for the transaction\ncan be streamed back to the requestor if the appropriate streaming parameters are supplied.",
        "operationId": "transGetState",
        "parameters": [
          {
            "description": "The identifier for the transaction whose state is being requested",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "schema": {
              "format": "uint64",
              "type": "integer"
            }
          },
          {
            "description": "Client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionState"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionState"
                }
              }
            },
            "description": "The response for a successful GET transaction-state request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/transaction/v2/validate": {
      "post": {
        "operationId": "transValidateTransaction",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/TransactionCr"
                },
                "type": "array"
              }
            }
          },
          "description": "The CRs to validate",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Validates a list of CRs to check that they are properly formed before later adding them to a transaction.",
        "tags": [
          "coreTransaction"
        ]
      }
    },
    "/core/user-storage/v2/directory": {
      "delete": {
        "description": "delete a user-storage directory (and its contents)",
        "operationId": "ussDeleteDirectory",
        "parameters": [
          {
            "description": "path for the file/directory being manipulated",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      },
      "get": {
        "description": "gets the content of a user-storage directory",
        "operationId": "ussGetDirectory",
        "parameters": [
          {
            "description": "path for the file/directory being manipulated",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "if true, file content will be base64-encoded before being returned",
            "in": "query",
            "name": "base64-encode",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserStorageOutDirContent"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/UserStorageOutDirContent"
                }
              }
            },
            "description": "The response for a successful GET directory user-storage request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      }
    },
    "/core/user-storage/v2/file": {
      "delete": {
        "description": "deletes a user-storage file",
        "operationId": "ussDeleteFile",
        "parameters": [
          {
            "description": "path for the file/directory being manipulated",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      },
      "get": {
        "description": "returns the content of a single user-storage file",
        "operationId": "ussGetFile",
        "parameters": [
          {
            "description": "path for the file/directory being manipulated",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "if true, file content will be base64-encoded before being returned",
            "in": "query",
            "name": "base64-encode",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserStorageOutFileContent"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/UserStorageOutFileContent"
                }
              }
            },
            "description": "The response for a successful GET file user-storage request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      },
      "post": {
        "description": "Creates/writes the content of a user-storage file",
        "operationId": "ussPostFile",
        "parameters": [
          {
            "description": "path for the file whose contents should be written",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "true if the content was base64-encoded before being sent.",
            "in": "query",
            "name": "base64-encoded",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserStorageInFileContent"
              }
            }
          },
          "description": "content for the file",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      },
      "put": {
        "description": "Creates a user-storage file",
        "operationId": "ussPutFile",
        "parameters": [
          {
            "description": "path for the file whose contents should be written",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "true if the content was base64-encoded before being sent.",
            "in": "query",
            "name": "base64-encoded",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserStorageInFileContent"
              }
            }
          },
          "description": "content for the file",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      }
    },
    "/core/user-storage/v2/files": {
      "delete": {
        "description": "Deletes the user-storage files whose paths are in the JSON string array in the body\nof the request.  There is never partial success.  Either all the deletes succeed,\nor none of them occur.  i.e. if an error response comes back, no files were\ndeleted.",
        "operationId": "ussDeleteFiles",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            }
          },
          "description": "paths for the files being deleted",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Deletes a number of user-storage files as specified in the JSON body of the request.",
        "tags": [
          "coreUss"
        ]
      }
    },
    "/core/user-storage/v2/shared/directory": {
      "delete": {
        "description": "delete a user-storage directory (and its contents) from the shared region",
        "operationId": "ussDeleteSharedDirectory",
        "parameters": [
          {
            "description": "path for the file/directory being manipulated",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      },
      "get": {
        "description": "gets the content of a user-storage directory from the shared region",
        "operationId": "ussGetSharedDirectory",
        "parameters": [
          {
            "description": "path for the file/directory being manipulated",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "if true, file content will be base64-encoded before being returned",
            "in": "query",
            "name": "base64-encode",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserStorageOutDirContent"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/UserStorageOutDirContent"
                }
              }
            },
            "description": "The response for a successful GET directory user-storage request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      }
    },
    "/core/user-storage/v2/shared/file": {
      "delete": {
        "description": "deletes a user-storage file from the shared region",
        "operationId": "ussDeleteSharedFile",
        "parameters": [
          {
            "description": "path for the file/directory being manipulated",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      },
      "get": {
        "description": "returns the content of a single user-storage file from the shared region",
        "operationId": "ussGetSharedFile",
        "parameters": [
          {
            "description": "path for the file/directory being manipulated",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "if true, file content will be base64-encoded before being returned",
            "in": "query",
            "name": "base64-encode",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          },
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserStorageOutFileContent"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/UserStorageOutFileContent"
                }
              }
            },
            "description": "The response for a successful GET file user-storage request."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      },
      "post": {
        "description": "Creates/writes the content of a user-storage file to the shared region",
        "operationId": "ussPostSharedFile",
        "parameters": [
          {
            "description": "path for the file whose contents should be written",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "true if the content was base64-encoded before being sent.",
            "in": "query",
            "name": "base64-encoded",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserStorageInFileContent"
              }
            }
          },
          "description": "content for the file",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      },
      "put": {
        "description": "Creates a user-storage file to the shared region",
        "operationId": "ussPutSharedFile",
        "parameters": [
          {
            "description": "path for the file whose contents should be written",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "true if the content was base64-encoded before being sent.",
            "in": "query",
            "name": "base64-encoded",
            "schema": {
              "default": false,
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserStorageInFileContent"
              }
            }
          },
          "description": "content for the file",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "tags": [
          "coreUss"
        ]
      }
    },
    "/core/user-storage/v2/shared/files": {
      "delete": {
        "description": "Deletes the user-storage files whose paths are in the JSON string array in the body\nof the request.  There is never partial success.  Either all the deletes succeed,\nor none of them occur.  i.e. if an error response comes back, no files were\ndeleted.",
        "operationId": "ussDeleteSharedFiles",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            }
          },
          "description": "paths for the files being deleted",
          "required": true
        },
        "responses": {
          "204": {
            "description": "no data is returned for this response type."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Deletes a number of user-storage files from the shared region as specified in the JSON\nbody of the request.",
        "tags": [
          "coreUss"
        ]
      }
    },
    "/core/workflows/v1": {
      "get": {
        "operationId": "wfListAllNs",
        "parameters": [
          {
            "description": "client information for streaming request",
            "in": "query",
            "name": "eventclient",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "stream information for streaming request",
            "in": "query",
            "name": "stream",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
            "in": "query",
            "name": "fields",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "an EQL \"where\" expression that will be used to filter the set of resources returned.",
            "in": "query",
            "name": "filter",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "a label selector string to filter the results based on CR labels",
            "in": "query",
            "name": "labelSelector",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Deprecated: a label selector string to filter the results based on CR labels",
            "in": "query",
            "name": "label-selector",
            "schema": {
              "type": "string"
            },
            "deprecated": true
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/WorkflowStatusSummary"
                  },
                  "type": "array"
                }
              },
              "application/yaml": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/WorkflowStatusSummary"
                  },
                  "type": "array"
                }
              }
            },
            "description": "List containing a summary of each workflow's status."
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": "Details of an error in response to an API REST request."
          }
        },
        "summary": "Get workflows across all groups, versions, and kinds.",
        "tags": [
          "coreWorkflows"
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "AccessQuery": {
        "properties": {
          "gvk": {
            "$ref": "#/components/schemas/GroupVersionKind"
          },
          "gvr": {
            "$ref": "#/components/schemas/GroupVersionResource"
          },
          "namespace": {
            "description": "The namespace to check. Empty string (or omit) to check for cluster-wide access",
            "type": "string"
          },
          "path": {
            "description": "Target url or table of the access check. Provided when type is table or url",
            "type": "string"
          },
          "permissions": {
            "description": "The permissions for the requested resource/url/table.",
            "enum": [
              "read",
              "readWrite"
            ],
            "type": "string"
          },
          "type": {
            "description": "The type of rule to check for",
            "enum": [
              "gvk",
              "gvr",
              "url",
              "table"
            ],
            "type": "string"
          }
        },
        "required": [
          "type"
        ],
        "type": "object"
      },
      "AccessResult": {
        "properties": {
          "access": {
            "description": "Indicates if the user can access the requested resource",
            "type": "boolean"
          },
          "error": {
            "$ref": "#/components/schemas/ErrorResponse"
          }
        },
        "type": "object"
      },
      "AlarmData": {
        "description": "provides the information about a single alarm or alarm history instance",
        "properties": {
          "acknowledged": {
            "description": "An indication if the alarm has been acknowledged.",
            "type": "boolean"
          },
          "acknowledgedUntil": {
            "description": "Indicates the end time of the acknowledgement.",
            "type": "string"
          },
          "additionalText": {
            "description": "adds extra context related to the alarm",
            "type": "string"
          },
          "cleared": {
            "description": "An indication if the alarm has been cleared.",
            "type": "boolean"
          },
          "clusterMember": {
            "description": "The cluster member that generated this alarm.  Use clusterName instead.\nDeprecated: true",
            "type": "string",
            "deprecated": true
          },
          "clusterName": {
            "description": "The name of the cluster member which generated this alarm.",
            "type": "string"
          },
          "description": {
            "description": "A description for the alarm.",
            "type": "string"
          },
          "group": {
            "description": "Indicates the group of the resource the alarm is present on.",
            "type": "string"
          },
          "jsPaths": {
            "description": "An unnormalized jspath relating to the object in the alarm state. Use jspaths instead.\nDeprecated: true",
            "items": {
              "type": "string"
            },
            "type": "array",
            "deprecated": true
          },
          "jspaths": {
            "description": "An unnormalized jspath relating to the object in the alarm state.",
            "example": [
              ".node{.name==\"spine-1-1\"}.srl{.version==\"24.10.1\"}.interface{.name==\"ethernet-1-1\"}"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "kind": {
            "description": "Indicates the kind of resource the alarm is present on.",
            "type": "string"
          },
          "lastAcknowledged": {
            "description": "the time this alarm was last acknowledged. Use lastAcknowledgedTime instead.\nDeprecated: true",
            "type": "string",
            "deprecated": true
          },
          "lastAcknowledgedBy": {
            "description": "the user who last acknowledged the alarm",
            "type": "string"
          },
          "lastAcknowledgedTime": {
            "description": "the time this alarm was last acknowledged.",
            "type": "string"
          },
          "lastChanged": {
            "description": "The last time that the alarm was changed; as provided by the raiser of the alarm.",
            "type": "string"
          },
          "lastSuppressed": {
            "description": "the time this alarm was last suppressed. Use lastSuppressedTime instead.\nDeprecated: true",
            "type": "string",
            "deprecated": true
          },
          "lastSuppressedBy": {
            "description": "the user who last suppressed the alarm",
            "type": "string"
          },
          "lastSuppressedTime": {
            "description": "the time this alarm was last suppressed.",
            "type": "string"
          },
          "name": {
            "description": "The unique name for the alarm, e.g. InterfaceDown-spine-1-1-ethernet-1-1.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the alarm",
            "type": "string"
          },
          "occurrences": {
            "description": "The number of occurrences of this alarm (the number of times it has been raised).",
            "format": "int64",
            "type": "integer"
          },
          "parentAlarms": {
            "description": "The names of other alarms that are parents of this alarm. This may be used to\nfilter out alarms that are not a root cause.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "probableCause": {
            "description": "the probable cause for raising the alarm. This field is optional, and\nshould also be a description indicating the primary probable cause of the\nalarm, which may be enriched with relevant information from this specific\nalarm instance. The complete alarm below contains an example.",
            "type": "string"
          },
          "remedialAction": {
            "description": "any remedial actions the user could try to resolve/clear the alarm. This\nfield is optional, and may also be enriched with relevant information\nfrom this specific alarm instance. The complete alarm below contains an\nexample.",
            "type": "string"
          },
          "resource": {
            "description": "The name of the resource that this alarm is present on.",
            "type": "string"
          },
          "severity": {
            "description": "Severity of the alarm",
            "enum": [
              "warning",
              "minor",
              "major",
              "critical"
            ],
            "type": "string"
          },
          "sourceGroup": {
            "description": "Indicates indicates the group of the resource that raised this alarm, e.g. interfaces.eda.nokia.com.",
            "type": "string"
          },
          "sourceKind": {
            "description": "Indicates the Kind of the resource that raised this alarm, e.g. InterfaceState.",
            "type": "string"
          },
          "sourceResource": {
            "description": "Indicates the the name of the resource that raised this alarm, e.g. spine-1-1-ethernet-1-1.",
            "type": "string"
          },
          "suppressed": {
            "description": "An indication if the alarm has been suppressed.",
            "type": "boolean"
          },
          "suppressedUntil": {
            "description": "Indicates the end time of the suppression.",
            "type": "string"
          },
          "targetsAffected": {
            "description": "List of nodes affected by this alarm.",
            "items": {
              "$ref": "#/components/schemas/AlarmTarget"
            },
            "type": "array"
          },
          "type": {
            "description": "A kind for the alarm, e.g. InterfaceDown",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AlarmHistoryData": {
        "properties": {
          "acknowledged": {
            "description": "An indication if the alarm has been acknowledged.",
            "type": "boolean"
          },
          "acknowledgedBy": {
            "description": "the user who acknowledged the alarm for this alarm history entry",
            "type": "string"
          },
          "additionalText": {
            "description": "adds extra context related to the alarm",
            "type": "string"
          },
          "cleared": {
            "description": "An indication if the alarm has been cleared.",
            "type": "boolean"
          },
          "lastChanged": {
            "description": "The last time that the alarm was changed; as provided by the raiser of the alarm.",
            "type": "string"
          },
          "name": {
            "description": "The unique name for the alarm, e.g. InterfaceDown-spine-1-1-ethernet-1-1.",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the alarm",
            "type": "string"
          },
          "probableCause": {
            "description": "the probable cause for raising the alarm. This field is optional, and\nshould also be a description indicating the primary probable cause of the\nalarm, which may be enriched with relevant information from this specific\nalarm instance. The complete alarm below contains an example.",
            "type": "string"
          },
          "remedialAction": {
            "description": "any remedial actions the user could try to resolve/clear the alarm. This\nfield is optional, and may also be enriched with relevant information\nfrom this specific alarm instance. The complete alarm below contains an\nexample.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AlarmHistoryEntry": {
        "properties": {
          "alarm": {
            "$ref": "#/components/schemas/AlarmHistoryData"
          },
          "index": {
            "description": "The index of the history entry within the entries for a single alarm..",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AlarmNamespaceAndName": {
        "properties": {
          "name": {
            "description": "The name of an alarm",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of an alarm",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AlarmTarget": {
        "properties": {
          "name": {
            "description": "Name of the target node.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AuthPasswordPolicy": {
        "properties": {
          "allowUserName": {
            "description": "If true, prevents passwords from being or containing the user name.",
            "type": "boolean"
          },
          "digits": {
            "description": "Minimum number of digits required in a password. Can be zero.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "forceExpiredPasswordChange": {
            "description": "The maximum number of days until a password change is enforced.\nA value of zero means no change is required.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "hashingAlgorithm": {
            "description": "The hashing algorithm to use when hashing stored passwords.",
            "enum": [
              "argon2",
              "pbkdf2-sha512",
              "pbkdf2-sha256",
              "pbkdf2"
            ],
            "type": "string"
          },
          "length": {
            "description": "Minimum password length.  This must be at least 1.",
            "format": "int64",
            "minimum": 1,
            "type": "integer"
          },
          "lowerCase": {
            "description": "Minimum number of lower case characters required in a password. Can be zero.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "maxFailureWaitSeconds": {
            "description": "The number of seconds before the users access will be restored, after too many authentication failures.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "maxLoginFailure": {
            "description": "The number of login/authentication failures before a lockout policy takes effect. Zero means no enforcement.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "passwordHistory": {
            "description": "The number of passwords remembered to enforce no re-use of passwords. Zero means no re-use enforcement.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "permanentLockout": {
            "description": "If true, lockout is permanent and the users access must be re-enabled by an administrator.\nIf false, the users access will be re-enabled after \"maxFailureWaitSeconds\" seconds.",
            "type": "boolean"
          },
          "resetTimeSeconds": {
            "description": "When lockout is not permanent, the count of authentication failures for a user will be reset\nthis many seconds after the last authentication failure.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "specialChars": {
            "description": "Minimum number of special characters required in a password. Can be zero.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "upperCase": {
            "description": "Minimum number of upper case characters required in a password. Can be zero.",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "AuthProvider": {
        "properties": {
          "auth": {
            "$ref": "#/components/schemas/AuthProvider_auth"
          },
          "enabled": {
            "description": "If true, checking/syncing this LDAP provider is enabled.",
            "type": "boolean",
            "x-eda-nokia-com": {
              "ui-column-span": 2,
              "ui-order-priority": 30,
              "ui-title": "Enabled",
              "ui-title-key": "enabled"
            }
          },
          "groupSupport": {
            "$ref": "#/components/schemas/AuthProvider_groupSupport"
          },
          "idAttribute": {
            "description": "Name of the LDAP attribute, which is used as a unique object identifier (UUID) for objects in LDAP.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 120,
              "ui-title": "ID Attribute",
              "ui-title-key": "uuid_ldap_attribute"
            }
          },
          "import": {
            "description": "If true, the LDAP information will be imported into the EDA (Keycloak) database.",
            "type": "boolean",
            "x-eda-nokia-com": {
              "ui-column-span": 2,
              "ui-order-priority": 30,
              "ui-title": "Import Users",
              "ui-title-key": "import_users"
            }
          },
          "name": {
            "description": "The name to give to the LDAP provider; must be unique.",
            "type": "string",
            "x-eda-nokia-com": {
              "immutable": true,
              "ui-order-priority": 10,
              "ui-title": "Name",
              "ui-title-key": "name"
            }
          },
          "pagination": {
            "description": "Set to true if the LDAP server supports pagination.",
            "type": "boolean",
            "x-eda-nokia-com": {
              "ui-column-span": 2,
              "ui-order-priority": 160,
              "ui-title": "Pagination",
              "ui-title-key": "pagination"
            }
          },
          "periodicSync": {
            "description": "If true, periodic synchronization of new changed or newly created LDAP users to Keycloak will occur.",
            "type": "boolean",
            "x-eda-nokia-com": {
              "ui-column-span": 2,
              "ui-order-priority": 170,
              "ui-single-line-group": "periodic_sync",
              "ui-title": "Periodic Sync",
              "ui-title-key": "periodic_sync"
            }
          },
          "periodicSyncSecs": {
            "description": "If periodic sync is enabled, this is the period in seconds that synchronization will occur.",
            "format": "int64",
            "type": "integer",
            "x-eda-nokia-com": {
              "ui-column-span": 2,
              "ui-order-priority": 180,
              "ui-single-line-group": "periodic_sync",
              "ui-title": "Periodic Sync Time",
              "ui-title-key": "periodic_sync_time",
              "ui-visible-if": "periodicSync === true"
            }
          },
          "rdnLDAPAttribute": {
            "description": "Name of the LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as the Username LDAP attribute, however it is not required.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 110,
              "ui-title": "RDN LDAP Attribute",
              "ui-title-key": "rdn_ldap_attribute"
            }
          },
          "readOnly": {
            "default": true,
            "description": "If false, changes made to LDAP-mapped attribute via EDA will be synced back to the LDAP server.  Otherwise, changes are not made in LDAP.",
            "type": "boolean",
            "x-eda-nokia-com": {
              "ui-column-span": 2,
              "ui-order-priority": 190,
              "ui-title": "Read Only",
              "ui-title-key": "read_only"
            }
          },
          "scope": {
            "description": "Must be \"One Level\" or \"Subtree\".  If \"One Level\", the search applies only for users in the DNs specified by User DNs. If \"Subtree\", the search applies to the whole subtree.",
            "enum": [
              "One Level",
              "Subtree"
            ],
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 150,
              "ui-title": "Scope",
              "ui-title-key": "searchScope"
            }
          },
          "timeout": {
            "description": "LDAP connection timeout in milliseconds",
            "format": "int64",
            "type": "integer",
            "x-eda-nokia-com": {
              "ui-column-span": 2,
              "ui-order-priority": 100,
              "ui-title": "Timeout",
              "ui-title-key": "timeout"
            }
          },
          "tls": {
            "description": "If true, encrypts the connection to LDAP using STARTTLS",
            "type": "boolean",
            "x-eda-nokia-com": {
              "ui-column-span": 2,
              "ui-order-priority": 50,
              "ui-title": "Use TLS",
              "ui-title-key": "use_tls"
            }
          },
          "type": {
            "description": "The type of provider.  Currently only \"ldap\" is supported.",
            "enum": [
              "ldap"
            ],
            "type": "string",
            "x-eda-nokia-com": {
              "ui-column-span": 2,
              "ui-order-priority": 60,
              "ui-title": "Bind Type",
              "ui-title-key": "bind_type"
            }
          },
          "url": {
            "description": "Connection URL to your LDAP server",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 40,
              "ui-title": "Connection URL",
              "ui-title-key": "connection_url"
            }
          },
          "userDN": {
            "description": "Full DN of LDAP tree where your users are. This DN is the parent of LDAP users.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 80,
              "ui-title": "User DN",
              "ui-title-key": "user_dn"
            }
          },
          "userObjectClasses": {
            "description": "All values of LDAP objectClass attribute for users in LDAP, divided by commas. (e.g. inetOrgPerson, organizationalPerson).",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 130,
              "ui-title": "User Object Classes",
              "ui-title-key": "user_object_classes"
            }
          },
          "userSearchFilter": {
            "description": "Additional LDAP filter for filtering searched users. Leave this empty if you don't need an additional filter. Make sure that it starts with '(' and ends with ')'.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 140,
              "ui-title": "User Search Filter",
              "ui-title-key": "user_search_filter"
            }
          },
          "usernameAttribute": {
            "description": "Name of the LDAP attribute, which is mapped as EDA username. For many LDAP server vendors it can be 'uid'.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-internal-feature": [
                "testConnection"
              ],
              "ui-order-priority": 90,
              "ui-title": "Username LDAP Attribute",
              "ui-title-key": "username_ldap_attribute"
            }
          },
          "uuid": {
            "description": "The unique identifier given to the entry when it is created.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-visible-if": "false"
            }
          },
          "vendor": {
            "description": "LDAP vendor (provider).",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 20,
              "ui-title": "Vendor",
              "ui-title-key": "vendor"
            }
          }
        },
        "required": [
          "idAttribute",
          "name",
          "rdnLDAPAttribute",
          "readOnly",
          "type",
          "url",
          "userDN",
          "userObjectClasses",
          "usernameAttribute",
          "vendor"
        ],
        "type": "object"
      },
      "AuthProviderTestParams": {
        "properties": {
          "action": {
            "description": "The test action to take.",
            "enum": [
              "connection",
              "authentication"
            ],
            "type": "string"
          },
          "auth": {
            "$ref": "#/components/schemas/ProviderAuth"
          },
          "name": {
            "description": "The name of the provider to test",
            "type": "string"
          },
          "timeout": {
            "description": "LDAP connection timeout in milliseconds",
            "format": "int64",
            "type": "integer"
          },
          "tls": {
            "description": "If true, encrypts the connection to LDAP using STARTTLS",
            "type": "boolean"
          },
          "url": {
            "description": "Connection URL to your LDAP server",
            "type": "string"
          }
        },
        "required": [
          "action",
          "url"
        ],
        "type": "object"
      },
      "AuthProviders": {
        "items": {
          "$ref": "#/components/schemas/AuthProvider"
        },
        "type": "array"
      },
      "AuthRole": {
        "properties": {
          "description": {
            "type": "string"
          },
          "name": {
            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
            "type": "string",
            "x-eda-nokia-com": {
              "immutable": true
            }
          },
          "namespace": {
            "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?)?$",
            "type": "string",
            "x-eda-nokia-com": {
              "immutable": true
            }
          },
          "resourceRules": {
            "description": "Rules for access to resources.",
            "items": {
              "$ref": "#/components/schemas/ResourceRule"
            },
            "type": "array"
          },
          "tableRules": {
            "description": "Rules for access to EDB tables, including via EQL.",
            "items": {
              "$ref": "#/components/schemas/TableRule"
            },
            "type": "array"
          },
          "urlRules": {
            "description": "Rules for access to APIServer routes.",
            "items": {
              "$ref": "#/components/schemas/UrlRule"
            },
            "type": "array"
          }
        },
        "required": [
          "description",
          "name"
        ],
        "type": "object"
      },
      "AuthRoles": {
        "items": {
          "$ref": "#/components/schemas/AuthRole"
        },
        "type": "array"
      },
      "AuthUser": {
        "properties": {
          "email": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "firstName": {
            "type": "string"
          },
          "groups": {
            "description": "contains the UUIDs of the groups of which the user is a member.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "lastName": {
            "type": "string"
          },
          "maxSessions": {
            "format": "int64",
            "type": "integer"
          },
          "password": {
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/UserStatus"
          },
          "username": {
            "type": "string"
          },
          "uuid": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "AuthUserGroup": {
        "properties": {
          "description": {
            "type": "string"
          },
          "full-users": {
            "description": "contains the full user definitions of the users who are members of the group, if requested",
            "items": {
              "$ref": "#/components/schemas/AuthUser"
            },
            "type": "array"
          },
          "fullRoles": {
            "description": "contains the full role definitions of the Roles and ClusterRoles associated with the group, if requested",
            "items": {
              "$ref": "#/components/schemas/AuthRole"
            },
            "type": "array"
          },
          "isFederated": {
            "description": "if true, indicates that the group was imported from a federated LDAP server",
            "type": "boolean"
          },
          "name": {
            "type": "string"
          },
          "roles": {
            "description": "Contains the names of the ClusterRoles and Roles roles associated with the group.\nA Role name has the form \"namesspace:rolename\", whereas a ClusteRole name is a\nsimple \"rolename\", without a colon or a namespace.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "users": {
            "description": "contains the usernames of the users who are members of the group",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "uuid": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "AuthUserGroups": {
        "items": {
          "$ref": "#/components/schemas/AuthUserGroup"
        },
        "type": "array"
      },
      "AuthUsers": {
        "items": {
          "$ref": "#/components/schemas/AuthUser"
        },
        "type": "array"
      },
      "AutoCompleteDetails": {
        "properties": {
          "condition": {
            "description": "Accepted and ignored.",
            "type": "string"
          },
          "group": {
            "description": "The group name for a resource.\nValid with gvk, gvr, or label selector autocomplete only.",
            "type": "string"
          },
          "kind": {
            "description": "The kind of the resource.\nValid with gvk or label selector autocomplete only.",
            "type": "string"
          },
          "query": {
            "description": "The query input.\nValid with query type autocomplete only.",
            "type": "string"
          },
          "resource": {
            "description": "A resource name.\nValid with gvr autocomplete only.",
            "type": "string"
          },
          "subject": {
            "description": "Accepted and ignored.",
            "type": "boolean"
          },
          "table": {
            "description": "The table name.\nValid with where or fields autocomplete only.",
            "type": "string"
          },
          "table-expression": {
            "description": "The table expression.\nAccepted and ignored.",
            "type": "string"
          },
          "table-prefix": {
            "description": "The table name as prefix.\nValid with table autocomplete only.",
            "type": "string"
          },
          "table-prefix-expression": {
            "description": "The table prefix expression.\nAccepted and ignored.",
            "type": "string"
          },
          "type": {
            "description": "The type of autocompletion request.",
            "enum": [
              "query",
              "gvk",
              "gvr",
              "label",
              "table",
              "where",
              "fields",
              "labelselector"
            ],
            "type": "string"
          },
          "version": {
            "description": "A resource version.\nValid with gvk, gvr, or label selector autocomplete only.",
            "type": "string"
          }
        },
        "required": [
          "type"
        ],
        "type": "object"
      },
      "AutoCompleteRequest": {
        "properties": {
          "details": {
            "$ref": "#/components/schemas/AutoCompleteDetails"
          },
          "limit": {
            "description": "The maximum number of results to return",
            "format": "uint32",
            "type": "integer"
          },
          "namespace": {
            "description": "The namespace in which to search for completions",
            "type": "string"
          },
          "value": {
            "description": "A user input to be autocompleted",
            "type": "string"
          }
        },
        "required": [
          "details",
          "value"
        ],
        "title": "The information which must be POSTed with an auto-complete request to guide the auto-complete process.",
        "type": "object"
      },
      "AutoCompleteResponse": {
        "description": "The result of an auto-completion request",
        "properties": {
          "action": {
            "default": "append",
            "description": "The action to take with the \"completion\" field of each completion.\nOnly relevant/present if no \"error\" is present.",
            "enum": [
              "append",
              "replace"
            ],
            "type": "string"
          },
          "completions": {
            "description": "A list of possible auto-complete results. Only one of \"error\" or \"completions\" will be present.",
            "items": {
              "$ref": "#/components/schemas/AutoCompletion"
            },
            "type": "array"
          },
          "error": {
            "$ref": "#/components/schemas/ErrorResponse"
          }
        },
        "type": "object"
      },
      "AutoCompletion": {
        "properties": {
          "completion": {
            "description": "The completion result.  Depending on the \"action\" field in the enclosing response, should either be appended-to, or replace the input if the user selects this completion.",
            "type": "string"
          },
          "token": {
            "description": "Intended to be displayed to the user as to indicate the result of this completion.",
            "type": "string"
          }
        },
        "required": [
          "completion",
          "token"
        ],
        "type": "object"
      },
      "ChatResponseType": {
        "format": "uint32",
        "type": "integer"
      },
      "CheckAccessRequest": {
        "additionalProperties": {
          "$ref": "#/components/schemas/AccessQuery"
        },
        "description": "Body of a checkAccess request. Contains a key and AccessQuery for each resource/url/table to be checked for user access",
        "type": "object"
      },
      "CheckAccessResponse": {
        "additionalProperties": {
          "$ref": "#/components/schemas/AccessResult"
        },
        "description": "Body of a access check response. Contains an AccessResult for each of the keys provided in the request",
        "type": "object"
      },
      "ConversationHistory": {
        "properties": {
          "created": {
            "description": "Time when the conversation was created",
            "format": "date-time",
            "type": "string"
          },
          "id": {
            "description": "Conversation ID",
            "type": "string"
          },
          "lastUpdated": {
            "description": "Time when the conversation was last updated",
            "format": "date-time",
            "type": "string"
          },
          "messageCount": {
            "description": "Number of messages in the conversation",
            "format": "int32",
            "type": "integer"
          },
          "messages": {
            "description": "List of messages in the conversation",
            "items": {
              "$ref": "#/components/schemas/ConversationHistoryMessage"
            },
            "type": "array"
          },
          "name": {
            "description": "Conversation name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ConversationHistoryMessage": {
        "properties": {
          "role": {
            "$ref": "#/components/schemas/ConversationHistoryRole"
          },
          "type": {
            "$ref": "#/components/schemas/ChatResponseType"
          },
          "value": {
            "description": "The content of the message returned from ai",
            "type": "object"
          }
        },
        "type": "object"
      },
      "ConversationHistoryRole": {
        "type": "string"
      },
      "ConversationInfo": {
        "properties": {
          "created": {
            "description": "Time when the conversation was created",
            "format": "date-time",
            "type": "string"
          },
          "id": {
            "description": "Conversation ID",
            "type": "string"
          },
          "lastUpdated": {
            "description": "Time when the conversation was last updated",
            "format": "date-time",
            "type": "string"
          },
          "messageCount": {
            "description": "Number of messages in the conversation",
            "format": "int32",
            "type": "integer"
          },
          "name": {
            "description": "Conversation name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ConversationList": {
        "items": {
          "$ref": "#/components/schemas/ConversationInfo"
        },
        "type": "array"
      },
      "CrAnnotation": {
        "properties": {
          "cr": {
            "$ref": "#/components/schemas/NsCrGvkName"
          },
          "lines": {
            "items": {
              "$ref": "#/components/schemas/LineSegment"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Credentials": {
        "properties": {
          "temporary": {
            "description": "This is true if the password being set is a temporary password.  In this case the user\nis required to change the password after they login using the temporary password.",
            "type": "boolean"
          },
          "value": {
            "description": "The new password for the user.",
            "type": "string"
          }
        },
        "title": "Credentials (password) for a user. This can never be retrieved from the system.",
        "type": "object"
      },
      "ErrorIndex": {
        "properties": {
          "index": {
            "format": "int64",
            "type": "integer"
          }
        },
        "title": "Wrapper for index information inside an error.",
        "type": "object"
      },
      "ErrorItem": {
        "properties": {
          "error": {
            "type": "object"
          },
          "type": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "ErrorResponse": {
        "properties": {
          "causeCollection": {
            "description": "A lower-level set of structured errors.\n\nOnly oneOf `causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection` will ever be set.",
            "items": {
              "$ref": "#/components/schemas/ErrorResponse"
            },
            "type": "array"
          },
          "causeIndexedCollection": {
            "description": "A lower-level set of structured errors.\nEach of these errors MUST have index set.\n\nOnly oneOf `causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection` will ever be set.",
            "items": {
              "$ref": "#/components/schemas/ErrorResponse"
            },
            "type": "array"
          },
          "causeIsInternal": {
            "description": "If true, then the cause (`causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection`) should be hidden from the user.",
            "type": "boolean"
          },
          "causeSimple": {
            "description": "Simple string error type.\n\nOnly oneOf `causeWrapped`, `causeSimple`, `causeCollection`, or `causeIndexedCollection` will ever be set.",
            "type": "string"
          },
          "causeWrapped": {
            "$ref": "#/components/schemas/ErrorResponse"
          },
          "code": {
            "description": "the numeric HTTP error code for the response.\n\nDeprecated: Prefer to check the request's HTTP response code directly.",
            "format": "int64",
            "type": "integer",
            "deprecated": true
          },
          "details": {
            "description": "The optional details of the error response.\nDeprecated: Replaced by `causeSimple`.",
            "type": "string",
            "deprecated": true
          },
          "dictionary": {
            "additionalProperties": true,
            "description": "Dictionary/map of associated data/information relevant to the error.\nThe error \"message\" may contain {{name}} escapes that should be substituted\nwith information from this dictionary.\n\nDeprecated: Use \"values\" instead.",
            "type": "object",
            "deprecated": true
          },
          "domain": {
            "description": "The \"domain\" for the error.  If empty, it is an EDA\ncore error.  Alternatively it can be an EDA application\n\"apiVersion\" value (e.g. interfaces.eda.nokia.com/v1alpha1)\nindicating that the error is specific to that application.\nThe domain gives the receiver information that they can use\nto help them interpret the \"type\" field.",
            "type": "string"
          },
          "errors": {
            "description": "Collection of errors in cases where more than one exists.\nThis needs to be flexible so we can support multiple formats.\nDeprecated: Replaced by `causeCollection` or `causeIndexedCollection` instead.",
            "items": {
              "$ref": "#/components/schemas/ErrorItem"
            },
            "type": "array",
            "deprecated": true
          },
          "index": {
            "$ref": "#/components/schemas/ErrorIndex"
          },
          "internal": {
            "description": "Internal error code number.\n\nDeprecated: \"type\" & \"domain\" should be used instead to uniquely identify this error.",
            "format": "int64",
            "type": "integer",
            "deprecated": true
          },
          "message": {
            "description": "The basic text error message for the error response.",
            "type": "string"
          },
          "ref": {
            "description": "Reference to the error source. Should typically be the URI of the request.",
            "type": "string"
          },
          "type": {
            "description": "Type defines a unique identifier for the error, within the domain.\nThis may be used (along with the domain) to find an internationalization translation for the message.\n\nSHOULD be a valid golang identifier, and SHOULD be in UpperCamelCase.",
            "type": "string"
          },
          "values": {
            "additionalProperties": {
              "type": "object"
            },
            "description": "Associated data/information.\nThe error \"message\" may contain {{name}} escapes that should be substituted with information from this dictionary.\n\nNote that this map MUST NOT contain JSON objects (`{...}`) or arrays (`[...]`), only simple JSON types are permitted.",
            "type": "object"
          }
        },
        "required": [
          "internal",
          "message",
          "type"
        ],
        "title": "Generic error response for REST APIs.",
        "type": "object"
      },
      "GetLabelCompletionRequest": {
        "properties": {
          "gvk": {
            "$ref": "#/components/schemas/GroupVersionKind"
          },
          "limit": {
            "description": "The maximum number of results to return",
            "format": "uint32",
            "type": "integer"
          },
          "namespace": {
            "description": "The namespace of the GVK if the CRD is namespaced\nrequired: true if the GVK is namespaced",
            "type": "string"
          },
          "value": {
            "description": "A key value string delimited by =.  If the Value does not include an =\nit is assumed to be a Key lookup.  If there is an =, everything before\nthe = is assumed to be the key and the lookup will be a value lookup",
            "type": "string"
          }
        },
        "required": [
          "value"
        ],
        "type": "object"
      },
      "GroupID": {
        "description": "The UUID of an EDA user group",
        "type": "string"
      },
      "GroupIDs": {
        "items": {
          "$ref": "#/components/schemas/GroupID"
        },
        "title": "A list of user group identifiers (uuid values).",
        "type": "array"
      },
      "GroupVersionKind": {
        "properties": {
          "group": {
            "description": "Name of the API group",
            "type": "string"
          },
          "kind": {
            "description": "The Kind of the resource",
            "type": "string"
          },
          "version": {
            "description": "Version of the API group",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GroupVersionResource": {
        "properties": {
          "group": {
            "description": "Name of the API group",
            "type": "string"
          },
          "resource": {
            "description": "The plural name of the resource",
            "type": "string"
          },
          "version": {
            "description": "Version of the API group",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Health": {
        "properties": {
          "mode": {
            "description": "Indication of the activity of this cluster.",
            "enum": [
              "ACTIVE",
              "STANDBY"
            ],
            "type": "string"
          },
          "services": {
            "additionalProperties": {
              "$ref": "#/components/schemas/HealthServiceStatus"
            },
            "description": "Detailed health of the services comprising the EDA cluster.  Keyed by the name of the service.",
            "type": "object"
          },
          "status": {
            "description": "Overall health status of the EDA cluster.",
            "enum": [
              "UP",
              "DEGRADED",
              "DOWN"
            ],
            "type": "string"
          },
          "timestamp": {
            "description": "Time that the health report was generated.",
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "mode",
          "status",
          "timestamp"
        ],
        "title": "Structure containing a health report for the EDA cluster.",
        "type": "object"
      },
      "HealthServiceStatus": {
        "properties": {
          "error": {
            "description": "Detailed status if the service is not up.",
            "type": "string"
          },
          "status": {
            "description": "Health status of the given service.  UP or DOWN.",
            "enum": [
              "UP",
              "DOWN"
            ],
            "type": "string"
          }
        },
        "required": [
          "status"
        ],
        "title": "Structure containing a health report for a particular service.",
        "type": "object"
      },
      "Identifier": {
        "properties": {
          "group": {
            "type": "string"
          },
          "id": {
            "format": "int64",
            "type": "integer"
          },
          "kind": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "namespace": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "K8SPatchOp": {
        "description": "The definition for a JSON patch for a resource, as in RFC 6902",
        "properties": {
          "from": {
            "description": "Only applies to a \"move\" operation, and is the path to the field/value within\nthe target JSON object that should be moved to the location specified by the \"path\"\nfield.",
            "example": "/a/b/c",
            "type": "string"
          },
          "op": {
            "description": "The type of operation this patch should perform.",
            "enum": [
              "add",
              "remove",
              "replace",
              "move",
              "copy",
              "test"
            ],
            "example": "replace",
            "type": "string"
          },
          "path": {
            "description": "The path to the field within the target JSON object\nthat should be patched according to the \"op\" field.",
            "example": "/a/b/d",
            "type": "string"
          },
          "value": {
            "description": "This field would be set to the value which the user intends to put in the\nfield referenced by the \"path\" field.  The type of the value should match\nthe type of the field as indicated by the schema of the resource being\npatched.",
            "example": "example for a string field",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              },
              {
                "type": "array",
                "items": {}
              },
              {
                "type": "object"
              }
            ]
          },
          "x-permissive": {
            "description": "For an \"add\" operation, an already-present field referenced by the \"path\" will\nresult in an error unless this field is true.  Similarly for a non-existent\ntarget field of a \"remove\" operation.",
            "type": "boolean"
          }
        },
        "required": [
          "op",
          "path"
        ],
        "type": "object"
      },
      "LabelCompletionResponse": {
        "properties": {
          "results": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "LineSegment": {
        "properties": {
          "endLine": {
            "format": "uint32",
            "type": "integer"
          },
          "startLine": {
            "format": "uint32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Metadata": {
        "properties": {
          "annotations": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-eda-nokia-com": {
              "ui-order-priority": 40,
              "ui-title": "Annotations",
              "ui-title-key": "annotations"
            }
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-eda-nokia-com": {
              "ui-auto-completes": [
                {
                  "condition": "true",
                  "group": "GROUP",
                  "kind": "KIND",
                  "type": "label",
                  "version": "VERSION"
                }
              ],
              "ui-order-priority": 30,
              "ui-title": "Labels",
              "ui-title-key": "labels"
            }
          },
          "name": {
            "maxLength": 253,
            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
            "type": "string",
            "x-eda-nokia-com": {
              "immutable": true,
              "ui-order-priority": 10,
              "ui-pattern-error": "A valid name is made up of one or more components where each component is separated by period characters.  Each component must start and end with a lower case alphanumeric character and the body of the component is made up of zero or more lower case alphanumeric and hyphen characters.",
              "ui-title": "Name",
              "ui-title-key": "name"
            }
          },
          "namespace": {
            "type": "string",
            "x-eda-nokia-com": {
              "immutable": true,
              "ui-order-priority": 20,
              "ui-title": "Namespace",
              "ui-title-key": "namespace"
            }
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "NamespaceData": {
        "description": "Information about an individual namespace",
        "properties": {
          "description": {
            "description": "The description of the namespace",
            "type": "string"
          },
          "name": {
            "description": "The namespace name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "NamespaceGetResponse": {
        "description": "Body of the non streaming namespace get request",
        "properties": {
          "allNamesapces": {
            "description": "If true, the requestor is considered to have permission to access all namespaces",
            "type": "boolean"
          },
          "namespaces": {
            "description": "The list of namespaces",
            "items": {
              "$ref": "#/components/schemas/NamespaceData"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "NodeConfigResponse": {
        "properties": {
          "annotations": {
            "description": "The the list of annotations for the node configuration",
            "items": {
              "$ref": "#/components/schemas/CrAnnotation"
            },
            "type": "array"
          },
          "running": {
            "description": "The current node configuration for the node",
            "type": "string"
          }
        },
        "type": "object"
      },
      "NsCrGvkName": {
        "properties": {
          "gvk": {
            "$ref": "#/components/schemas/GroupVersionKind"
          },
          "name": {
            "type": "string"
          },
          "namespace": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "OperationType": {
        "type": "string"
      },
      "Overlay": {
        "properties": {
          "endpoint_attr_queries": {
            "items": {
              "$ref": "#/components/schemas/TopoOverlayAttrQuery"
            },
            "type": "array"
          },
          "endpoint_state": {
            "items": {
              "$ref": "#/components/schemas/TopoOverlayStateMetadata"
            },
            "type": "array"
          },
          "endpoint_state_heading": {
            "type": "string"
          },
          "endpoint_state_heading_key": {
            "type": "string"
          },
          "group": {
            "type": "string"
          },
          "link_attr_queries": {
            "items": {
              "$ref": "#/components/schemas/TopoOverlayAttrQuery"
            },
            "type": "array"
          },
          "link_state": {
            "items": {
              "$ref": "#/components/schemas/TopoOverlayStateMetadata"
            },
            "type": "array"
          },
          "link_state_heading": {
            "type": "string"
          },
          "link_state_heading_key": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "node_attr_queries": {
            "items": {
              "$ref": "#/components/schemas/TopoOverlayAttrQuery"
            },
            "type": "array"
          },
          "node_badge": {
            "items": {
              "$ref": "#/components/schemas/TopoOverlayBadgeMetadata"
            },
            "type": "array"
          },
          "node_state": {
            "items": {
              "$ref": "#/components/schemas/TopoOverlayStateMetadata"
            },
            "type": "array"
          },
          "node_state_heading": {
            "type": "string"
          },
          "node_state_heading_key": {
            "type": "string"
          },
          "ui_description": {
            "type": "string"
          },
          "ui_description_key": {
            "type": "string"
          },
          "ui_name": {
            "type": "string"
          },
          "ui_name_key": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "OverlayState": {
        "properties": {
          "link_groups": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoOverlayLinkGroup"
            },
            "type": "object"
          },
          "links": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoOverlayLink"
            },
            "type": "object"
          },
          "nodes": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoOverlayNode"
            },
            "type": "object"
          },
          "nodes_and_groups": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoOverlayNodeOrGroup"
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "Overlays": {
        "items": {
          "$ref": "#/components/schemas/Overlay"
        },
        "type": "array"
      },
      "Patch": {
        "items": {
          "$ref": "#/components/schemas/K8SPatchOp"
        },
        "type": "array"
      },
      "ProviderAuth": {
        "properties": {
          "bindCredential": {
            "description": "Credentials to use when binding to an LDAP provider",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-internal-feature": [
                "testAuthentication"
              ],
              "ui-order-priority": 20,
              "ui-title": "Bind Credential",
              "ui-title-key": "bind_credential"
            }
          },
          "bindDN": {
            "description": "DN to use when binding to an LDAP provider",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 10,
              "ui-title": "Bind DN",
              "ui-title-key": "bind_dn"
            }
          }
        },
        "required": [
          "bindCredential",
          "bindDN"
        ],
        "type": "object"
      },
      "QueryCompletion": {
        "properties": {
          "completion": {
            "type": "string"
          },
          "token": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryCompletionResponse": {
        "description": "The result of a successful query auto-completion request",
        "properties": {
          "completions": {
            "description": "Array of possible auto-completion results.",
            "items": {
              "$ref": "#/components/schemas/QueryCompletion"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "QueryConvertRequest": {
        "properties": {
          "jsPath": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryConvertResponse": {
        "properties": {
          "query": {
            "type": "string"
          },
          "table": {
            "type": "string"
          },
          "whereClause": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryResponse": {
        "description": "The response for a non-streaming query request",
        "properties": {
          "data": {
            "items": {
              "type": "object"
            },
            "type": "array"
          },
          "jsonSchema": {
            "description": "The JSON schema definition for the query data being returned.",
            "properties": {},
            "type": "object"
          }
        },
        "type": "object"
      },
      "ResourceRule": {
        "properties": {
          "apiGroups": {
            "description": "The API groups for the resources controlled by the rule.\nAn API group consists of an apiGroup and a version, e.g. \"apigroup/version\".\nThe API group can be a wildcard (\"*\"), in which case it will match any API group.\nIn addition, the version can be a wildcard.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "permissions": {
            "description": "Permissions for resources specified by the rule.",
            "enum": [
              "none",
              "read",
              "readWrite"
            ],
            "type": "string"
          },
          "resources": {
            "description": "Names for the resources controlled by the rule.\nIt can be a wildcard (\"*\"), in which case it will match any resource\nin the matching API groups.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "apiGroups",
          "resources"
        ],
        "title": "A role rule controlling access to a kubernetes resource.",
        "type": "object"
      },
      "StoreAppInstalledSettings": {
        "properties": {
          "appId": {
            "description": "The application identifier.",
            "type": "string"
          },
          "settings": {
            "additionalProperties": {
              "type": "object"
            },
            "description": "The settings for the application as a JSON object.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "StoreAppManifest": {
        "properties": {
          "manifest": {
            "additionalProperties": {
              "type": "object"
            },
            "description": "The application manifest as JSON",
            "type": "object"
          },
          "metadata": {
            "$ref": "#/components/schemas/StoreAppVersionMetadata"
          },
          "version": {
            "$ref": "#/components/schemas/StoreAppVersion"
          }
        },
        "type": "object"
      },
      "StoreAppRequirementsGraph": {
        "properties": {
          "graphItems": {
            "description": "The items in the requirements graph resulting from the request.  Only present if the state is FINISHED.",
            "items": {
              "$ref": "#/components/schemas/StoreAppRequirementsGraphItem"
            },
            "type": "array"
          },
          "state": {
            "description": "The state of the requirements graph generation request.",
            "enum": [
              "UNKNOWN",
              "RUNNING",
              "FINISHED",
              "FAILED"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "StoreAppRequirementsGraphItem": {
        "properties": {
          "appId": {
            "description": "The application identifier to which the 'requires' elements of graph items will refer.",
            "type": "string"
          },
          "installedAppVersion": {
            "$ref": "#/components/schemas/StoreAppRequirementsGraphItem_installedAppVersion"
          },
          "requires": {
            "description": "The identifiers for the applications on which this application version depends.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "targetAppVersion": {
            "$ref": "#/components/schemas/StoreAppRequirementsGraphItem_targetAppVersion"
          }
        },
        "required": [
          "appId",
          "targetAppVersion"
        ],
        "type": "object"
      },
      "StoreAppSettingsDefinition": {
        "properties": {
          "appId": {
            "description": "The application identifier",
            "type": "string"
          },
          "definition": {
            "additionalProperties": {
              "type": "object"
            },
            "description": "The settings definition for the application as a JSON object.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "StoreAppSummary": {
        "properties": {
          "appId": {
            "description": "Unique ID identifying this application",
            "type": "string"
          },
          "catalogs": {
            "description": "Catalogs where this app was found",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "categories": {
            "description": "Application categories.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "description": {
            "description": "Application description that can be used for user display purposes",
            "type": "string"
          },
          "hasSettings": {
            "description": "Application has settings",
            "type": "boolean"
          },
          "infoVersion": {
            "$ref": "#/components/schemas/StoreAppVersion"
          },
          "infoVersionMetadata": {
            "$ref": "#/components/schemas/StoreAppVersionMetadata"
          },
          "installed": {
            "description": "\"true\" if the app is installed",
            "type": "boolean"
          },
          "installedVersion": {
            "$ref": "#/components/schemas/StoreAppVersion"
          },
          "installedVersionMetadata": {
            "$ref": "#/components/schemas/StoreAppVersionMetadata"
          },
          "latestVersion": {
            "$ref": "#/components/schemas/StoreAppVersion"
          },
          "latestVersionMetadata": {
            "$ref": "#/components/schemas/StoreAppVersionMetadata"
          },
          "supportedEndpoints": {
            "description": "Application supported endpoints.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "title": {
            "description": "Application title that can be used for user display purposes",
            "type": "string"
          },
          "upgradable": {
            "description": "\"true\" if there is a new version that can be installed",
            "type": "boolean"
          },
          "vendor": {
            "description": "Name of the vendor for this app",
            "type": "string"
          }
        },
        "type": "object"
      },
      "StoreAppSummaryList": {
        "items": {
          "$ref": "#/components/schemas/StoreAppSummary"
        },
        "type": "array"
      },
      "StoreAppVersion": {
        "description": "The information about an application version available from a catalog.\nAt least one of \"semVer\" or \"commitHash\" must/will be defined.",
        "properties": {
          "appId": {
            "description": "The identifier for the application",
            "type": "string"
          },
          "catalog": {
            "description": "The catalog in which this application version was found",
            "type": "string"
          },
          "commitHash": {
            "description": "The commit hash for the application version.",
            "type": "string"
          },
          "semVer": {
            "description": "The semantic version for the application version.",
            "type": "string"
          }
        },
        "title": "Application version information",
        "type": "object"
      },
      "StoreAppVersionList": {
        "items": {
          "$ref": "#/components/schemas/StoreAppVersionWithMetadata"
        },
        "type": "array"
      },
      "StoreAppVersionMetadata": {
        "properties": {
          "publishedTime": {
            "description": "The date and time when the application version was published.",
            "format": "date-time",
            "type": "string"
          }
        },
        "title": "The metadata associated with an application version.",
        "type": "object"
      },
      "StoreAppVersionWithMetadata": {
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/StoreAppVersionMetadata"
          },
          "version": {
            "$ref": "#/components/schemas/StoreAppVersion"
          }
        },
        "type": "object"
      },
      "StoreCategoryList": {
        "items": {
          "type": "string"
        },
        "type": "array"
      },
      "TableRule": {
        "description": "A role rule controlling access to a EDB table.  Note that\nthere is never write access to EDB.",
        "properties": {
          "path": {
            "description": "EDB path to which this rule applies. It can end in \".*\"\nin which case the final portion of the table path can be anything, if the\nprefix matches. It can end in \".**\" in which case the table path can be\nanything if the prefix matches.",
            "minLength": 1,
            "pattern": "^\\..*",
            "type": "string"
          },
          "permissions": {
            "description": "Permissions for the given EDB path.",
            "enum": [
              "none",
              "read"
            ],
            "type": "string"
          }
        },
        "required": [
          "path",
          "permissions"
        ],
        "type": "object"
      },
      "TopoAttrMetadata": {
        "properties": {
          "type": {
            "type": "string"
          },
          "ui_description": {
            "type": "string"
          },
          "ui_description_key": {
            "type": "string"
          },
          "ui_name": {
            "type": "string"
          },
          "ui_name_key": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoAttribute": {
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoBoolExpression": {
        "properties": {
          "endpoint_expression": {
            "$ref": "#/components/schemas/TopoEndpointBoolExpression"
          },
          "fixed_expression": {
            "$ref": "#/components/schemas/TopoFixedBoolExpression"
          },
          "has_badge": {
            "$ref": "#/components/schemas/TopoLiteralStatusOrBadge"
          },
          "label": {
            "$ref": "#/components/schemas/TopoLabelSelector"
          },
          "literal": {
            "$ref": "#/components/schemas/TopoBoolLiteral"
          },
          "logical": {
            "$ref": "#/components/schemas/TopoLogicalExpression"
          },
          "not": {
            "$ref": "#/components/schemas/TopoBoolExpression"
          },
          "value_expression": {
            "$ref": "#/components/schemas/TopoValueExpression"
          }
        },
        "type": "object"
      },
      "TopoBoolLiteral": {
        "properties": {
          "value": {
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "TopoElemMetadata": {
        "properties": {
          "attributes": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoAttrMetadata"
            },
            "type": "object"
          },
          "schema": {
            "$ref": "#/components/schemas/TopoSchema"
          },
          "subtitle": {
            "type": "string"
          },
          "subtitle_key": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoEndpointBoolExpression": {
        "properties": {
          "endpoint": {
            "type": "string"
          },
          "expression": {
            "$ref": "#/components/schemas/TopoBoolExpression"
          }
        },
        "type": "object"
      },
      "TopoField": {
        "properties": {
          "type": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoFixedBoolExpression": {
        "properties": {
          "type": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoGroupingStateRequest": {
        "properties": {
          "name": {
            "type": "string"
          },
          "spec": {
            "$ref": "#/components/schemas/TopologyStateGroupingBase"
          }
        },
        "type": "object"
      },
      "TopoLabelSelector": {
        "properties": {
          "selector": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "TopoLiteralStatusOrBadge": {
        "properties": {
          "overlay": {
            "type": "string"
          },
          "value": {
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TopoLiteralValue": {
        "properties": {
          "badge": {
            "$ref": "#/components/schemas/TopoLiteralStatusOrBadge"
          },
          "bool": {
            "type": "boolean"
          },
          "number": {
            "format": "double",
            "type": "number"
          },
          "status": {
            "$ref": "#/components/schemas/TopoLiteralStatusOrBadge"
          },
          "string": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoLogicalExpression": {
        "properties": {
          "left": {
            "$ref": "#/components/schemas/TopoBoolExpression"
          },
          "operation": {
            "type": "string"
          },
          "right": {
            "$ref": "#/components/schemas/TopoBoolExpression"
          }
        },
        "type": "object"
      },
      "TopoNodeGrouping": {
        "properties": {
          "group": {
            "type": "string"
          },
          "group_key": {
            "type": "string"
          },
          "tier": {
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TopoOverlayAttrMetadata": {
        "properties": {
          "ui_description": {
            "type": "string"
          },
          "ui_description_key": {
            "type": "string"
          },
          "ui_name": {
            "type": "string"
          },
          "ui_name_key": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoOverlayAttrQuery": {
        "properties": {
          "attributes": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoOverlayAttrMetadata"
            },
            "type": "object"
          },
          "query": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoOverlayBadgeMetadata": {
        "properties": {
          "badge_name": {
            "type": "string"
          },
          "badge_path": {
            "type": "string"
          },
          "color": {
            "type": "string"
          },
          "ui_description": {
            "type": "string"
          },
          "ui_description_key": {
            "type": "string"
          },
          "ui_name": {
            "type": "string"
          },
          "ui_name_key": {
            "type": "string"
          },
          "value": {
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TopoOverlayEndpoint": {
        "properties": {
          "attributes": {
            "additionalProperties": {
              "type": "object"
            },
            "type": "object"
          },
          "cr_name": {
            "type": "string"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object"
          },
          "name": {
            "type": "string"
          },
          "namespace": {
            "type": "string"
          },
          "node": {
            "type": "string"
          },
          "node_key": {
            "type": "string"
          },
          "overlays": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoOverlayEndpointState"
            },
            "type": "object"
          },
          "schema": {
            "$ref": "#/components/schemas/TopoSchema"
          },
          "ui_name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoOverlayEndpointState": {
        "properties": {
          "state": {
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TopoOverlayLink": {
        "properties": {
          "attributes": {
            "additionalProperties": {
              "type": "object"
            },
            "type": "object"
          },
          "cr_name": {
            "type": "string"
          },
          "endpoint_a": {
            "$ref": "#/components/schemas/TopoOverlayEndpoint"
          },
          "endpoint_a_name": {
            "type": "string"
          },
          "endpoint_b": {
            "$ref": "#/components/schemas/TopoOverlayEndpoint"
          },
          "endpoint_b_name": {
            "type": "string"
          },
          "group_key": {
            "type": "string"
          },
          "key": {
            "type": "string"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object"
          },
          "name": {
            "type": "string"
          },
          "namespace": {
            "type": "string"
          },
          "overlays": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoOverlayLinkState"
            },
            "type": "object"
          },
          "schema": {
            "$ref": "#/components/schemas/TopoSchema"
          },
          "ui_name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoOverlayLinkGroup": {
        "properties": {
          "endpoint_a": {
            "$ref": "#/components/schemas/TopoOverlayLinkGroupEndpoint"
          },
          "endpoint_b": {
            "$ref": "#/components/schemas/TopoOverlayLinkGroupEndpoint"
          },
          "key": {
            "type": "string"
          },
          "overlays": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoOverlayLinkState"
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "TopoOverlayLinkGroupEndpoint": {
        "properties": {
          "group_key": {
            "type": "string"
          },
          "node_key": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoOverlayLinkState": {
        "properties": {
          "state": {
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TopoOverlayNode": {
        "properties": {
          "attributes": {
            "additionalProperties": {
              "type": "object"
            },
            "type": "object"
          },
          "cr_name": {
            "type": "string"
          },
          "grouping": {
            "$ref": "#/components/schemas/TopoNodeGrouping"
          },
          "key": {
            "type": "string"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object"
          },
          "name": {
            "type": "string"
          },
          "namespace": {
            "type": "string"
          },
          "overlays": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoOverlayNodeState"
            },
            "type": "object"
          },
          "schema": {
            "$ref": "#/components/schemas/TopoSchema"
          },
          "ui_name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoOverlayNodeOrGroup": {
        "properties": {
          "attributes": {
            "additionalProperties": {
              "type": "object"
            },
            "type": "object"
          },
          "cr_name": {
            "type": "string"
          },
          "grouping": {
            "$ref": "#/components/schemas/TopoNodeGrouping"
          },
          "key": {
            "type": "string"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object"
          },
          "name": {
            "type": "string"
          },
          "namespace": {
            "type": "string"
          },
          "num_nodes": {
            "format": "int64",
            "type": "integer"
          },
          "overlays": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TopoOverlayNodeState"
            },
            "type": "object"
          },
          "schema": {
            "$ref": "#/components/schemas/TopoSchema"
          },
          "type": {
            "type": "string"
          },
          "ui_name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoOverlayNodeState": {
        "properties": {
          "badges": {
            "items": {
              "format": "int64",
              "type": "integer"
            },
            "type": "array"
          },
          "state": {
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TopoOverlayStateMetadata": {
        "properties": {
          "color": {
            "type": "string"
          },
          "ui_description": {
            "type": "string"
          },
          "ui_description_key": {
            "type": "string"
          },
          "ui_name": {
            "type": "string"
          },
          "ui_name_key": {
            "type": "string"
          },
          "value": {
            "format": "int64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TopoOverlayValue": {
        "properties": {
          "overlay": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoSchema": {
        "properties": {
          "group": {
            "type": "string"
          },
          "kind": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopoStateFilter": {
        "properties": {
          "expand_all_link_groups": {
            "type": "boolean"
          },
          "expand_all_node_groups": {
            "type": "boolean"
          },
          "expanded_link_groups": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "expanded_node_groups": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "link_filter": {
            "$ref": "#/components/schemas/TopoBoolExpression"
          },
          "node_filter": {
            "$ref": "#/components/schemas/TopoBoolExpression"
          }
        },
        "type": "object"
      },
      "TopoStateRequest": {
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/TopoStateFilter"
          },
          "grouping": {
            "$ref": "#/components/schemas/TopoGroupingStateRequest"
          },
          "namespace": {
            "type": "string"
          },
          "overlays": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "TopoValue": {
        "properties": {
          "attribute": {
            "$ref": "#/components/schemas/TopoAttribute"
          },
          "badge": {
            "$ref": "#/components/schemas/TopoOverlayValue"
          },
          "field": {
            "$ref": "#/components/schemas/TopoField"
          },
          "literal": {
            "$ref": "#/components/schemas/TopoLiteralValue"
          },
          "status": {
            "$ref": "#/components/schemas/TopoOverlayValue"
          }
        },
        "type": "object"
      },
      "TopoValueExpression": {
        "properties": {
          "left": {
            "$ref": "#/components/schemas/TopoValue"
          },
          "operation": {
            "type": "string"
          },
          "right": {
            "$ref": "#/components/schemas/TopoValue"
          }
        },
        "type": "object"
      },
      "Topologies": {
        "items": {
          "$ref": "#/components/schemas/Topology"
        },
        "type": "array"
      },
      "Topology": {
        "properties": {
          "endpoints": {
            "$ref": "#/components/schemas/TopoElemMetadata"
          },
          "group": {
            "type": "string"
          },
          "grouping": {
            "$ref": "#/components/schemas/TopoSchema"
          },
          "links": {
            "$ref": "#/components/schemas/TopoElemMetadata"
          },
          "name": {
            "type": "string"
          },
          "nodes": {
            "$ref": "#/components/schemas/TopoElemMetadata"
          },
          "ui_description": {
            "type": "string"
          },
          "ui_description_key": {
            "type": "string"
          },
          "ui_name": {
            "type": "string"
          },
          "ui_name_key": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopologyGroupingInstance": {
        "properties": {
          "apiVersion": {
            "description": "The group/version for the topology grouping data.",
            "type": "string"
          },
          "kind": {
            "description": "The kind for the topology grouping data.",
            "type": "string"
          },
          "metadata": {
            "$ref": "#/components/schemas/TopologyGroupingInstance_metadata"
          },
          "spec": {
            "additionalProperties": {
              "type": "object"
            },
            "type": "object"
          },
          "status": {
            "additionalProperties": {
              "type": "object"
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "TopologyGroupingsList": {
        "properties": {
          "apiVersion": {
            "description": "The group/version for the topology grouping data.",
            "type": "string"
          },
          "items": {
            "description": "The metadata kind for the topology grouping data.",
            "items": {
              "$ref": "#/components/schemas/TopologyGroupingInstance"
            },
            "type": "array"
          },
          "kind": {
            "description": "The kind for the topology grouping data.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopologyStateGroupSelector": {
        "properties": {
          "group": {
            "description": "The group to assign to nodes that match the selector.\n+eda:ui:title=\"Group\"",
            "type": "string"
          },
          "nodeSelector": {
            "description": "+kubebuilder:validation:Optional\n+eda:ui:title=\"Node Selector\"\n+eda:ui:format=\"labelselector\"\nLabel selector to use to match nodes that should be assigned to this group.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "TopologyStateGroupingBase": {
        "description": "Embed this type inside your topology tier CRD spec to determine the tiers and the\ngroups of the nodes in the topology.",
        "properties": {
          "groupSelectors": {
            "description": "The set of selectors for assigning nodes to groups\n+eda:ui:title=\"Group Selectors\"",
            "items": {
              "$ref": "#/components/schemas/TopologyStateGroupSelector"
            },
            "type": "array"
          },
          "tierSelectors": {
            "description": "The set of selectors for assigning nodes to tiers\n+eda:ui:title=\"Tier Selectors\"",
            "items": {
              "$ref": "#/components/schemas/TopologyStateTierSelector"
            },
            "type": "array"
          },
          "uiDescription": {
            "description": "A description of the topology grouping to expose in the UI\n+eda:ui:title=\"UI Description\"",
            "type": "string"
          },
          "uiDescriptionKey": {
            "description": "The translation key for the description of the topology grouping to expose in the UI\n+eda:ui:title=\"UI Description Key\"",
            "type": "string"
          },
          "uiName": {
            "description": "The name of the topology grouping to expose in the UI\n+eda:ui:title=\"UI Name\"",
            "type": "string"
          },
          "uiNameKey": {
            "description": "The translation key for the name of the topology grouping to expose in the UI\n+eda:ui:title=\"UI Name Key\"",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopologyStateTierSelector": {
        "properties": {
          "nodeSelector": {
            "description": "+kubebuilder:validation:Optional\n+eda:ui:title=\"Node Selector\"\n+eda:ui:format=\"labelselector\"\nLabel selector to use to match nodes that should be assigned to this tier.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "tier": {
            "description": "The tier to assign to nodes that match the selector.\n+eda:ui:title=\"Tier\"",
            "format": "uint32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Transaction": {
        "properties": {
          "crs": {
            "description": "List of CRs to include in the transaction",
            "items": {
              "$ref": "#/components/schemas/TransactionCr"
            },
            "type": "array"
          },
          "description": {
            "description": "Description/commit message for the transaction",
            "type": "string"
          },
          "detailLevel": {
            "default": "standard",
            "description": "The detail level requested for transaction results.",
            "enum": [
              "standard",
              "detailed"
            ],
            "type": "string"
          },
          "disableBatching": {
            "default": false,
            "description": "If true the transaction will not be allowed to be batched with other transactions.\n\nNote that setting this to true can have an adverse impact on performance.",
            "type": "boolean"
          },
          "dryRun": {
            "description": "If true the transaction will not be committed and will run in dry run mode.  If false the\ntransaction will be committed",
            "type": "boolean"
          },
          "resultType": {
            "description": "The type of results requested.\nDeprecated: \"detailLevel\" should be used instead.",
            "enum": [
              "errors_only",
              "normal",
              "debug"
            ],
            "type": "string",
            "deprecated": true
          },
          "retain": {
            "default": false,
            "description": "Deprecated: retain after results fetched - e.g. after call to get transaction result",
            "type": "boolean",
            "deprecated": true
          }
        },
        "required": [
          "crs",
          "description",
          "dryRun"
        ],
        "title": "Request body content for a POST transaction request.",
        "type": "object"
      },
      "TransactionAppError": {
        "properties": {
          "rawError": {
            "type": "string"
          },
          "structuredError": {
            "$ref": "#/components/schemas/TransactionStructuredAppError"
          }
        },
        "type": "object"
      },
      "TransactionContent": {
        "properties": {
          "apiVersion": {
            "type": "string"
          },
          "kind": {
            "type": "string"
          },
          "metadata": {
            "$ref": "#/components/schemas/Metadata"
          },
          "spec": {
            "type": "object"
          }
        },
        "type": "object"
      },
      "TransactionCr": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/TransactionType"
          }
        },
        "type": "object"
      },
      "TransactionExecutionResult": {
        "properties": {
          "changedCrs": {
            "description": "List of changed CRs as part of the transaction",
            "items": {
              "$ref": "#/components/schemas/TransactionNsCrGvkNames"
            },
            "type": "array"
          },
          "executionSummary": {
            "description": "Information about time taken during processing",
            "type": "string"
          },
          "generalErrors": {
            "description": "List of general errors while running the transaction",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "intentsRun": {
            "description": "List of intents which ran as part of the transaction",
            "items": {
              "$ref": "#/components/schemas/TransactionIntentResult"
            },
            "type": "array"
          },
          "nodesWithConfigChanges": {
            "description": "List of nodes with configuration changes from the transaction",
            "items": {
              "$ref": "#/components/schemas/TransactionNodeResult"
            },
            "type": "array"
          },
          "topologySupported": {
            "description": "Whether a topology representation of this transaction is supported",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "TransactionId": {
        "properties": {
          "id": {
            "description": "A transaction identifier; these are assigned by the system to a posted transaction.",
            "format": "uint64",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TransactionInputResource": {
        "properties": {
          "data": {
            "additionalProperties": {
              "type": "object"
            },
            "type": "object"
          },
          "isDelete": {
            "type": "boolean"
          },
          "name": {
            "$ref": "#/components/schemas/NsCrGvkName"
          },
          "operation": {
            "$ref": "#/components/schemas/OperationType"
          }
        },
        "type": "object"
      },
      "TransactionIntentResult": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/TransactionAppError"
            },
            "type": "array"
          },
          "intentName": {
            "$ref": "#/components/schemas/NsCrGvkName"
          },
          "outputCrs": {
            "items": {
              "$ref": "#/components/schemas/NsCrGvkName"
            },
            "type": "array"
          },
          "script": {
            "$ref": "#/components/schemas/TransactionScriptResults"
          }
        },
        "type": "object"
      },
      "TransactionNodeResult": {
        "description": "The name of a node with changes from a transaction, and a list\nof errors that occurred for the node",
        "properties": {
          "errors": {
            "description": "Resulting errors for the node",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "description": "The name of the node",
            "type": "string"
          },
          "namespace": {
            "description": "The namespace of the node",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TransactionNsCrGvkNames": {
        "properties": {
          "gvk": {
            "$ref": "#/components/schemas/GroupVersionKind"
          },
          "names": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "namespace": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TransactionPatch": {
        "properties": {
          "patchOps": {
            "$ref": "#/components/schemas/Patch"
          },
          "target": {
            "$ref": "#/components/schemas/NsCrGvkName"
          }
        },
        "required": [
          "patchOps",
          "target"
        ],
        "type": "object"
      },
      "TransactionResultInputResources": {
        "properties": {
          "inputCrs": {
            "description": "List of input resources from the transaction",
            "items": {
              "$ref": "#/components/schemas/TransactionInputResource"
            },
            "type": "array"
          },
          "limitedAccess": {
            "description": "This field is true if the list returned here is not the complete list of input resources in the transaction because the user does not have read-access to some of them",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "TransactionResultObject": {
        "properties": {
          "after": {
            "$ref": "#/components/schemas/TransactionResultObjectString"
          },
          "before": {
            "$ref": "#/components/schemas/TransactionResultObjectString"
          },
          "dataUnavailable": {
            "description": "True if there is no data available for the result",
            "type": "boolean"
          },
          "format": {
            "description": "The format of the response - Text or YAML",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TransactionResultObjectString": {
        "properties": {
          "data": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "TransactionRevertRestoreRequest": {
        "properties": {
          "detailLevel": {
            "default": "standard",
            "description": "The detail level requested for transaction results for the transaction resulting from the revert/restore.",
            "enum": [
              "standard",
              "detailed"
            ],
            "type": "string"
          },
          "dryRun": {
            "description": "If true the operation will not be committed and will run in dry run mode.  If false the\noperation will be committed",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "TransactionScriptResults": {
        "properties": {
          "executionTime": {
            "format": "uint32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TransactionState": {
        "properties": {
          "state": {
            "description": "The state of the transaction",
            "enum": [
              "unknownTid",
              "queued",
              "running",
              "complete"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "TransactionStructuredAppError": {
        "properties": {
          "message": {
            "type": "string"
          },
          "messageKey": {
            "type": "string"
          },
          "values": {
            "additionalProperties": {
              "type": "object"
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "TransactionSummaryResult": {
        "description": "Summary of the result of a transaction",
        "properties": {
          "bundledTransactionId": {
            "description": "If present (and non-zero) indicates that the execution of this transaction was bundled into the transaction with this identifier.",
            "format": "uint64",
            "type": "integer"
          },
          "commitHash": {
            "description": "The git commit hash for the transaction",
            "type": "string"
          },
          "description": {
            "description": "The description of the transaction, as posted in the transaction request.",
            "type": "string"
          },
          "detailLevel": {
            "description": "The level of detail available in the transaction details.",
            "enum": [
              "basic",
              "standard",
              "detailed"
            ],
            "type": "string"
          },
          "details": {
            "description": "The type of details available for the transaction, as posted in the transaction request.\nDeprecated: use \"detailLevel\" instead.",
            "enum": [
              "errors_only",
              "normal",
              "debug"
            ],
            "type": "string",
            "deprecated": true
          },
          "dryRun": {
            "description": "If true the transaction was not committed and ran in dry run mode.",
            "type": "boolean"
          },
          "id": {
            "description": "The transaction identifier",
            "format": "uint64",
            "type": "integer"
          },
          "lastChangeTimestamp": {
            "description": "The time that the transaction completed.",
            "type": "string"
          },
          "state": {
            "description": "The state of the transaction.",
            "type": "string"
          },
          "success": {
            "description": "True if the transaction was successful.",
            "type": "boolean"
          },
          "username": {
            "description": "The user who posted the transaction.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TransactionSummaryResults": {
        "properties": {
          "results": {
            "description": "array of summary-results for transactions",
            "items": {
              "$ref": "#/components/schemas/TransactionSummaryResult"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "TransactionTopologyResult": {
        "properties": {
          "overlayMetadata": {
            "$ref": "#/components/schemas/Overlay"
          },
          "topology": {
            "$ref": "#/components/schemas/OverlayState"
          },
          "topologyMetadata": {
            "$ref": "#/components/schemas/Topology"
          }
        },
        "type": "object"
      },
      "TransactionType": {
        "properties": {
          "create": {
            "$ref": "#/components/schemas/TransactionValue"
          },
          "delete": {
            "$ref": "#/components/schemas/NsCrGvkName"
          },
          "modify": {
            "$ref": "#/components/schemas/TransactionValue"
          },
          "patch": {
            "$ref": "#/components/schemas/TransactionPatch"
          },
          "replace": {
            "$ref": "#/components/schemas/TransactionValue"
          }
        },
        "type": "object"
      },
      "TransactionValue": {
        "properties": {
          "value": {
            "$ref": "#/components/schemas/TransactionContent"
          }
        },
        "type": "object"
      },
      "UrlRule": {
        "properties": {
          "path": {
            "description": "The API server URL path to which this rule applies. It can end in \"/*\"\nin which case the final portion of the URL path can be anything, if the\nprefix matches. It can end in \"/**\" in which case the URL path can be\nanything if the prefix matches.\",",
            "minLength": 1,
            "pattern": "^/.*",
            "type": "string"
          },
          "permissions": {
            "description": "The permissions for the API server URL for the rule.",
            "enum": [
              "none",
              "read",
              "readWrite"
            ],
            "type": "string"
          }
        },
        "required": [
          "path"
        ],
        "title": "A role rule controlling access to an API server endpoint/route.",
        "type": "object"
      },
      "UserStatus": {
        "properties": {
          "failedLoginSinceSuccessfulLogin": {
            "format": "int64",
            "type": "integer"
          },
          "federationProviderName": {
            "description": "The name of the federation provider for this user. Absent if the user is not federated",
            "type": "string"
          },
          "federationProviderUUID": {
            "description": "The UUID of the federation provider for this user. Absent if the user is not federated",
            "type": "string"
          },
          "isFederatedUser": {
            "description": "True if the user comes from a federated LDAP server",
            "type": "boolean"
          },
          "lastFailedLogin": {
            "type": "string"
          },
          "lastSuccessfulLogin": {
            "type": "string"
          },
          "temporarilyDisabled": {
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "UserStorageInFileContent": {
        "properties": {
          "file-content": {
            "description": "The desired content of the user-storage file. This will be base64 decoded before storing if the request indicates that the content is base64 encoded.",
            "type": "string"
          }
        },
        "required": [
          "file-content"
        ],
        "title": "request body contents for a PUT/POST file user-storage request.",
        "type": "object"
      },
      "UserStorageOutDirContent": {
        "properties": {
          "directory-path": {
            "description": "path for the directory within the users storage",
            "type": "string"
          },
          "entries": {
            "description": "array of entries for the items in the directory",
            "items": {
              "$ref": "#/components/schemas/UserStorageOutDirEntry"
            },
            "type": "array"
          }
        },
        "required": [
          "directory-path",
          "entries"
        ],
        "title": "The data returned to the client from a GET directory user-storage request.",
        "type": "object"
      },
      "UserStorageOutDirEntry": {
        "description": "user-storage directory entry",
        "properties": {
          "modification-time": {
            "description": "modification type of the item, if a file",
            "format": "date-time",
            "type": "string"
          },
          "name": {
            "description": "name of the item within the directory",
            "type": "string"
          },
          "type": {
            "description": "type of the item; \"file\" or \"directory\"",
            "type": "string"
          }
        },
        "required": [
          "name",
          "type"
        ],
        "type": "object"
      },
      "UserStorageOutFileContent": {
        "properties": {
          "file-content": {
            "description": "content of the file, will be base64 encoded if the request asked for this",
            "type": "string"
          },
          "file-deleted": {
            "description": "if present and true, indicates the file has been deleted; used for\nstreamed responses",
            "type": "boolean"
          },
          "file-name": {
            "description": "name of the file",
            "type": "string"
          },
          "modification-time": {
            "description": "UTC modification time of the file, as an RFC 3339 date/time.\nNot valid if file-deleted is true (in a streamed response)",
            "format": "date-time",
            "type": "string"
          }
        },
        "required": [
          "file-name"
        ],
        "type": "object"
      },
      "WorkflowStatusSummary": {
        "properties": {
          "creationTime": {
            "type": "string"
          },
          "group": {
            "type": "string"
          },
          "id": {
            "format": "int64",
            "type": "integer"
          },
          "kind": {
            "type": "string"
          },
          "lastUpdate": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "namespace": {
            "type": "string"
          },
          "parent": {
            "$ref": "#/components/schemas/Identifier"
          },
          "rootWorkflow": {
            "$ref": "#/components/schemas/Identifier"
          },
          "state": {
            "enum": [
              "OK",
              "Failed",
              "Terminated",
              "WaitingForInput",
              "Running",
              "WaitingToStart",
              "SubflowWaitingForInput",
              "Completed"
            ],
            "type": "string"
          },
          "username": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "dbGetResult": {
        "additionalProperties": {
          "type": "object"
        },
        "description": "Each key is the \"jsPath\" of the table row, and each value is the data for that row.",
        "title": "DB get endpoint result",
        "type": "object"
      },
      "singleVersionInfo": {
        "properties": {
          "builtDate": {
            "description": "The build-time for the component.",
            "type": "string"
          },
          "version": {
            "description": "The version string for the component.",
            "type": "string"
          }
        },
        "title": "Version information for a single component.",
        "type": "object"
      },
      "transactionTopologyRequest": {
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/TopoStateFilter"
          }
        },
        "type": "object"
      },
      "versionInfo": {
        "additionalProperties": {
          "$ref": "#/components/schemas/singleVersionInfo"
        },
        "title": "Version information for subsystems and the overall EDA product.",
        "type": "object"
      },
      "AuthProvider_auth": {
        "description": "If present, bind to LDAP server with the given credentials.  Otherwise do not bind.",
        "properties": {
          "bindCredential": {
            "description": "Credentials to use when binding to an LDAP provider",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-internal-feature": [
                "testAuthentication"
              ],
              "ui-order-priority": 20,
              "ui-title": "Bind Credential",
              "ui-title-key": "bind_credential"
            }
          },
          "bindDN": {
            "description": "DN to use when binding to an LDAP provider",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 10,
              "ui-title": "Bind DN",
              "ui-title-key": "bind_dn"
            }
          }
        },
        "required": [
          "bindCredential",
          "bindDN"
        ],
        "type": "object",
        "x-eda-nokia-com": {
          "ui-order-priority": 70,
          "ui-presence-toggle": true,
          "ui-title": "Bind Attributes",
          "ui-title-key": "bind_attributes"
        }
      },
      "AuthProvider_groupSupport": {
        "description": "Configuration for group import/sync with LDAP.  If not present, groups will not synchronized with EDA.",
        "properties": {
          "NameLDAPAttribute": {
            "description": "The LDAP group name attribute",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 230,
              "ui-title": "Name LDAP Attribute",
              "ui-title-key": "name_ldap_attribute"
            }
          },
          "filter": {
            "description": "Further for filtering when retrieving LDAP groups. Ensure starts and ends with parentheses if using.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 270,
              "ui-title": "Filter",
              "ui-title-key": "filter"
            }
          },
          "groupLDAPDN": {
            "description": "The LDAP DN where groups are found.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 220,
              "ui-title": "Group LDAP DN",
              "ui-title-key": "groups_dn"
            }
          },
          "memberAttribute": {
            "description": "The group attribute for a members.  Usually \"member\" or \"memberUid\".",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 240,
              "ui-title": "Member Attribute",
              "ui-title-key": "member_attribute"
            }
          },
          "memberOfAttribute": {
            "description": "If retrievalStrategy is \"memberOf\", this is the LDAP user attribute for group memberships.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 290,
              "ui-title": "Member Of Attribute",
              "ui-title-key": "member_of_attribute"
            }
          },
          "membershipAttributeType": {
            "description": "How users are identified in a group member entry: either DN or UID.",
            "enum": [
              "DN",
              "UID"
            ],
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 250,
              "ui-title": "Membership Attribute Type",
              "ui-title-key": "membership_attribute_type"
            }
          },
          "membershipUserAttribute": {
            "description": "Only required if membershipAttributeType is UID; then it is the user attribute that should match the group member value.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 260,
              "ui-title": "Membership User Attribute",
              "ui-title-key": "membership_user_attribute"
            }
          },
          "objectClasses": {
            "description": "The LDAP object class or classes used for groups. If more than one, they must be comma-separated.",
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 210,
              "ui-title": "Object Classes",
              "ui-title-key": "object_classes"
            }
          },
          "retrievalStrategy": {
            "description": "The strategy for retrieving groups.  Should be \"member\" to get group membership from the group, or \"memberOf\" to get group membership from the user.",
            "enum": [
              "member",
              "memberOf"
            ],
            "type": "string",
            "x-eda-nokia-com": {
              "ui-order-priority": 280,
              "ui-title": "Retrieval Strategy",
              "ui-title-key": "retrieval_strategy"
            }
          }
        },
        "required": [
          "NameLDAPAttribute",
          "groupLDAPDN",
          "objectClasses"
        ],
        "type": "object",
        "x-eda-nokia-com": {
          "ui-order-priority": 200,
          "ui-presence-toggle": true,
          "ui-title": "Group Support",
          "ui-title-key": "group_support"
        }
      },
      "StoreAppRequirementsGraphItem_installedAppVersion": {
        "description": "The application version installed in the cluster, if installed.",
        "properties": {
          "appId": {
            "description": "The identifier for the application",
            "type": "string"
          },
          "catalog": {
            "description": "The catalog in which this application version was found",
            "type": "string"
          },
          "commitHash": {
            "description": "The commit hash for the application version.",
            "type": "string"
          },
          "semVer": {
            "description": "The semantic version for the application version.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "StoreAppRequirementsGraphItem_targetAppVersion": {
        "description": "This graph item instance contains the dependencies for this particular application version.",
        "properties": {
          "appId": {
            "description": "The identifier for the application",
            "type": "string"
          },
          "catalog": {
            "description": "The catalog in which this application version was found",
            "type": "string"
          },
          "commitHash": {
            "description": "The commit hash for the application version.",
            "type": "string"
          },
          "semVer": {
            "description": "The semantic version for the application version.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TopologyGroupingInstance_metadata": {
        "description": "The metadata kind for the topology grouping data.",
        "properties": {
          "annotations": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-eda-nokia-com": {
              "ui-order-priority": 40,
              "ui-title": "Annotations",
              "ui-title-key": "annotations"
            }
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "x-eda-nokia-com": {
              "ui-auto-completes": [
                {
                  "condition": "true",
                  "group": "GROUP",
                  "kind": "KIND",
                  "type": "label",
                  "version": "VERSION"
                }
              ],
              "ui-order-priority": 30,
              "ui-title": "Labels",
              "ui-title-key": "labels"
            }
          },
          "name": {
            "maxLength": 253,
            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$",
            "type": "string",
            "x-eda-nokia-com": {
              "immutable": true,
              "ui-order-priority": 10,
              "ui-pattern-error": "A valid name is made up of one or more components where each component is separated by period characters.  Each component must start and end with a lower case alphanumeric character and the body of the component is made up of zero or more lower case alphanumeric and hyphen characters.",
              "ui-title": "Name",
              "ui-title-key": "name"
            }
          },
          "namespace": {
            "type": "string",
            "x-eda-nokia-com": {
              "immutable": true,
              "ui-order-priority": 20,
              "ui-title": "Namespace",
              "ui-title-key": "namespace"
            }
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      }
    },
    "securitySchemes": {
      "bearerAuth": {
        "scheme": "bearer",
        "type": "http",
        "bearerFormat": "JWT"
      }
    }
  }
}