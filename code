=== ./package.json ===
{
  "name": "vscode-eda",
  "publisher": "eda-labs",
  "displayName": "Event Driven Automation",
  "icon": "resources/eda.png",
  "description": "Manage and monitor Event-Driven Architecture resources in Kubernetes",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.70.0"
  },
  "repository": {
    "type": "git"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [],
  "main": "./dist/extension.js",
  "contributes": {
    "viewsContainers": {
      "activitybar": [
        {
          "id": "edaExplorerViewContainer",
          "title": "EDA Explorer",
          "icon": "resources/eda-icon-black.svg"
        }
      ]
    },
    "views": {
      "edaExplorerViewContainer": [
        {
          "id": "edaNamespaces",
          "name": "Resources"
        },
        {
          "id": "edaSystem",
          "name": "System"
        },
        {
          "id": "edaAlarms",
          "name": "Alarms"
        },
        {
          "id": "edaDeviations",
          "name": "Deviations"
        },
        {
          "id": "edaTransactions",
          "name": "Transactions"
        }
      ]
    },
    "commands": [
      {
        "command": "vscode-eda.refreshResources",
        "title": "Refresh Resources",
        "icon": "$(refresh)"
      },
      {
        "command": "vscode-eda.showTransactionDetails",
        "title": "Show Transaction Details"
      },
      {
        "command": "vscode-eda.deletePod",
        "title": "Delete Pod",
        "icon": "$(trash)"
      },
      {
        "command": "vscode-eda.terminalPod",
        "title": "Open Terminal to Pod",
        "icon": "$(terminal)"
      },
      {
        "command": "vscode-eda.logsPod",
        "title": "View Pod Logs",
        "icon": "$(list-unordered)"
      },
      {
        "command": "vscode-eda.describePod",
        "title": "Describe Pod",
        "icon": "$(info)"
      },
      {
        "command": "vscode-eda.switchToEditResource",
        "title": "Switch to Edit Mode",
        "icon": "$(edit)"
      },
      {
        "command": "vscode-eda.applyResourceChanges",
        "title": "Apply Resource Changes",
        "icon": "$(check)"
      },
      {
        "command": "vscode-eda.applyResourceChanges.dryRun",
        "title": "Validate (Dry Run)",
        "icon": "$(debug-alt)"
      },
      {
        "command": "vscode-eda.showResourceDiff",
        "title": "Show Resource Changes",
        "icon": "$(diff)"
      },
      {
        "command": "vscode-eda.showCRDDefinition",
        "title": "Show CRD Definition",
        "icon": "$(file)"
      },
      {
        "command": "vscode-eda.filterTree",
        "title": "Filter Tree",
        "icon": "$(filter-filled)"
      },
      {
        "command": "vscode-eda.clearFilter",
        "title": "Clear Filter",
        "icon": "$(filter)"
      },
      {
        "command": "vscode-eda.createResource",
        "title": "Create Resource",
        "icon": "$(add)"
      },
      {
        "command": "vscode-eda.showAlarmDetails",
        "title": "Show Alarm Details"
      },
      {
        "command": "vscode-eda.showDeviationDetails",
        "title": "Show Deviation Details"
      },
      {
        "command": "vscode-eda.acceptDeviation",
        "title": "Accept Deviation"
      },
      {
        "command": "vscode-eda.rejectDeviation",
        "title": "Reject Deviation"
      },
      {
        "command": "vscode-eda.acceptDeviation",
        "title": "Accept Deviation",
        "icon": "$(check)"
      },
      {
        "command": "vscode-eda.rejectDeviation",
        "title": "Reject Deviation",
        "icon": "$(x)"
      },
      {
        "command": "vscode-eda.revertTransaction",
        "title": "Revert Transaction",
        "icon": "$(history)"
      },
      {
        "command": "vscode-eda.restoreTransaction",
        "title": "Restore Transaction",
        "icon": "$(debug-step-back)"
      }
    ],
    "menus": {
      "view/title": [
        {
          "command": "vscode-eda.refreshResources",
          "when": "view == edaNamespaces",
          "group": "navigation@1"
        },
        {
          "command": "vscode-eda.filterTree",
          "when": "view == edaNamespaces",
          "group": "navigation@2"
        },
        {
          "command": "vscode-eda.filterTree",
          "when": "view == edaSystem",
          "group": "navigation@3"
        },
        {
          "command": "vscode-eda.clearFilter",
          "when": "view == edaNamespaces || view == edaSystem",
          "group": "navigation@4"
        },
        {
          "command": "vscode-eda.createResource",
          "when": "view == edaNamespaces || view == edaSystem",
          "group": "navigation@5"
        }
      ],
      "view/item/context": [
        {
          "command": "vscode-eda.logsPod",
          "when": "viewItem == pod || viewItem == npp-pod",
          "group": "inline"
        },
        {
          "command": "vscode-eda.describePod",
          "when": "viewItem == pod || viewItem == npp-pod",
          "group": "inline"
        },
        {
          "command": "vscode-eda.terminalPod",
          "when": "viewItem == pod || viewItem == npp-pod",
          "group": "inline"
        },
        {
          "command": "vscode-eda.deletePod",
          "when": "viewItem == pod || viewItem == npp-pod",
          "group": "inline"
        },
        {
          "command": "vscode-eda.logsPod",
          "when": "viewItem == pod || viewItem == npp-pod",
          "group": "navigation"
        },
        {
          "command": "vscode-eda.describePod",
          "when": "viewItem == pod || viewItem == npp-pod",
          "group": "navigation"
        },
        {
          "command": "vscode-eda.terminalPod",
          "when": "viewItem == pod || viewItem == npp-pod",
          "group": "navigation"
        },
        {
          "command": "vscode-eda.deletePod",
          "when": "viewItem == pod || viewItem == npp-pod",
          "group": "navigation"
        },
        {
          "command": "vscode-eda.viewResource",
          "when": "viewItem =~ /pod|deployment|service|configmap|secret|crd-instance/",
          "group": "inline"
        },
        {
          "command": "vscode-eda.showCRDDefinition",
          "when": "viewItem == crd-instance",
          "group": "inline"
        },
        {
          "command": "vscode-eda.showCRDDefinition",
          "when": "viewItem == crd-instance",
          "group": "navigation"
        },
        {
          "command": "vscode-eda.showAlarmDetails",
          "when": "viewItem == eda-alarm",
          "group": "navigation"
        },
        {
          "command": "vscode-eda.showDeviationDetails",
          "when": "viewItem == eda-deviation",
          "group": "navigation"
        },
        {
          "command": "vscode-eda.acceptDeviation",
          "when": "viewItem == eda-deviation",
          "group": "inline"
        },
        {
          "command": "vscode-eda.rejectDeviation",
          "when": "viewItem == eda-deviation",
          "group": "inline"
        },
        {
          "command": "vscode-eda.revertTransaction",
          "when": "viewItem == transaction",
          "group": "inline"
        },
        {
          "command": "vscode-eda.restoreTransaction",
          "when": "viewItem == transaction",
          "group": "inline"
        }
      ],
      "editor/title": [
        {
          "command": "vscode-eda.applyResourceChanges",
          "when": "resourceScheme == k8s",
          "group": "navigation@1"
        },
        {
          "command": "vscode-eda.showResourceDiff",
          "when": "resourceScheme == k8s",
          "group": "navigation@2"
        },
        {
          "command": "vscode-eda.applyResourceChanges.dryRun",
          "when": "resourceScheme == k8s",
          "group": "navigation@3"
        },
        {
          "command": "vscode-eda.switchToEditResource",
          "when": "resourceScheme == k8s-view",
          "group": "navigation@4"
        }
      ],
      "editor/context": [
        {
          "command": "vscode-eda.switchToEditResource",
          "when": "resourceScheme == k8s-view",
          "group": "1_modification@1"
        }
      ]
    },
    "configuration": {
      "title": "EDA Explorer",
      "properties": {
        "vscode-eda.refreshInterval": {
          "type": "number",
          "default": 30000,
          "description": "Auto-refresh interval in milliseconds (default: 10000 ms = 30 seconds)"
        },
        "vscode-eda.logLevel": {
          "type": "number",
          "default": 1,
          "enum": [
            0,
            1,
            2,
            3
          ],
          "enumDescriptions": [
            "Debug: Show all logs including detailed operations",
            "Info: Show general information (default)",
            "Warning: Show only warnings and errors",
            "Error: Show only errors"
          ],
          "description": "Controls the level of detail in the EDA output logs"
        }
      }
    }
  },
  "scripts": {
    "compile": "npm run check-types && npm run lint && node esbuild.js --production",
    "watch": "npm-run-all -p watch:*",
    "watch:esbuild": "node esbuild.js --watch",
    "watch:tsc": "tsc --noEmit --watch --project tsconfig.json"
  },
  "devDependencies": {
    "@types/glob": "^8.1.0",
    "@types/js-yaml": "^4.0.9",
    "@types/node": "^18.15.11",
    "@types/request": "^2.48.12",
    "@types/vscode": "^1.70.0",
    "@types/ws": "^8.18.0",
    "@typescript-eslint/eslint-plugin": "~5.59.0",
    "@typescript-eslint/parser": "~5.59.0",
    "esbuild": "^0.25.1",
    "eslint": "~8.38.0",
    "eslint-config-prettier": "~8.8.0",
    "eslint-plugin-prettier": "~4.2.1",
    "glob": "^8.1.0",
    "prettier": "~2.8.7",
    "typescript": "~5.7.2",
    "vscode-test": "^1.6.1"
  },
  "dependencies": {
    "@kubernetes/client-node": "^1.0.0",
    "handlebars": "^4.7.8",
    "js-yaml": "^4.1.0"
  },
  "overrides": {
    "tough-cookie": "^4.1.3",
    "@cypress/request": "3.0.8"
  },
  "keybindings": [
    {
      "command": "vscode-eda.filterTree",
      "key": "alt+shift+f",
      "when": ""
    }
  ]
}

=== ./src/commands/index.ts ===
export * from './podCommands';
export * from './refreshCommands';
export * from './viewCommands';
export * from './resourceEditCommands';
export * from './resourceCreateCommand';
export * from './deviationCommands';
export * from './transactionCommands';
export * from './resourceViewCommands';
export * from './clusterCommands';
=== ./src/commands/deviationCommands.ts ===
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';
import { execSync } from 'child_process';
import { KubernetesService } from '../services/kubernetes/kubernetes';
import { log, LogLevel, edaDeviationProvider, edaOutputChannel } from '../extension.js';
import { DeviationResource } from '../services/types';

/**
 * Check if a deviation still exists
 */
async function checkDeviationExists(k8sService: KubernetesService, name: string, namespace: string): Promise<boolean> {
  try {
    const deviations = await k8sService.getEdaDeviations();
    return deviations.some(dev => dev.name === name && dev["namespace.name"] === namespace);
  } catch (error) {
    log(`Error checking if deviation exists: ${error}`, LogLevel.ERROR);
    return true;
  }
}

/**
 * Delete a DeviationAction resource
 */
async function deleteDeviationAction(k8sService: KubernetesService, name: string, namespace: string): Promise<void> {
  try {
    log(`Deleting DeviationAction ${name} in namespace ${namespace}`, LogLevel.INFO);
    const kubectlPath = k8sService.getKubectlPath();
    execSync(`${kubectlPath} delete deviationaction ${name} -n ${namespace}`, { encoding: 'utf-8' });
    log(`Successfully deleted DeviationAction ${name}`, LogLevel.INFO);
  } catch (error) {
    log(`Error deleting DeviationAction: ${error}`, LogLevel.ERROR);
  }
}

/**
 * Register commands for deviation acceptance and rejection
 */
export function registerDeviationCommands(
  context: vscode.ExtensionContext,
  k8sService: KubernetesService
) {
  // Helper function to repeatedly try deleting the deviation action
  async function attemptCleanup(
    name: string,
    namespace: string,
    actionName: string
  ) {
    const maxWaitTime = 60000; // 60 seconds
    const pollInterval = 5000; // every 5 seconds
    const startTime = Date.now();

    async function cleanupLoop() {
      try {
        const deviationExists = await checkDeviationExists(k8sService, name, namespace);
        if (!deviationExists) {
          log(`Deviation ${name} has been successfully handled, deleting DeviationAction...`, LogLevel.INFO);
          await deleteDeviationAction(k8sService, actionName, namespace);
          edaDeviationProvider.removeDeviation(name, namespace);
        } else if (Date.now() - startTime < maxWaitTime) {
          setTimeout(cleanupLoop, pollInterval);
        } else {
          edaDeviationProvider.updateDeviation(name, namespace, "Still processing...");
        }
      } catch (error) {
        log(`Error during deletion cleanup: ${error}`, LogLevel.ERROR);
      }
    }

    // Start checking after 2 seconds
    setTimeout(cleanupLoop, 2000);
  }

  // Register accept deviation command
  const acceptDeviationCmd = vscode.commands.registerCommand('vscode-eda.acceptDeviation', async (treeItem: any) => {
    if (!treeItem?.deviation) {
      vscode.window.showErrorMessage('No deviation selected.');
      return;
    }

    try {
      const deviation = treeItem.deviation;
      const name = deviation.name;
      const namespace = deviation["namespace.name"];
      const actionName = `accept-${name}`;

      log(`Accepting deviation ${name} in namespace ${namespace}`, LogLevel.INFO, true);
      const yamlContent = await k8sService.getResourceYaml('Deviation', name, namespace);
      const fullDeviation = yaml.load(yamlContent) as DeviationResource;

      if (!fullDeviation || !fullDeviation.spec) {
        vscode.window.showErrorMessage(`Failed to get full details for deviation ${name}`);
        return;
      }

      const nodeEndpoint = fullDeviation.spec.nodeEndpoint;
      const path = fullDeviation.spec.path;

      if (!nodeEndpoint || !path) {
        vscode.window.showErrorMessage('Deviation is missing required properties');
        return;
      }

      const acceptResource = {
        apiVersion: 'core.eda.nokia.com/v1',
        kind: 'DeviationAction',
        metadata: {
          name: actionName,
          namespace: namespace
        },
        spec: {
          actions: [
            {
              action: 'setAccept',
              path: path,
              recurse: false
            }
          ],
          nodeEndpoint: nodeEndpoint
        }
      };

      await k8sService.applyResource(acceptResource);
      vscode.window.showInformationMessage(`Deviation ${name} accepted successfully`);
      edaDeviationProvider.updateDeviation(name, namespace, "Processing...");

      // Attempt to clean up the deviation action resource for up to 60 seconds
      attemptCleanup(name, namespace, actionName);

    } catch (error) {
      vscode.window.showErrorMessage(`Failed to accept deviation: ${error}`);
      edaOutputChannel.appendLine(`Error accepting deviation: ${error}`);
    }
  });

  // Register reject deviation command
  const rejectDeviationCmd = vscode.commands.registerCommand('vscode-eda.rejectDeviation', async (treeItem: any) => {
    if (!treeItem?.deviation) {
      vscode.window.showErrorMessage('No deviation selected.');
      return;
    }

    try {
      const deviation = treeItem.deviation;
      const name = deviation.name;
      const namespace = deviation["namespace.name"];
      const actionName = `reject-${name}`;

      log(`Rejecting deviation ${name} in namespace ${namespace}`, LogLevel.INFO, true);
      const yamlContent = await k8sService.getResourceYaml('Deviation', name, namespace);
      const fullDeviation = yaml.load(yamlContent) as DeviationResource;

      if (!fullDeviation || !fullDeviation.spec) {
        vscode.window.showErrorMessage(`Failed to get full details for deviation ${name}`);
        return;
      }

      const nodeEndpoint = fullDeviation.spec.nodeEndpoint;
      const path = fullDeviation.spec.path;

      if (!nodeEndpoint || !path) {
        vscode.window.showErrorMessage('Deviation is missing required properties');
        return;
      }

      const rejectResource = {
        apiVersion: 'core.eda.nokia.com/v1',
        kind: 'DeviationAction',
        metadata: {
          name: actionName,
          namespace: namespace
        },
        spec: {
          actions: [
            {
              action: "reject",
              path: path,
              recurse: false
            }
          ],
          nodeEndpoint: nodeEndpoint
        }
      };

      await k8sService.applyResource(rejectResource);
      vscode.window.showInformationMessage(`Deviation ${name} rejected successfully`);
      edaDeviationProvider.updateDeviation(name, namespace, "Processing...");

      // Attempt to clean up the deviation action resource for up to 60 seconds
      attemptCleanup(name, namespace, actionName);

    } catch (error) {
      vscode.window.showErrorMessage(`Failed to reject deviation: ${error}`);
      edaOutputChannel.appendLine(`Error rejecting deviation: ${error}`);
    }
  });

  context.subscriptions.push(acceptDeviationCmd, rejectDeviationCmd);
}

=== ./src/commands/resourceCreateCommand.ts ===
// src/commands/resourceCreateCommand.ts
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';
import { KubernetesService } from '../services/kubernetes/kubernetes';
import { K8sFileSystemProvider } from '../providers/documents/resourceProvider';
import { log, LogLevel } from '../extension.js';
import { CrdVersion } from '../services/types';

/**
 * Generate a spec object based on a JSON schema
 */
function generateSpecFromSchema(schema: any): any {
  if (!schema || typeof schema !== 'object') {
    return {};
  }

  const result: any = {};

  // If it's an object schema with properties
  if (schema.type === 'object' && schema.properties) {
    for (const [key, prop] of Object.entries<any>(schema.properties)) {
      // For required properties, add a template value
      if (schema.required?.includes(key)) {
        if (prop.type === 'object') {
          result[key] = generateSpecFromSchema(prop);
        } else if (prop.type === 'array') {
          result[key] = [];
        } else if (prop.type === 'string') {
          result[key] = prop.default || '';
        } else if (prop.type === 'number' || prop.type === 'integer') {
          result[key] = prop.default || 0;
        } else if (prop.type === 'boolean') {
          result[key] = prop.default || false;
        }
      }
    }
  }

  return result;
}

/**
 * Generate a mapping of property paths to a comment for optional fields.
 */
function generateOptionalComments(schema: any, prefix: string = ''): Record<string, string> {
  if (!schema || typeof schema !== 'object') {
    return {};
  }

  const result: Record<string, string> = {};

  if (schema.type === 'object' && schema.properties) {
    // Get the required fields for this object (if any)
    const requiredFields: string[] = schema.required || [];

    for (const [key, prop] of Object.entries<any>(schema.properties)) {
      const path = prefix ? `${prefix}.${key}` : key;

      // If the field is not listed in required, mark it as optional.
      if (!requiredFields.includes(key)) {
        result[path] = 'optional';
      }

      // Recursively process nested objects.
      if (prop.type === 'object') {
        Object.assign(result, generateOptionalComments(prop, path));
      }

      // If the property is an array with object items, process the item schema.
      if (prop.type === 'array' && prop.items && prop.items.type === 'object') {
        Object.assign(result, generateOptionalComments(prop.items, `${path}[]`));
      }
    }
  }

  return result;
}


/**
 * Generate a comprehensive spec object based on a JSON schema,
 * including both required and optional fields
 */
function generateDetailedSpecFromSchema(schema: any): any {
  if (!schema || typeof schema !== 'object') {
    return {};
  }

  const result: any = {};

  // If it's an object schema with properties
  if (schema.type === 'object' && schema.properties) {
    for (const [key, prop] of Object.entries<any>(schema.properties)) {
      // Include both required and optional fields
      // Generate value based on type
      if (prop.type === 'object') {
        result[key] = generateDetailedSpecFromSchema(prop);
      }
      else if (prop.type === 'array') {
        // For arrays, if we have items schema defined, include an example item
        if (prop.items) {
          // Add an example item based on the array item schema
          const exampleItem = generateArrayExampleItem(prop.items);
          if (Object.keys(exampleItem).length > 0) {
            result[key] = [exampleItem];
          } else {
            result[key] = [];
          }
        } else {
          result[key] = [];
        }
      }
      else if (prop.type === 'string') {
        if (prop.enum && prop.enum.length > 0) {
          // For enum strings, use the first enum value
          result[key] = prop.enum[0];
        } else if (prop.default !== undefined) {
          result[key] = prop.default;
        } else if (prop.example !== undefined) {
          result[key] = prop.example;
        } else {
          result[key] = '';
        }
      }
      else if (prop.type === 'number' || prop.type === 'integer') {
        result[key] = prop.default !== undefined ? prop.default :
                     (prop.example !== undefined ? prop.example : 0);
      }
      else if (prop.type === 'boolean') {
        result[key] = prop.default !== undefined ? prop.default : false;
      }
      else {
        // For any other type, add an empty value
        result[key] = null;
      }
    }
  }

  return result;
}

/**
 * Generate an example item for an array based on its schema
 */
function generateArrayExampleItem(itemSchema: any): any {
  if (!itemSchema || typeof itemSchema !== 'object') {
    return {};
  }

  if (itemSchema.type === 'string') {
    return itemSchema.enum ? itemSchema.enum[0] : (itemSchema.example || '');
  }

  if (itemSchema.type === 'number' || itemSchema.type === 'integer') {
    return itemSchema.example || 0;
  }

  if (itemSchema.type === 'boolean') {
    return itemSchema.example !== undefined ? itemSchema.example : false;
  }

  if (itemSchema.type === 'object') {
    const result: any = {};

    if (itemSchema.properties) {
      for (const [key, prop] of Object.entries<any>(itemSchema.properties)) {
        // Include all properties for the example
        if (prop.type === 'string') {
          if (prop.enum && prop.enum.length > 0) {
            result[key] = prop.enum[0]; // Use first enum value
          } else {
            result[key] = prop.example || '';
          }
        } else if (prop.type === 'object') {
          result[key] = generateArrayExampleItem(prop);
        } else if (prop.type === 'array') {
          result[key] = [];
        } else if (prop.type === 'number' || prop.type === 'integer') {
          result[key] = prop.example || 0;
        } else if (prop.type === 'boolean') {
          result[key] = prop.example !== undefined ? prop.example : false;
        }
      }
    }

    return result;
  }

  return {};
}

/**
 * Register the command to create a new Kubernetes resource from a CRD definition
 */
export function registerResourceCreateCommand(
  context: vscode.ExtensionContext,
  k8sService: KubernetesService,
  fileSystemProvider: K8sFileSystemProvider
): void {
  const createResourceCommand = vscode.commands.registerCommand(
    'vscode-eda.createResource',
    async () => {
      try {
        log('Creating new resource from CRD...', LogLevel.INFO, true);

        // 1. Get all available CRDs
        const crds = await k8sService.getCRDs();
        if (!crds || crds.length === 0) {
          vscode.window.showErrorMessage('No Custom Resource Definitions found in the cluster');
          return;
        }

        // 2. Create quick pick items with proper grouping and formatting
        const crdItems = crds
          .filter(crd => crd.spec?.names?.kind)
          .map(crd => {
            const group = crd.spec?.group || '';
            const kind = crd.spec?.names?.kind || '';
            const version = crd.spec?.versions?.find((v: CrdVersion) =>
              v.storage === true || v.served === true)?.name || '';

            // Extract a meaningful description from the CRD
            let detailInfo = '';

            // Try to get schema from the active version
            const activeVersion = crd.spec?.versions?.find((v: CrdVersion) =>
              v.storage === true || v.served === true);
            const schema = activeVersion?.schema?.openAPIV3Schema ||
                          (crd.spec as any)?.validation?.openAPIV3Schema;

            // First check if spec property has a detailed description - this is often the most informative
            if (schema?.properties?.spec?.description) {
              const specDesc = schema.properties.spec.description;
              // If the description is very long, extract just the first sentence or truncate it
              const firstSentence = specDesc.split(/\.(?:\s|$)/)[0]; // Get first sentence
              detailInfo = firstSentence.length > 100 ?
                          `${firstSentence.substring(0, 97)}...` :
                          `${firstSentence}.`;
            }
            // Then try the schema top-level description
            else if (schema?.description) {
              const desc = schema.description;
              detailInfo = desc.length > 100 ? `${desc.substring(0, 97)}...` : desc;
            }
            // Look for annotations
            else if (crd.metadata?.annotations?.['description']) {
              detailInfo = crd.metadata.annotations['description'];
            }
            // Last resort: show the resource scope and some additional info
            else {
              const scope = crd.spec?.scope || 'Namespaced';
              const shortNames = crd.spec?.names?.shortNames?.join(', ') || '';
              detailInfo = `${scope} resource${shortNames ? `, Aliases: ${shortNames}` : ''}`;
            }

            return {
              label: kind,
              description: `${group}/${version}`,
              detail: detailInfo,
              group: group.split('.')[0], // Group by first part of the API group
              crd
            };
          })

        // 3. Show quick pick with nice grouping by API group
        const selected = await vscode.window.showQuickPick(crdItems, {
          placeHolder: 'Select a Custom Resource Definition',
          matchOnDescription: true,
          matchOnDetail: true
        });

        if (!selected) {
          return; // User cancelled
        }

        // 4. Get a namespace to create the resource in
        const namespaces = await k8sService.getEdaNamespaces();
        const namespace = await vscode.window.showQuickPick(namespaces, {
          placeHolder: 'Select a namespace for the new resource',
        });

        if (!namespace) {
          return; // User cancelled
        }

        // 5. Ask for a name for the new resource
        const name = await vscode.window.showInputBox({
          placeHolder: 'Enter a name for the new resource',
          validateInput: text => {
            if (!text) {
              return 'Name is required';
            }
            if (!/^[a-z0-9]([-a-z0-9]*[a-z0-9])?$/.test(text)) {
              return 'Name must consist of lowercase alphanumeric characters or "-", and must start and end with an alphanumeric character';
            }
            return null;
          }
        });

        if (!name) {
          return; // User cancelled
        }

        // 6. Generate a skeleton resource based on the schema
        let schema: any = null;
        try {
          schema = await k8sService.getCrdSchemaForKind(selected.label);
        } catch (error) {
          log(`Error getting schema for ${selected.label}: ${error}`, LogLevel.WARN);
          // Continue without schema, we'll create a minimal skeleton
        }

        const kind = selected.label;
        const apiGroup = selected.crd.spec?.group;
        const version = selected.crd.spec?.versions?.find((v: {name: string, storage?: boolean, served?: boolean}) => v.storage === true || v.served === true)?.name || 'v1';
        const apiVersion = `${apiGroup}/${version}`;

        // Create a resource skeleton
        let skeleton = {
          apiVersion,
          kind,
          metadata: {
            name,
            namespace
          },
          spec: {}
        };

        // Generate a comprehensive skeleton with all fields from the schema
        if (schema && schema.properties?.spec) {
          skeleton.spec = generateDetailedSpecFromSchema(schema.properties.spec);
        }

        // Add YAML comments for enum fields where applicable
        let yamlContent = yaml.dump(skeleton, { indent: 2 });

        // Add schema comment at the top for schema validation
        yamlContent = `# yaml-language-server: $schema=/tmp/vscode-k8s-schemas/${kind.toLowerCase()}.json\n${yamlContent}`;

        // Enhance YAML with comments for enum values
        if (schema && schema.properties?.spec) {
          const enumComments = generateEnumComments(schema.properties.spec);
          for (const [path, options] of Object.entries(enumComments)) {
            // Find the line containing the path
            const lines = yamlContent.split('\n');
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].trim().startsWith(path + ':')) {
                // Add comment about available options
                lines[i] = lines[i] + '  # Options: ' + options.join(', ');
                break;
              }
            }
            yamlContent = lines.join('\n');
          }
        }

        if (schema && schema.properties?.spec) {
          const optionalComments = generateOptionalComments(schema.properties.spec);
          for (const [path, comment] of Object.entries(optionalComments)) {
            // Split YAML content into lines.
            const lines = yamlContent.split('\n');
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].trim().startsWith(path + ':')) {
                // Append the optional comment.
                lines[i] = lines[i] + '  # ' + comment;
                break;
              }
            }
            yamlContent = lines.join('\n');
          }
        }

        log(`Created skeleton for ${kind}/${name} in namespace ${namespace}`, LogLevel.INFO);

        // 7. Create a URI for this resource
        const uri = K8sFileSystemProvider.createUri(namespace, kind, name);

        // 8. Store the skeleton resource
        fileSystemProvider.setOriginalResource(uri, skeleton);

        // 9. Convert to YAML and store the content
        fileSystemProvider.setFileContent(uri, Buffer.from(yamlContent, 'utf8'));

        // 10. Open the document and register it
        const document = await vscode.workspace.openTextDocument(uri);
        await vscode.languages.setTextDocumentLanguage(document, 'yaml');
        const editor = await vscode.window.showTextDocument(document);

        // 11. Register close handler for this document
        const closeDisposable = vscode.workspace.onDidCloseTextDocument(doc => {
          if (doc.uri.toString() === uri.toString()) {
            fileSystemProvider.cleanupDocument(uri);
            closeDisposable.dispose();
          }
        });

        // Add to disposables
        context.subscriptions.push(closeDisposable);

      } catch (error) {
        vscode.window.showErrorMessage(`Failed to create resource: ${error}`);
        log(`Error in createResource: ${error}`, LogLevel.ERROR, true);
      }
    }
  );

  /**
 * Generate a mapping of property paths to their enum options
 * for adding comments to the YAML output
 */
function generateEnumComments(schema: any, prefix: string = ''): Record<string, string[]> {
  if (!schema || typeof schema !== 'object') {
    return {};
  }

  const result: Record<string, string[]> = {};

  if (schema.type === 'object' && schema.properties) {
    for (const [key, prop] of Object.entries<any>(schema.properties)) {
      const path = prefix ? `${prefix}.${key}` : key;

      // If this property has enum values, add them to the result
      if (prop.enum && Array.isArray(prop.enum) && prop.enum.length > 0) {
        result[key] = prop.enum;
      }

      // Recursively process nested objects
      if (prop.type === 'object') {
        const nestedResults = generateEnumComments(prop, path);
        Object.assign(result, nestedResults);
      }

      // Handle arrays with object items
      if (prop.type === 'array' && prop.items && prop.items.type === 'object') {
        const nestedResults = generateEnumComments(prop.items, `${path}[]`);
        Object.assign(result, nestedResults);
      }

      // Special case for arrays with items that have enum values
      if (prop.type === 'array' && prop.items && prop.items.properties) {
        for (const [itemKey, itemProp] of Object.entries<any>(prop.items.properties)) {
          if (itemProp.enum && Array.isArray(itemProp.enum) && itemProp.enum.length > 0) {
            result[`${key}[].${itemKey}`] = itemProp.enum;
          }
        }
      }
    }
  }

  return result;
}

  context.subscriptions.push(createResourceCommand);
}
=== ./src/commands/refreshCommands.ts ===
import * as vscode from 'vscode';
import { log, LogLevel, k8sService, resourceStore, edaAlarmProvider, edaDeviationProvider, edaTransactionProvider } from '../extension.js';


/**
 * Registers the refresh commands and sets up auto-refresh.
 * Both manual and automatic refresh routines use the same underlying logic:
 * - Get the list of EDA namespaces (using k8sService.getEdaNamespaces())
 * - Refresh each namespace's resources via resourceStore.loadNamespaceResources()
 * - Also refresh the system namespace ("eda-system")
 * - Refresh all providers (alarms, deviations, transactions)
 */
export function registerRefreshCommands(context: vscode.ExtensionContext) {
  // ---------- Manual Refresh Command ----------
  // Guard flag to prevent overlapping manual refreshes.
  let isManualRefreshInProgress = false;

  const refreshCommand = vscode.commands.registerCommand('vscode-eda.refreshResources', async () => {
    if (isManualRefreshInProgress) {
      log('Manual refresh already in progress, ignoring duplicate trigger.', LogLevel.DEBUG);
      return;
    }
    isManualRefreshInProgress = true;

    vscode.window.showInformationMessage('Manual refresh of resources triggered.');
    log('Manual refresh of resources triggered.', LogLevel.INFO, true);

    try {
      // Deduplicate namespaces in case there are duplicates.
      const namespaces = Array.from(new Set(await k8sService.getEdaNamespaces()));
      await Promise.all(namespaces.map(ns => resourceStore.loadNamespaceResources(ns)));
      
      // Clear any transaction cache to force fresh data
      k8sService.clearTransactionCache();
      
      // Refresh all providers
      edaAlarmProvider.refresh();
      edaDeviationProvider.refresh();
      edaTransactionProvider.refresh();
    } catch (error) {
      vscode.window.showErrorMessage(`Error during manual refresh: ${error}`);
      log(`Error during manual refresh: ${error}`, LogLevel.ERROR, true);
    } finally {
      isManualRefreshInProgress = false;
    }
  });

  context.subscriptions.push(refreshCommand);


  // ---------- Auto Refresh Setup ----------
  const config = vscode.workspace.getConfiguration('vscode-eda');
  const refreshInterval = config.get<number>('refreshInterval', 30000); // default to 30s if not set
  log(`Auto-refresh configured for every ${refreshInterval} ms`, LogLevel.INFO, true);

  const autoRefreshTimer = setInterval(async () => {
    log('Auto-refreshing resources...', LogLevel.DEBUG);
    try {
      const namespaces = await k8sService.getEdaNamespaces();
      await Promise.all(namespaces.map(ns => resourceStore.loadNamespaceResources(ns)));
      
      // Clear any transaction cache to force fresh data
      k8sService.clearTransactionCache();
      
      // Refresh all providers
      edaAlarmProvider.refresh();
      edaDeviationProvider.refresh();
      edaTransactionProvider.refresh();
    } catch (error) {
      log(`Error during auto-refresh: ${error}`, LogLevel.ERROR, true);
    }
  }, refreshInterval);

  // Dispose the timer when the extension is deactivated.
  context.subscriptions.push({
    dispose: () => clearInterval(autoRefreshTimer)
  });
}
=== ./src/commands/clusterCommands.ts ===
// src/commands/clusterCommands.ts
import * as vscode from 'vscode';
import { KubernetesService } from '../services/kubernetes/kubernetes';
import { ClusterManager } from '../services/kubernetes/clusterManager';
import { ResourceStore } from '../services/store/resourceStore';
import { log, LogLevel } from '../extension.js';

/**
 * Registers commands for managing and switching between Kubernetes clusters
 */
export function registerClusterCommands(
  context: vscode.ExtensionContext,
  k8sService: KubernetesService,
  clusterManager: ClusterManager,
  resourceStore: ResourceStore
) {
  // Register the switch cluster command
  const switchClusterCommand = vscode.commands.registerCommand(
    'vscode-eda.switchCluster',
    async () => {
      const clusters = clusterManager.getAvailableContexts();
      if (clusters.length === 0) {
        vscode.window.showErrorMessage('No Kubernetes clusters found in kubeconfig');
        return;
      }

      const currentContext = k8sService.getCurrentContext();
      const selectedCluster = await vscode.window.showQuickPick(
        clusters.map(cluster => ({
          label: cluster,
          description: cluster === currentContext ? '(current)' : '',
        })),
        {
          placeHolder: 'Select a Kubernetes cluster',
          title: 'Switch Kubernetes Cluster'
        }
      );

      if (selectedCluster && selectedCluster.label !== currentContext) {
        try {
          vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: `Switching to cluster ${selectedCluster.label}`,
            cancellable: false
          }, async (progress) => {
            progress.report({ increment: 0 });

            const success = await clusterManager.switchContext(selectedCluster.label);

            if (success) {
              // Clear all caches and refresh all providers
              k8sService.clearAllCaches();
              await resourceStore.refreshAll();

              vscode.window.showInformationMessage(`Switched to cluster ${selectedCluster.label}`);
            } else {
              vscode.window.showErrorMessage(`Failed to switch to cluster ${selectedCluster.label}`);
            }

            progress.report({ increment: 100 });
          });
        } catch (error) {
          vscode.window.showErrorMessage(`Error switching clusters: ${error}`);
        }
      }
    }
  );



  context.subscriptions.push(switchClusterCommand);
}
=== ./src/commands/podCommands.ts ===
import * as vscode from 'vscode';
import { KubernetesService } from '../services/kubernetes/kubernetes';
import { edaOutputChannel } from '../extension.js';
import { PodDescribeDocumentProvider } from '../providers/documents/podDescribeProvider';

export function registerPodCommands(
  context: vscode.ExtensionContext,
  k8sService: KubernetesService,
  podDescribeProvider: PodDescribeDocumentProvider
) {
  // 1) Delete Pod
  const deletePodCmd = vscode.commands.registerCommand('vscode-eda.deletePod', async (treeItem) => {
    if (!treeItem || !treeItem.resource) {
      vscode.window.showErrorMessage('No pod available to delete.');
      return;
    }
    const pod = treeItem.resource;
    const ns = pod.metadata.namespace;
    const name = pod.metadata.name;

    const confirmed = await vscode.window.showWarningMessage(
      `Delete Pod '${name}' in namespace '${ns}'? This action is irreversible.`,
      { modal: true },
      'Yes'
    );
    if (confirmed === 'Yes') {
      try {
        await k8sService.deletePod(ns, name);
        vscode.window.showInformationMessage(`Pod '${name}' deleted successfully.`);
      } catch (err: any) {
        vscode.window.showErrorMessage(err.message);
      }
    }
  });

  // 2) Open Terminal (shell) in Pod
  const terminalPodCmd = vscode.commands.registerCommand('vscode-eda.terminalPod', async (treeItem) => {
    if (!treeItem || !treeItem.resource) {
      vscode.window.showErrorMessage('No pod available for terminal.');
      return;
    }
    const pod = treeItem.resource;
    const ns = pod.metadata.namespace;
    const name = pod.metadata.name;

    // Create a new VS Code Terminal that runs `kubectl exec -it`
    const term = vscode.window.createTerminal({
      name: `Shell: ${name}`,
      shellPath: 'kubectl',
      shellArgs: ['exec', '-it', '-n', ns, name, '--', '/bin/sh']
    });
    term.show();
  });

  // 3) View Logs in a new Terminal
  const logsPodCmd = vscode.commands.registerCommand('vscode-eda.logsPod', async (treeItem) => {
    if (!treeItem || !treeItem.resource) {
      vscode.window.showErrorMessage('No pod available for logs.');
      return;
    }
    const pod = treeItem.resource;
    const ns = pod.metadata.namespace;
    const name = pod.metadata.name;

  // Create a new Terminal that runs `kubectl logs` with follow mode (-f)
  const term = vscode.window.createTerminal({
      name: `Logs: ${name}`,
      shellPath: 'kubectl',
      shellArgs: ['logs', '-f', '--tail=100', '-n', ns, name]
    });
    term.show();
  });

  // 4) Describe Pod in a read-only doc
  const describePodCmd = vscode.commands.registerCommand('vscode-eda.describePod', async (treeItem) => {
    if (!treeItem || !treeItem.resource) {
      vscode.window.showErrorMessage('No pod available to describe.');
      return;
    }
    const pod = treeItem.resource;
    const ns = pod.metadata.namespace;
    const name = pod.metadata.name;

    try {
      // 1) Get "describe" text via kubectl
      const describeOutput = k8sService.getPodDescribeOutput(ns, name);

      // 2) Construct a "k8s-describe:" URI (with a random query param)
      //    so each time you call "describePod" for that pod, it refreshes
      const docUri = vscode.Uri.parse(`k8s-describe:/${ns}/${name}?ts=${Date.now()}`);

      // 3) Store the output in the read-only provider
      podDescribeProvider.setDescribeContent(docUri, describeOutput);

      // 4) Open the doc
      const doc = await vscode.workspace.openTextDocument(docUri);

      // 5) Force log syntax highlighting
      await vscode.languages.setTextDocumentLanguage(doc, 'log');

      await vscode.window.showTextDocument(doc, { preview: false });
    } catch (err: any) {
      vscode.window.showErrorMessage(`Failed to describe pod: ${err.message || err}`);
    }
  });

  context.subscriptions.push(deletePodCmd, terminalPodCmd, logsPodCmd, describePodCmd);
}
=== ./src/commands/transactionCommands.ts ===
import * as vscode from 'vscode';
import { KubernetesService } from '../services/kubernetes/kubernetes';
import { edaOutputChannel } from '../extension.js';
import { log, LogLevel } from '../extension.js';

/**
 * Registers commands for managing EDA transactions (revert and restore)
 */
export function registerTransactionCommands(
  context: vscode.ExtensionContext,
  k8sService: KubernetesService
) {
  // Command to revert a transaction (undoing changes)
  const revertTransactionCmd = vscode.commands.registerCommand(
    'vscode-eda.revertTransaction',
    async (treeItem) => {
      if (!treeItem?.resource?.id) {
        vscode.window.showErrorMessage('No transaction ID available.');
        return;
      }

      const transactionId = treeItem.resource.id;

      // Fetch transaction details to get commit hash
      try {
        const details = await k8sService.getEdaTransactionDetails(transactionId);

        // Extract commit hash using regex
        const match = details.match(/commit-hash:\s*([a-f0-9]+)/i);
        if (!match || !match[1]) {
          vscode.window.showErrorMessage(`Could not find commit hash for transaction ${transactionId}`);
          return;
        }

        const commitHash = match[1];
        log(`Found commit hash ${commitHash} for transaction ${transactionId}`, LogLevel.INFO);

        // Confirm with user
        const confirmed = await vscode.window.showWarningMessage(
          `Are you sure you want to revert transaction ${transactionId}?\nThis will undo changes from commit ${commitHash.substring(0, 8)}`,
          { modal: true },
          'Yes', 'No'
        );

        if (confirmed === 'Yes') {
          try {
            log(`Executing revert for transaction ${transactionId} (${commitHash})`, LogLevel.INFO, true);

            // Execute revert command via edactl
            const output = await k8sService.revertTransaction(commitHash);

            vscode.window.showInformationMessage(`Transaction ${transactionId} reverted successfully.`);
            edaOutputChannel.appendLine(`Revert Transaction ${transactionId} (${commitHash}) output:\n${output}`);
            edaOutputChannel.show();
          } catch (err: any) {
            const errMsg = `Failed to revert transaction: ${err.message || err}`;
            vscode.window.showErrorMessage(errMsg);
            log(errMsg, LogLevel.ERROR, true);
          }
        }
      } catch (err: any) {
        const errMsg = `Failed to fetch transaction details: ${err.message || err}`;
        vscode.window.showErrorMessage(errMsg);
        log(errMsg, LogLevel.ERROR, true);
      }
    }
  );

  // Command to restore a transaction (reapplying changes)
  const restoreTransactionCmd = vscode.commands.registerCommand(
    'vscode-eda.restoreTransaction',
    async (treeItem) => {
      if (!treeItem?.resource?.id) {
        vscode.window.showErrorMessage('No transaction ID available.');
        return;
      }

      const transactionId = treeItem.resource.id;

      // Fetch transaction details to get commit hash
      try {
        const details = await k8sService.getEdaTransactionDetails(transactionId);

        // Extract commit hash using regex
        const match = details.match(/commit-hash:\s*([a-f0-9]+)/i);
        if (!match || !match[1]) {
          vscode.window.showErrorMessage(`Could not find commit hash for transaction ${transactionId}`);
          return;
        }

        const commitHash = match[1];
        log(`Found commit hash ${commitHash} for transaction ${transactionId}`, LogLevel.INFO);

        // Confirm with user
        const confirmed = await vscode.window.showWarningMessage(
          `Are you sure you want to restore transaction ${transactionId}?\nThis will reapply changes from commit ${commitHash.substring(0, 8)}`,
          { modal: true },
          'Yes', 'No'
        );

        if (confirmed === 'Yes') {
          try {
            log(`Executing restore for transaction ${transactionId} (${commitHash})`, LogLevel.INFO, true);

            // Execute restore command via edactl
            const output = await k8sService.restoreTransaction(commitHash);

            vscode.window.showInformationMessage(`Transaction ${transactionId} restored successfully.`);
            edaOutputChannel.appendLine(`Restore Transaction ${transactionId} (${commitHash}) output:\n${output}`);
            edaOutputChannel.show();
          } catch (err: any) {
            const errMsg = `Failed to restore transaction: ${err.message || err}`;
            vscode.window.showErrorMessage(errMsg);
            log(errMsg, LogLevel.ERROR, true);
          }
        }
      } catch (err: any) {
        const errMsg = `Failed to fetch transaction details: ${err.message || err}`;
        vscode.window.showErrorMessage(errMsg);
        log(errMsg, LogLevel.ERROR, true);
      }
    }
  );

  // Add commands to subscriptions for cleanup
  context.subscriptions.push(revertTransactionCmd, restoreTransactionCmd);
}
=== ./src/commands/viewCommands.ts ===
// src/commands/viewCommands.ts (using improved template loader)
import * as vscode from 'vscode';
import { KubernetesService } from '../services/kubernetes/kubernetes';
import { edaOutputChannel } from '../extension.js';
import { CrdDefinitionFileSystemProvider } from '../providers/documents/crdDefinitionProvider';
import { TransactionDetailsDocumentProvider } from '../providers/documents/transactionDetailsProvider';
import { alarmDetailsProvider, deviationDetailsProvider } from '../extension.js';
import { loadTemplate } from '../utils/templateLoader';

export function registerViewCommands(
  context: vscode.ExtensionContext,
  k8sService: KubernetesService,
  crdFsProvider: CrdDefinitionFileSystemProvider,
  transactionDetailsProvider?: TransactionDetailsDocumentProvider
) {
  // Show transaction details command (unchanged)
  const showTransactionDetailsCommand = vscode.commands.registerCommand(
    'vscode-eda.showTransactionDetails',
    async (transactionId: string) => {
      if (!transactionId) {
        vscode.window.showErrorMessage('No transaction ID provided.');
        return;
      }

      try {
        // 1) Retrieve text from "edactl transaction <id>" (or your existing method)
        const detailsText = await k8sService.getEdaTransactionDetails(transactionId);

        // If no read-only provider was given, fallback to older approach
        if (!transactionDetailsProvider) {
          // fallback: open ephemeral doc
          const doc = await vscode.workspace.openTextDocument({
            content: detailsText,
            language: 'yaml'
          });
          await vscode.window.showTextDocument(doc, { preview: false });
          return;
        }

        // 2) Create a "eda-transaction:" URI for read-only
        const docUri = vscode.Uri.parse(
          `eda-transaction:/${transactionId}?ts=${Date.now()}`
        );

        // 3) Store the text in the read-only provider
        transactionDetailsProvider.setTransactionContent(docUri, detailsText);

        // 4) Open the doc
        const doc = await vscode.workspace.openTextDocument(docUri);

        // 5) Optionally force syntax highlighting:
        // "log" is a good approximation for this multiline text
        // or "plaintext" if you prefer
        await vscode.languages.setTextDocumentLanguage(doc, 'log');

        await vscode.window.showTextDocument(doc, { preview: false });
      } catch (err: any) {
        const msg = `Failed to load transaction details for ID ${transactionId}: ${err.message}`;
        vscode.window.showErrorMessage(msg);
        edaOutputChannel.appendLine(msg);
      }
    }
  );

  // Show CRD Definition command (unchanged)
  const showCRDDefinitionCommand = vscode.commands.registerCommand('vscode-eda.showCRDDefinition', async (treeItem: any) => {
    try {
      if (!treeItem?.resource?.kind) {
        vscode.window.showErrorMessage('No CRD instance or missing kind.');
        return;
      }
      const { kind } = treeItem.resource;

      // 1) Get the YAML from k8sService (using --show-managed-fields=false)
      const crdYaml = await k8sService.getCrdYamlForKind(kind);

      // 2) Create a unique crd: URI
      //    e.g. crd:/Interface?random=...
      //    If multiple CRDs share the same kind, we can add a random query param
      const crdUri = vscode.Uri.parse(`crd:/${kind}?ts=${Date.now()}`);

      // 3) Store the YAML in the read-only FS
      crdFsProvider.setCrdYaml(crdUri, crdYaml);

      // 4) Open the doc
      const doc = await vscode.workspace.openTextDocument(crdUri);

      // 5) Force YAML highlighting (in case VS Code doesn't auto-detect)
      await vscode.languages.setTextDocumentLanguage(doc, 'yaml');

      await vscode.window.showTextDocument(doc, { preview: false });
    } catch (error: any) {
      vscode.window.showErrorMessage(`Failed to show CRD definition: ${error.message || error}`);
      edaOutputChannel.appendLine(`Error showing CRD definition: ${error}`);
    }
  });

  // Show alarm details using Handlebars template
  vscode.commands.registerCommand('vscode-eda.showAlarmDetails', async (arg: any) => {
    const alarm = arg && arg.alarm ? arg.alarm : arg;
    if (!alarm) {
      vscode.window.showErrorMessage('No alarm details available.');
      return;
    }

    try {
      // Determine severity color
      const severity = alarm.severity ? alarm.severity.toLowerCase() : 'info';
      let severityColor = '#3498DB'; // blue (default)
      switch (severity) {
        case 'critical':
          severityColor = '#E74C3C'; // red
          break;
        case 'major':
          severityColor = '#E67E22'; // orange
          break;
        case 'minor':
          severityColor = '#F1C40F'; // yellow
          break;
      }

      // Prepare variables for the template
      const templateVars = {
        name: alarm.name,
        kind: alarm.kind,
        type: alarm.type,
        severity: alarm.severity,
        severityColor,
        namespace: alarm["namespace.name"],
        group: alarm.group,
        sourceGroup: alarm.sourceGroup,
        sourceKind: alarm.sourceKind,
        sourceResource: alarm.sourceResource,
        jspath: alarm.jspath,
        parentAlarm: alarm.parentAlarm || 'N/A',
        probableCause: alarm.probableCause,
        remedialAction: alarm.remedialAction,
        description: alarm.description,
        resource: alarm.resource,
        clusterSpecific: alarm.clusterSpecific || 'N/A'
      };

      // Render the template
      const detailsText = loadTemplate('alarm', context, templateVars);

      // Create a unique URI for this alarm document
      const docUri = vscode.Uri.parse(`eda-alarm:/${alarm.name}?ts=${Date.now()}`);
      alarmDetailsProvider.setAlarmContent(docUri, detailsText);

      // Open the markdown preview
      await vscode.commands.executeCommand("markdown.showPreview", docUri);
    } catch (error: any) {
      vscode.window.showErrorMessage(`Failed to load alarm details: ${error.message || error}`);
    }
  });


  // Show deviation details using markdown template
  vscode.commands.registerCommand('vscode-eda.showDeviationDetails', async (deviation: any) => {
    if (!deviation) {
      vscode.window.showErrorMessage('No deviation details available.');
      return;
    }

    try {
      const name = deviation.name;
      const kind = deviation.kind || 'Deviation';
      const namespace = deviation["namespace.name"];

      // Prepare base template variables
      const templateVars: Record<string, any> = {
        name: deviation.name,
        kind: deviation.kind || 'Deviation',
        apiVersion: deviation.apiVersion || 'v1',
        namespace: deviation["namespace.name"]
      };

      try {
        // Fetch the YAML for the deviation
        const resourceYaml = await k8sService.getResourceYaml(kind, name, namespace);
        templateVars.resourceYaml = resourceYaml;
      } catch (error) {
        // Add error message if we couldn't get the YAML
        templateVars.errorMessage = error instanceof Error ? error.message : String(error);
      }

      // Load and process the template using Handlebars
      const detailsText = loadTemplate('deviation', context, templateVars);

      // Create a unique URI for this deviation document
      const docUri = vscode.Uri.parse(`eda-deviation:/${name}?ts=${Date.now()}`);
      deviationDetailsProvider.setDeviationContent(docUri, detailsText);

      // Open markdown preview
      await vscode.commands.executeCommand("markdown.showPreview", docUri);
    } catch (error: any) {
      vscode.window.showErrorMessage(`Failed to load deviation details: ${error.message || error}`);
    }
  });
}
=== ./src/commands/resourceEditCommands.ts ===
// src/commands/resourceEditCommands.ts
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';
import { KubernetesService } from '../services/kubernetes/kubernetes';
import { K8sFileSystemProvider } from '../providers/documents/resourceProvider';
import { log, LogLevel, edaOutputChannel } from '../extension.js';

// Keep track of open resource editors
const openResourceEditors = new Set<string>();

// Store last command execution timestamp to prevent rapid multiple executions
let lastCommandTime = 0;
const COMMAND_DEBOUNCE_MS = 300; // Prevent multiple executions within 300ms

// Define interface for our custom quick pick items
interface ActionQuickPickItem extends vscode.QuickPickItem {
  id: string;
}

export function registerResourceEditCommands(
  context: vscode.ExtensionContext,
  k8sService: KubernetesService,
  fileSystemProvider: K8sFileSystemProvider,
  providers?: {
    namespaceProvider?: any;
    systemProvider?: any;
    transactionProvider?: any;
  }
) {
  // Edit resource in editor - accept either tree item or direct resource parameters
  const editResourceCommand = vscode.commands.registerCommand(
    'vscode-eda.editResource',
    async (treeItemOrResourceInfo: any) => {
      // Debounce protection for multiple rapid calls
      const now = Date.now();
      if (now - lastCommandTime < COMMAND_DEBOUNCE_MS) {
        log(`Command execution debounced (${now - lastCommandTime}ms since last call)`, LogLevel.DEBUG);
        return;
      }
      lastCommandTime = now;

      try {
        let resource, resourceKind, resourceName, namespace;

        // Handle two ways of calling this command:
        // 1. With a tree item that has resource property
        // 2. With a plain object containing resource data

        if (treeItemOrResourceInfo?.resource) {
          // Called with a tree item
          resource = treeItemOrResourceInfo.resource;
          resourceKind = resource.kind || 'Resource';
          resourceName = resource.metadata?.name || 'unnamed';
          namespace = resource.metadata?.namespace || treeItemOrResourceInfo.namespace || 'default';
        }
        else if (treeItemOrResourceInfo?.kind && treeItemOrResourceInfo?.name) {
          // Called with direct parameters
          resourceKind = treeItemOrResourceInfo.kind;
          resourceName = treeItemOrResourceInfo.name;
          namespace = treeItemOrResourceInfo.namespace || 'default';

          // We need to fetch the resource
          log(`Fetching ${resourceKind}/${resourceName} from ${namespace} for editing...`, LogLevel.INFO);
          let yamlContent = await k8sService.getResourceYaml(resourceKind, resourceName, namespace);

          // Check if the YAML has apiVersion (might be missing in edactl output)
          const hasApiVersion = yamlContent.includes('apiVersion:');

          if (!hasApiVersion) {
            log(`YAML for ${resourceKind}/${resourceName} is missing apiVersion, fetching from CRD definition...`, LogLevel.INFO);

            try {
              // Get the CRD definition directly from the Kubernetes service
              const crdDef = await k8sService.getCrdDefinitionForKind(resourceKind);

              if (crdDef && crdDef.spec?.group) {
                // Get the preferred version (storage: true, or first served version)
                const version = crdDef.spec.versions?.find(v => v.storage === true) ||
                              crdDef.spec.versions?.find(v => v.served === true) ||
                              crdDef.spec.versions?.[0];

                if (version?.name) {
                  const apiVersion = `${crdDef.spec.group}/${version.name}`;
                  log(`Found API version for ${resourceKind}: ${apiVersion}`, LogLevel.INFO);
                  yamlContent = `apiVersion: ${apiVersion}\n${yamlContent}`;
                } else {
                  log(`Could not determine version for ${resourceKind} from CRD, falling back to v1alpha1`, LogLevel.WARN);
                  yamlContent = `apiVersion: ${crdDef.spec.group}/v1alpha1\n${yamlContent}`;
                }
              } else {
                // For standard Kubernetes resources
                const k8sResources: Record<string, string> = {
                  'Pod': 'v1',
                  'Service': 'v1',
                  'Deployment': 'apps/v1',
                  'ConfigMap': 'v1',
                  'Secret': 'v1',
                  'Node': 'v1'
                };

                if (k8sResources[resourceKind]) {
                  yamlContent = `apiVersion: ${k8sResources[resourceKind]}\n${yamlContent}`;
                } else {
                  log(`Could not find CRD for ${resourceKind}, using fallback`, LogLevel.WARN);
                  yamlContent = `apiVersion: ${resourceKind.toLowerCase()}s.eda.nokia.com/v1alpha1\n${yamlContent}`;
                }
              }
            } catch (error) {
              log(`Error fetching CRD for ${resourceKind}: ${error}`, LogLevel.ERROR);
              // Last resort fallback - this should rarely be reached since we're fixing the issue at its source
              yamlContent = `apiVersion: ${resourceKind.toLowerCase()}s.eda.nokia.com/v1alpha1\n${yamlContent}`;
            }
          }

          try {
            resource = yaml.load(yamlContent);

            // Create a URI for this resource
            const uri = K8sFileSystemProvider.createUri(namespace, resourceKind, resourceName);

            // Store both the resource and the YAML content to avoid duplicate fetching
            fileSystemProvider.setOriginalResource(uri, resource);
            fileSystemProvider.setFileContent(uri, Buffer.from(yamlContent, 'utf8'));
          } catch (error) {
            log(`Failed to parse resource YAML: ${error}`, LogLevel.ERROR);
            vscode.window.showErrorMessage(`Failed to parse resource YAML: ${error}`);
            return;
          }
        }

        if (!resource || !resourceKind || !resourceName) {
          vscode.window.showErrorMessage('Invalid resource parameters');
          return;
        }

        // Create a URI for this resource
        const uri = K8sFileSystemProvider.createUri(namespace, resourceKind, resourceName);

        // Store the original resource
        fileSystemProvider.setOriginalResource(uri, resource);

        // Open the document and register it
        const document = await vscode.workspace.openTextDocument(uri);
        await vscode.languages.setTextDocumentLanguage(document, 'yaml');
        const editor = await vscode.window.showTextDocument(document);

        // Track this resource document
        openResourceEditors.add(uri.toString());

        // Register close handler for this document
        const closeDisposable = vscode.workspace.onDidCloseTextDocument(doc => {
          if (doc.uri.toString() === uri.toString()) {
            fileSystemProvider.cleanupDocument(uri);
            openResourceEditors.delete(uri.toString());
            closeDisposable.dispose();
          }
        });

        // Add to disposables
        context.subscriptions.push(closeDisposable);

      } catch (error) {
        vscode.window.showErrorMessage(`Failed to edit resource: ${error}`);
        log(`Error in editResource: ${error}`, LogLevel.ERROR, true);
      }
    }
  );

  // Apply changes to a resource - modified to support new interactive flow
  const applyChangesCommand = vscode.commands.registerCommand(
    'vscode-eda.applyResourceChanges',
    async (documentUri: vscode.Uri, options: {
      dryRun?: boolean;
      skipPrompt?: boolean;
      bypassChangesCheck?: boolean;
    } = {}) => {
      try {
        // Debounce protection for multiple rapid calls
        const now = Date.now();
        if (now - lastCommandTime < COMMAND_DEBOUNCE_MS) {
          log(`Command execution debounced (${now - lastCommandTime}ms since last call)`, LogLevel.DEBUG);
          return;
        }
        lastCommandTime = now;

        // Get the document by URI
        const document = await vscode.workspace.openTextDocument(documentUri);
        const docText = document.getText();

        // Make sure this is our k8s resource document
        if (documentUri.scheme !== 'k8s') {
          vscode.window.showErrorMessage('Not a Kubernetes resource document');
          return;
        }

        // Parse the YAML
        let resource: any;
        try {
          resource = yaml.load(docText);
        } catch (yamlError) {
          vscode.window.showErrorMessage(`YAML validation error: ${yamlError}`);
          return;
        }

        // Get the original resource
        const originalResource = fileSystemProvider.getOriginalResource(documentUri);
        if (!originalResource) {
          throw new Error('Could not find original resource data');
        }

        // Validate the resource
        const validationResult = validateResource(resource, originalResource);
        if (!validationResult.valid) {
          vscode.window.showErrorMessage(`Validation error: ${validationResult.message}`);
          return;
        }

        // Check if there are changes to the resource (unless bypassed)
        const hasChanges = options.bypassChangesCheck ?
          true : await fileSystemProvider.hasChanges(documentUri);

        if (!hasChanges) {
          vscode.window.showInformationMessage('No changes detected in the resource');
          return;
        }

        // If we have an explicit option (dry run or direct apply), skip the initial prompt
        if (options.skipPrompt) {
          if (options.dryRun) {
            return await validateAndPromptForApply(k8sService, fileSystemProvider, documentUri, resource, providers);
          } else {
            // Direct apply - still show diff first
            const shouldContinue = await showResourceDiff(fileSystemProvider, documentUri);
            if (!shouldContinue) {
              return;
            }

            // Confirm and apply
            const confirmed = await confirmResourceUpdate(resource.kind, resource.metadata?.name, false);
            if (confirmed) {
              const result = await applyResource(k8sService, resource, { dryRun: false }, providers);
              if (result) {
                fileSystemProvider.setOriginalResource(documentUri, resource);
                vscode.window.showInformationMessage(`Successfully applied ${resource.kind} "${resource.metadata?.name}"`,
                  'View Details').then(selection => {
                    if (selection === 'View Details') {
                      edaOutputChannel.show();
                    }
                  });
              }
            }
            return;
          }
        }

        // Present options to the user
        const action = await promptForApplyAction(resource);

        if (!action) {
          return; // User cancelled
        }

        if (action === 'diff') {
          // Show diff and then ask for validate or direct apply
          const shouldContinue = await showResourceDiff(fileSystemProvider, documentUri);
          if (!shouldContinue) {
            return;
          }

          // After showing diff, ask if user wants to validate or direct apply
          const nextAction = await promptForNextAction(resource, 'diff');
          if (!nextAction) {
            return; // User cancelled
          }

          if (nextAction === 'validate') {
            // Validate and then ask for apply
            return await validateAndPromptForApply(k8sService, fileSystemProvider, documentUri, resource, providers);
          } else {
            // Direct apply after diff
            const confirmed = await confirmResourceUpdate(resource.kind, resource.metadata?.name, false);
            if (confirmed) {
              const result = await applyResource(k8sService, resource, { dryRun: false }, providers);
              if (result) {
                fileSystemProvider.setOriginalResource(documentUri, resource);
                vscode.window.showInformationMessage(`Successfully applied ${resource.kind} "${resource.metadata?.name}"`,
                  'View Details').then(selection => {
                    if (selection === 'View Details') {
                      edaOutputChannel.show();
                    }
                  });
              }
            }
          }
        } else if (action === 'validate') {
          // Validate and then ask for apply
          return await validateAndPromptForApply(k8sService, fileSystemProvider, documentUri, resource, providers);
        } else {
          // Direct apply - still show diff first as a safeguard
          const shouldContinue = await showResourceDiff(fileSystemProvider, documentUri);
          if (!shouldContinue) {
            return;
          }

          // Confirm and apply
          const confirmed = await confirmResourceUpdate(resource.kind, resource.metadata?.name, false);
          if (confirmed) {
            const result = await applyResource(k8sService, resource, { dryRun: false }, providers);
            if (result) {
              fileSystemProvider.setOriginalResource(documentUri, resource);
              vscode.window.showInformationMessage(`Successfully applied ${resource.kind} "${resource.metadata?.name}"`,
                'View Details').then(selection => {
                  if (selection === 'View Details') {
                    edaOutputChannel.show();
                  }
                });
            }
          }
        }

      } catch (error) {
        vscode.window.showErrorMessage(`Failed to apply changes: ${error}`);
        log(`Error in applyResourceChanges: ${error}`, LogLevel.ERROR, true);
        // Always show output channel on error
        edaOutputChannel.show();
      }
    }
  );

  // Add separate command for dry run with different icon
  const applyDryRunCommand = vscode.commands.registerCommand(
    'vscode-eda.applyResourceChanges.dryRun',
    async (documentUri: vscode.Uri) => {
      // Just call the main apply command with dryRun flag
      return vscode.commands.executeCommand('vscode-eda.applyResourceChanges',
        documentUri, { dryRun: true, skipPrompt: true });
    }
  );

  // Show diff between original and modified resource
  const showDiffCommand = vscode.commands.registerCommand(
    'vscode-eda.showResourceDiff',
    async (documentUri: vscode.Uri) => {
      await showResourceDiff(fileSystemProvider, documentUri);
    }
  );

  // Add a save handler to intercept standard save - MODIFIED FOR BETTER SAVE HANDLING
  const onWillSaveTextDocument = vscode.workspace.onWillSaveTextDocument(event => {
    if (event.document.uri.scheme === 'k8s') {
      // This prevents the default save operation
      event.waitUntil(Promise.resolve([]));

      // Use a very short timeout to ensure the UI is responsive
      setTimeout(() => {
        // Always bypass the changes check when triggered by save
        vscode.commands.executeCommand('vscode-eda.applyResourceChanges',
          event.document.uri,
          { bypassChangesCheck: true });
      }, 10);
    }
  });

  context.subscriptions.push(
    editResourceCommand,
    applyChangesCommand,
    applyDryRunCommand,
    showDiffCommand,
    onWillSaveTextDocument
  );
}

// Prompt user for what action they want to take with the resource
async function promptForApplyAction(resource: any): Promise<string | undefined> {
  const kind = resource.kind;
  const name = resource.metadata?.name;

  const choices: ActionQuickPickItem[] = [
    { label: ' View Changes (Diff)', id: 'diff', description: 'Compare changes before proceeding' },
    { label: ' Validate (Dry Run)', id: 'validate', description: 'Check if changes are valid without applying' },
    { label: ' Apply Changes', id: 'apply', description: 'Apply changes to the cluster' }
  ];

  const chosen = await vscode.window.showQuickPick(choices, {
    placeHolder: `Choose an action for ${kind} "${name}"`,
    title: 'Apply Resource Changes'
  });

  return chosen?.id;
}

// Prompt for next action after diff
async function promptForNextAction(resource: any, currentStep: string): Promise<string | undefined> {
  const kind = resource.kind;
  const name = resource.metadata?.name;

  let choices: ActionQuickPickItem[] = [];
  if (currentStep === 'diff') {
    choices = [
      { label: ' Validate (Dry Run)', id: 'validate', description: 'Check if changes are valid without applying' },
      { label: ' Apply Changes', id: 'apply', description: 'Apply changes to the cluster' }
    ];
  } else if (currentStep === 'validate') {
    choices = [
      { label: ' Apply Changes', id: 'apply', description: 'Apply changes to the cluster' }
    ];
  }

  const chosen = await vscode.window.showQuickPick(choices, {
    placeHolder: `Choose next action for ${kind} "${name}"`,
    title: 'Apply Resource Changes'
  });

  return chosen?.id;
}

// Validate and then prompt for apply
async function validateAndPromptForApply(
  k8sService: KubernetesService,
  fileSystemProvider: K8sFileSystemProvider,
  documentUri: vscode.Uri,
  resource: any,
  providers?: {
    namespaceProvider?: any;
    systemProvider?: any;
    transactionProvider?: any;
  }
): Promise<void> {
  // Always show diff first
  const shouldContinue = await showResourceDiff(fileSystemProvider, documentUri);
  if (!shouldContinue) {
    return;
  }

  // Confirm validation
  const confirmed = await confirmResourceUpdate(resource.kind, resource.metadata?.name, true);
  if (!confirmed) {
    return;
  }

  // Perform validation (dry run)
  const validationResult = await applyResource(k8sService, resource, { dryRun: true }, providers);

  if (validationResult) {
    // Show success message for validation
    const validationAction = await vscode.window.showInformationMessage(
      ` Validation successful for ${resource.kind} "${resource.metadata?.name}"`,
      'Apply Changes', 'View Details', 'Cancel'
    );

    if (validationAction === 'Apply Changes') {
      // Now apply the changes
      const applyResult = await applyResource(k8sService, resource, { dryRun: false }, providers);
      if (applyResult) {
        fileSystemProvider.setOriginalResource(documentUri, resource);
        vscode.window.showInformationMessage(`Successfully applied ${resource.kind} "${resource.metadata?.name}"`,
          'View Details').then(selection => {
            if (selection === 'View Details') {
              edaOutputChannel.show();
            }
          });
      }
    } else if (validationAction === 'View Details') {
      edaOutputChannel.show();
    }
  }
}

// Validate the resource for basic errors
interface ValidationResult {
  valid: boolean;
  message?: string;
}

function validateResource(resource: any, originalResource: any): ValidationResult {
  // Check for required fields
  if (!resource) {
    return { valid: false, message: 'Resource is empty or invalid' };
  }

  if (!resource.kind) {
    return { valid: false, message: 'Resource kind is missing' };
  }

  if (!resource.metadata) {
    return { valid: false, message: 'Resource metadata is missing' };
  }

  if (!resource.metadata.name) {
    return { valid: false, message: 'Resource name is missing' };
  }

  // Check that the resource kind and name match the original
  if (resource.kind !== originalResource.kind) {
    return {
      valid: false,
      message: `Cannot change resource kind from "${originalResource.kind}" to "${resource.kind}"`
    };
  }

  if (resource.metadata.name !== originalResource.metadata.name) {
    return {
      valid: false,
      message: `Cannot change resource name from "${originalResource.metadata.name}" to "${resource.metadata.name}"`
    };
  }

  // Check that the namespace matches (if present)
  if (originalResource.metadata.namespace &&
      resource.metadata.namespace !== originalResource.metadata.namespace) {
    return {
      valid: false,
      message: `Cannot change resource namespace from "${originalResource.metadata.namespace}" to "${resource.metadata.namespace}"`
    };
  }

  return { valid: true };
}

// Show a unified diff view of the changes
async function showResourceDiff(
  fileSystemProvider: K8sFileSystemProvider,
  documentUri: vscode.Uri
): Promise<boolean> {
  try {
    // Get the original resource
    const originalResource = fileSystemProvider.getOriginalResource(documentUri);
    if (!originalResource) {
      vscode.window.showErrorMessage('Could not find original resource to compare');
      return false;
    }

    // Get the current document text and parse it
    const document = await vscode.workspace.openTextDocument(documentUri);
    const currentText = document.getText();
    const updatedResource = yaml.load(currentText);

    // Convert both resources to formatted YAML for comparison
    const originalYaml = yaml.dump(originalResource, { indent: 2 });
    const updatedYaml = yaml.dump(updatedResource, { indent: 2 });

    // If no differences, inform the user and return
    if (originalYaml === updatedYaml) {
      vscode.window.showInformationMessage('No changes detected in the resource');
      return true; // Continue with apply even though there are no changes
    }

    // Create URIs for the diff editor - use a timestamp to avoid caching issues
    const timestamp = Date.now();
    const title = `${originalResource.kind}-${originalResource.metadata.name}`;
    const originalUri = vscode.Uri.parse(`k8s-diff:/original/${title}-${timestamp}`);
    const modifiedUri = vscode.Uri.parse(`k8s-diff:/modified/${title}-${timestamp}`);

    // Create one-time file system provider for the diff
    const diffProvider = vscode.workspace.registerFileSystemProvider('k8s-diff', {
      onDidChangeFile: new vscode.EventEmitter<vscode.FileChangeEvent[]>().event,
      watch: () => ({ dispose: () => {} }),
      stat: () => ({ type: vscode.FileType.File, ctime: timestamp, mtime: timestamp, size: 0 }),
      readDirectory: () => [],
      createDirectory: () => {},
      readFile: (uri) => {
        if (uri.path.startsWith('/original/')) {
          return Buffer.from(originalYaml);
        } else {
          return Buffer.from(updatedYaml);
        }
      },
      writeFile: () => {},
      delete: () => {},
      rename: () => {}
    }, { isCaseSensitive: true });

    // Show the diff
    await vscode.commands.executeCommand('vscode.diff',
      originalUri,
      modifiedUri,
      `Diff: ${title}`,
      { preview: true }
    );

    // Clean up provider after a delay
    setTimeout(() => {
      diffProvider.dispose();
    }, 5000);

    // Show a message with action buttons - no information message, just buttons
    const action = await vscode.window.showWarningMessage(
      'Continue with the operation?',
      'Continue',
      'Cancel'
    );

    // Return whether the user wants to proceed
    return action === 'Continue';

  } catch (error) {
    vscode.window.showErrorMessage(`Error showing diff: ${error}`);
    log(`Error in showResourceDiff: ${error}`, LogLevel.ERROR, true);
    edaOutputChannel.show();
    return false;
  }
}

// Confirm with the user before applying changes
async function confirmResourceUpdate(kind: string, name: string, dryRun: boolean | undefined): Promise<boolean> {
  const action = dryRun ? 'validate' : 'apply changes to';
  const message = `Are you sure you want to ${action} ${kind} "${name}"?`;

  const result = await vscode.window.showWarningMessage(
    message,
    { modal: false },
    dryRun ? 'Validate' : 'Apply'
  );

  return result === (dryRun ? 'Validate' : 'Apply');
}

// Apply the resource changes to the cluster
async function applyResource(
  k8sService: KubernetesService,
  resource: any,
  options: { dryRun?: boolean },
  providers?: {
    namespaceProvider?: any;
    systemProvider?: any;
    transactionProvider?: any;
  }
): Promise<boolean> {
  const isDryRun = options.dryRun || false;

  // Store URI so we can reopen it if needed
  let resourceUri: vscode.Uri | undefined;

  try {
    log(`${isDryRun ? 'Validating' : 'Applying'} resource ${resource.kind}/${resource.metadata.name}...`, LogLevel.INFO, true);

    // Create a URI for this resource to use later if needed
    resourceUri = K8sFileSystemProvider.createUri(
      resource.metadata.namespace || k8sService.getCurrentNamespace(),
      resource.kind,
      resource.metadata.name
    );

    const result = await k8sService.applyResource(resource, isDryRun);

    if (isDryRun) {
      log(`Validation successful for ${resource.kind} "${resource.metadata.name}"`, LogLevel.INFO, true);
    } else {
      log(`Successfully applied ${resource.kind} "${resource.metadata.name}"`, LogLevel.INFO, true);

      // Refresh all views after successful apply
      if (providers) {
        if (providers.namespaceProvider) {
          providers.namespaceProvider.refresh();
        }
        if (providers.systemProvider) {
          providers.systemProvider.refresh();
        }
        if (providers.transactionProvider) {
          providers.transactionProvider.refresh();
        }
      }

      // Close any open diff editors
      await closeDiffEditor();

      // If the resource isn't open anymore, reopen it
      const isResourceOpen = vscode.window.visibleTextEditors.some(
        editor => editor.document.uri.toString() === resourceUri?.toString()
      );

      if (!isResourceOpen && resourceUri) {
        try {
          const document = await vscode.workspace.openTextDocument(resourceUri);
          await vscode.window.showTextDocument(document, { preview: false });
        } catch (err) {
          log(`Failed to reopen resource: ${err}`, LogLevel.ERROR);
        }
      }
    }

    // Always show results in output channel
    if (result && typeof result === 'string' && result.length > 0) {
      log('\n======== APPLY RESULT ========', LogLevel.INFO, true);
      log(result, LogLevel.INFO, true);
      log('==============================\n', LogLevel.INFO, true);
    }

    // Always show the output channel
    edaOutputChannel.show();

    return true;

  } catch (error) {
    const errorMessage = `Failed to ${isDryRun ? 'validate' : 'apply'} resource: ${error}`;
    vscode.window.showErrorMessage(errorMessage);
    log(errorMessage, LogLevel.ERROR, true);

    // Show detailed error in output channel
    if (error instanceof Error) {
      log('\n======== ERROR DETAILS ========', LogLevel.ERROR, true);
      log(error.message, LogLevel.ERROR, true);
      log('===============================\n', LogLevel.ERROR, true);
    }

    // Always show the output channel
    edaOutputChannel.show();

    // If the resource isn't open anymore, try to reopen it
    if (resourceUri) {
      try {
        const isResourceOpen = vscode.window.visibleTextEditors.some(
          editor => editor.document.uri.toString() === resourceUri?.toString()
        );

        if (!isResourceOpen) {
          const document = await vscode.workspace.openTextDocument(resourceUri);
          await vscode.window.showTextDocument(document, { preview: false });
        }
      } catch (reopenErr) {
        log(`Failed to reopen resource after error: ${reopenErr}`, LogLevel.ERROR);
      }
    }

    return false;
  }
}

// Helper function to close diff editors and then reopen the resource
async function closeDiffEditor(): Promise<void> {
  try {
    // First, identify if there's a k8s resource open that we'll need to reopen
    let resourceUri: vscode.Uri | undefined;
    const resourceEditor = vscode.window.visibleTextEditors.find(
      editor => editor.document.uri.scheme === 'k8s'
    );

    if (resourceEditor) {
      resourceUri = resourceEditor.document.uri;
      log(`Found resource to reopen: ${resourceUri.toString()}`, LogLevel.DEBUG);
    }

    // Find if there's a diff editor open
    const hasDiffEditor = vscode.window.visibleTextEditors.some(
      editor => editor.document.uri.scheme === 'k8s-diff'
    );

    if (hasDiffEditor) {
      // Close the active editor (which should be the diff)
      await vscode.commands.executeCommand('workbench.action.closeActiveEditor');

      // If we had a resource open, reopen it
      if (resourceUri) {
        log(`Reopening resource: ${resourceUri.toString()}`, LogLevel.DEBUG);
        // Small delay to ensure the editor has closed
        await new Promise(resolve => setTimeout(resolve, 100));
        const document = await vscode.workspace.openTextDocument(resourceUri);
        await vscode.window.showTextDocument(document, { preview: false });
      }
    }
  } catch (error) {
    log(`Error in closeDiffEditor: ${error}`, LogLevel.ERROR);
  }
}
=== ./src/commands/resourceViewCommands.ts ===
// Updated src/commands/resourceViewCommand.ts with read-only enforcement
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';
import { KubernetesService } from '../services/kubernetes/kubernetes';
import { ResourceViewDocumentProvider } from '../providers/documents/resourceViewProvider';
import { log, LogLevel } from '../extension.js';

/**
 * Registers the "viewResource" command that opens a read-only YAML view (k8s-view:)
 */
export function registerResourceViewCommands(
  context: vscode.ExtensionContext,
  k8sService: KubernetesService,
  viewProvider: ResourceViewDocumentProvider
) {
  const viewResourceCommand = vscode.commands.registerCommand(
    'vscode-eda.viewResource',
    async (treeItemOrResourceInfo: any) => {
      try {
        let kind, name, namespace;

        // If called from a tree item:
        if (treeItemOrResourceInfo?.resource) {
          const resource = treeItemOrResourceInfo.resource;
          kind = resource.kind;
          name = resource.metadata?.name;
          namespace = resource.metadata?.namespace || treeItemOrResourceInfo.namespace || 'default';
        }
        // Or if called programmatically with { kind, name, namespace }:
        else if (treeItemOrResourceInfo?.kind && treeItemOrResourceInfo?.name) {
          kind = treeItemOrResourceInfo.kind;
          name = treeItemOrResourceInfo.name;
          namespace = treeItemOrResourceInfo.namespace || 'default';
        } else {
          vscode.window.showErrorMessage('Invalid resource to view.');
          return;
        }

        // 1) Fetch resource YAML
        let yamlContent = await k8sService.getResourceYaml(kind, name, namespace);
        try {
          const resource = yaml.load(yamlContent) as any;
          if (!resource.apiVersion) {
            // Compute the appropriate apiVersion (as you already do)
            let computedApiVersion = '';
            const isEdaCrd = await k8sService.isEdaCrd(kind);
            if (isEdaCrd) {
              try {
                const crdDef = await k8sService.getCrdDefinitionForKind(kind);
                if (crdDef && crdDef.spec?.group) {
                  const version = crdDef.spec.versions?.find(v => v.storage === true) ||
                                  crdDef.spec.versions?.find(v => v.served === true) ||
                                  crdDef.spec.versions?.[0];
                  computedApiVersion = version?.name ? `${crdDef.spec.group}/${version.name}` : `${crdDef.spec.group}/v1alpha1`;
                }
              } catch (error) {
                // Fallback for EDA CRDs
                let plural = kind.toLowerCase();
                if (plural.endsWith('f')) {
                  plural = plural.slice(0, -1) + 'ves';
                } else if (plural.endsWith('y')) {
                  plural = plural.slice(0, -1) + 'ies';
                } else if (!plural.endsWith('s')) {
                  plural += 's';
                }
                computedApiVersion = `${plural}.eda.nokia.com/v1alpha1`;
              }
            } else {
              const k8sResources: Record<string, string> = {
                'Pod': 'v1',
                'Service': 'v1',
                'Deployment': 'apps/v1',
                'ConfigMap': 'v1',
                'Secret': 'v1',
                'Node': 'v1'
              };
              computedApiVersion = k8sResources[kind] || '';
            }
            resource.apiVersion = computedApiVersion;
            // Instead of dumping the entire object (which reorders keys),
            // manually prepend the apiVersion line to the original YAML.
            // You might want to remove any old apiVersion line from yamlContent first.
            yamlContent = yamlContent.replace(/^apiVersion:.*\n/, '');
            yamlContent = `apiVersion: ${resource.apiVersion}\n${yamlContent}`;
          }
        } catch (error) {
          log(`Error processing YAML for view: ${error}`, LogLevel.WARN);
          // Proceed with original yamlContent if parsing fails
        }

        // 3) Build a read-only URI
        const viewUri = vscode.Uri.parse(
          `k8s-view:/${namespace}/${kind}/${name}?ts=${Date.now()}`
        );

        // 4) Store the YAML content in your read-only provider
        viewProvider.setResourceContent(viewUri, yamlContent);

        // 5) Open the doc & set language to 'yaml'
        const doc = await vscode.workspace.openTextDocument(viewUri);
        await vscode.languages.setTextDocumentLanguage(doc, 'yaml');

        // 6) Open the document as read-only
        await vscode.window.showTextDocument(doc, {
          preview: true,
          preserveFocus: false,
          viewColumn: vscode.ViewColumn.Active
        });

        // 7) Add a status bar item to easily switch to edit mode
        const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
        statusBarItem.text = "$(edit) Edit Resource";
        statusBarItem.tooltip = "Switch to editable mode";
        statusBarItem.command = "vscode-eda.switchToEditResource";
        statusBarItem.show();

        // Dispose the status bar item when the document is closed
        const disposable = vscode.workspace.onDidCloseTextDocument(closedDoc => {
          if (closedDoc.uri.toString() === viewUri.toString()) {
            statusBarItem.dispose();
            disposable.dispose();
          }
        });

        context.subscriptions.push(disposable);

      } catch (error) {
        log(`Failed to view resource: ${error}`, LogLevel.ERROR, true);
        vscode.window.showErrorMessage(`Failed to view resource: ${error}`);
      }
    }
  );

  context.subscriptions.push(viewResourceCommand);
}

export function registerSwitchToEditCommand(context: vscode.ExtensionContext) {
  const switchToEditCommand = vscode.commands.registerCommand(
    'vscode-eda.switchToEditResource',
    async () => {
      // We'll get the "activeTextEditor", parse the URI to figure out the resource
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showErrorMessage('No active editor to switch to edit mode.');
        return;
      }

      const docUri = editor.document.uri;
      if (docUri.scheme !== 'k8s-view') {
        vscode.window.showErrorMessage('This document is not in read-only view mode.');
        return;
      }

      // Parse the URI to get namespace, kind, name
      const parts = docUri.path.split('/').filter(p => p.length > 0); // e.g. /my-namespace/Pod/my-resource
      if (parts.length !== 3) {
        vscode.window.showErrorMessage(`Invalid k8s-view URI: ${docUri}`);
        return;
      }

      const [namespace, kind, resourceName] = parts;

      // Now we can simply call your "editResource" command with the same data
      await vscode.commands.executeCommand('vscode-eda.editResource', {
        kind,
        name: resourceName,
        namespace
      });
    }
  );

  context.subscriptions.push(switchToEditCommand);
}
=== ./src/utils/templateLoader.ts ===
// src/utils/templateLoader.ts
import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import * as Handlebars from 'handlebars';

/**
 * Loads a Handlebars template and compiles it with the provided variables.
 *
 * @param templateName Base name of the template file (without extension)
 * @param context VSCode extension context for resolving paths
 * @param variables Variables to pass into the template
 * @returns The rendered template as a string
 */
export function loadTemplate(
  templateName: string,
  context: vscode.ExtensionContext,
  variables: Record<string, any>
): string {
  try {
    // Adjust the path to point to src/templates instead of templates/
    const templatePath = context.asAbsolutePath(
      path.join('src', 'templates', `${templateName}.hbs`)
    );
    const templateContent = fs.readFileSync(templatePath, 'utf8');
    const template = Handlebars.compile(templateContent);
    return template(variables);
  } catch (error) {
    console.error(`Error loading template ${templateName}:`, error);
    return `Error loading template ${templateName}: ${error}`;
  }
}

=== ./src/utils/cacheUtils.ts ===
import { log, LogLevel } from '../extension.js';

/**
 * Generic cache entry with value and expiration tracking
 */
interface CacheEntry<T> {
  value: T | Promise<T>;
  timestamp: number;
  namespace?: string;
}

/**
 * Generic reusable cache manager for the extension
 */
export class Cache {
  private caches: Map<string, Map<string, CacheEntry<any>>> = new Map();
  private defaultTtl: number = 15000; // 15 seconds default TTL

  /**
   * Constructor
   * @param defaultTtl Default time-to-live for cache entries in milliseconds
   */
  constructor(defaultTtl?: number) {
    if (defaultTtl) {
      this.defaultTtl = defaultTtl;
    }
  }

  /**
   * Get an item from cache or fetch it using the provided function
   * @param group The cache group (e.g., 'pods', 'namespaces')
   * @param key The cache key
   * @param fetchFn Function to call if cache is invalid
   * @param options Additional options
   */
  async getOrFetch<T>(
    group: string,
    key: string,
    fetchFn: () => Promise<T>,
    options: {
      ttl?: number;
      description?: string;
      namespace?: string;
    } = {}
  ): Promise<T> {
    const ttl = options.ttl || this.defaultTtl;
    const description = options.description || `${group}/${key}`;
    const now = Date.now();

    // Check if we already have a valid cache entry.
    const cacheItem = this.get<T>(group, key);
    if (cacheItem && this.isValid(cacheItem.timestamp, ttl)) {
      if (options.namespace && cacheItem.namespace !== options.namespace) {
        log(`Cache namespace mismatch for ${description}, fetching...`, LogLevel.DEBUG);
      } else {
        log(`Using cached ${description}`, LogLevel.DEBUG);
        // Wrap in Promise.resolve in case the stored value is already a Promise.
        return Promise.resolve(cacheItem.value);
      }
    }

    // No valid cache entry exists, so create one immediately.
    const fetchPromise = fetchFn();
    // Store the in-flight promise in the cache.
    this.set<T>(group, key, fetchPromise, options.namespace);
    try {
      const result = await fetchPromise;
      // Once resolved, update the cache with the actual result and a fresh timestamp.
      this.set<T>(group, key, result, options.namespace);
      return result;
    } catch (error) {
      // Optionally, remove the failed cache entry so that the next call will try again.
      // For example:
      this.clear(group);
      log(`Error fetching ${description}: ${error}`, LogLevel.ERROR);
      throw error;
    }
  }

  /**
   * Check if a cache timestamp is still valid
   */
  private isValid(timestamp: number, ttl: number): boolean {
    return Date.now() - timestamp < ttl;
  }

  /**
   * Get an item from cache
   */
  get<T>(group: string, key: string): CacheEntry<T> | undefined {
    if (!this.caches.has(group)) {
      return undefined;
    }

    return this.caches.get(group)?.get(key) as CacheEntry<T> | undefined;
  }

  /**
   * Store an item in cache
   */
  set<T>(group: string, key: string, value: T | Promise<T>, namespace?: string): void {
    if (!this.caches.has(group)) {
      this.caches.set(group, new Map());
    }
    this.caches.get(group)?.set(key, {
      value,
      timestamp: Date.now(),
      namespace,
    });
  }

  /**
   * Clear a specific cache group
   */
  clear(group: string): void {
    this.caches.delete(group);
  }

  /**
   * Clear all caches
   */
  clearAll(): void {
    this.caches.clear();
  }

  /**
   * Remove a specific item from a cache group
   * @param group The cache group
   * @param key The cache key to remove
   * @returns true if the item was removed, false if not found
   */
  remove(group: string, key: string): boolean {
    if (!this.caches.has(group)) {
      return false;
    }
    
    const groupCache = this.caches.get(group);
    if (!groupCache) {
      return false;
    }
    
    return groupCache.delete(key);
  }

}

// Export a singleton instance
export const cache = new Cache();
=== ./src/utils/resourceUtils.ts ===
import { KubernetesObject } from '@kubernetes/client-node';
import { log, LogLevel } from '../extension.js';

/**
 * Interface for resource fetch options
 */
export interface ResourceFetchOptions {
  namespace: string;
  cacheKey?: string;
}

/**
 * Generic function to fetch Kubernetes resources
 */
export async function fetchResources<T extends KubernetesObject>(
  // Update the type definition to match the new response format
  fetchFn: () => Promise<{ items: T[] }>,  // Remove 'body' wrapper
  resourceType: string,
  options: ResourceFetchOptions
): Promise<T[]> {
  try {
    const { namespace, cacheKey } = options;

    log(`Fetching ${resourceType} in namespace '${namespace}'${cacheKey ? ` for ${cacheKey}` : ''}...`, LogLevel.DEBUG);
    const startTime = Date.now();

    const response = await fetchFn();
    const items = response.items;  // Direct access - no more response.body

    const elapsedTime = Date.now() - startTime;
    log(`Found ${items.length} ${resourceType} in namespace '${namespace}' (${elapsedTime}ms)`, LogLevel.DEBUG);

    return items;
  } catch (error) {
    log(`Failed to get ${resourceType}: ${error}`, LogLevel.ERROR, true);
    return [];
  }
}

/**
 * Execute kubectl command with error handling
 */
export function executeKubectl(
  kubectlPath: string,
  args: string[],
  options: { encoding: string } = { encoding: 'utf-8' }
): string {
  try {
    const { execSync } = require('child_process');
    return execSync(`${kubectlPath} ${args.join(' ')}`, options);
  } catch (error: any) {
    if (error.stdout?.includes('not found') || error.stderr?.includes('not found')) {
      log(`Resource not found with kubectl command: ${args.join(' ')}`, LogLevel.WARN);
      return '';
    }
    throw error;
  }
}
=== ./src/providers/documents/baseDocumentProvider.ts ===
import * as vscode from 'vscode';

/**
 * Base class for read-only document providers implementing the vscode.FileSystemProvider interface
 */
export abstract class BaseDocumentProvider implements vscode.FileSystemProvider {
  protected contentMap = new Map<string, Buffer>();

  private _onDidChangeFile = new vscode.EventEmitter<vscode.FileChangeEvent[]>();
  readonly onDidChangeFile: vscode.Event<vscode.FileChangeEvent[]> = this._onDidChangeFile.event;

  /**
   * Store the content for a given URI
   */
  protected setContent(uri: vscode.Uri, content: string): void {
    this.contentMap.set(uri.toString(), Buffer.from(content, 'utf8'));
  }

  /**
   * Required by FileSystemProvider, but not needed for read-only providers
   */
  watch(_uri: vscode.Uri, _options: { recursive: boolean; excludes: string[] }): vscode.Disposable {
    return new vscode.Disposable(() => {});
  }

  /**
   * Get information about a file
   */
  stat(uri: vscode.Uri): vscode.FileStat {
    const data = this.contentMap.get(uri.toString());
    if (!data) {
      throw vscode.FileSystemError.FileNotFound(uri);
    }
    return {
      type: vscode.FileType.File,
      ctime: 0,
      mtime: 0,
      size: data.byteLength,
      permissions: vscode.FilePermission.Readonly // Explicitly set read-only permission
    };
  }

  /**
   * Not supporting directory listing
   */
  readDirectory(_uri: vscode.Uri): [string, vscode.FileType][] {
    return [];
  }

  /**
   * Not supporting directory creation (read-only)
   */
  createDirectory(_uri: vscode.Uri): void {
    throw vscode.FileSystemError.NoPermissions('Read-only: cannot create directory');
  }

  /**
   * Read file content
   */
  readFile(uri: vscode.Uri): Uint8Array {
    const data = this.contentMap.get(uri.toString());
    if (!data) {
      throw vscode.FileSystemError.FileNotFound(uri);
    }
    return data;
  }

  /**
   * Not supporting write operations (read-only)
   */
  writeFile(_uri: vscode.Uri, _content: Uint8Array, _options: { create: boolean; overwrite: boolean }): void {
    throw vscode.FileSystemError.NoPermissions('This document is read-only. Use "Switch to Edit" to modify.');
  }

  /**
   * Not supporting delete operations (read-only)
   */
  delete(_uri: vscode.Uri, _options: { recursive: boolean }): void {
    throw vscode.FileSystemError.NoPermissions('Read-only: delete not supported');
  }

  /**
   * Not supporting rename operations (read-only)
   */
  rename(_oldUri: vscode.Uri, _newUri: vscode.Uri, _options: { overwrite: boolean }): void {
    throw vscode.FileSystemError.NoPermissions('Read-only: rename not supported');
  }
}
=== ./src/providers/documents/alarmDetailsProvider.ts ===
// providers/documents/alarmDetailsProvider.ts
import * as vscode from 'vscode';
import { BaseDocumentProvider } from './baseDocumentProvider';

export class AlarmDetailsDocumentProvider extends BaseDocumentProvider {
  public setAlarmContent(uri: vscode.Uri, text: string): void {
    this.setContent(uri, text);
  }
}

=== ./src/providers/documents/crdDefinitionProvider.ts ===
import * as vscode from 'vscode';
import { BaseDocumentProvider } from './baseDocumentProvider';

/**
 * A read-only provider for the "crd:" scheme, storing CRD YAML in memory.
 */
export class CrdDefinitionFileSystemProvider extends BaseDocumentProvider {
  /**
   * Store the YAML in memory for the given `crd:` URI.
   */
  public setCrdYaml(uri: vscode.Uri, yamlContent: string): void {
    this.setContent(uri, yamlContent);
  }
}
=== ./src/providers/documents/deviationDetailsProvider.ts ===
// providers/documents/deviationDetailsProvider.ts
import * as vscode from 'vscode';
import { BaseDocumentProvider } from './baseDocumentProvider';

export class DeviationDetailsDocumentProvider extends BaseDocumentProvider {
  public setDeviationContent(uri: vscode.Uri, text: string): void {
    this.setContent(uri, text);
  }
}

=== ./src/providers/documents/podDescribeProvider.ts ===
import * as vscode from 'vscode';
import { BaseDocumentProvider } from './baseDocumentProvider';

/**
 * Provides read-only text for "kubectl describe pod" output, under the "k8s-describe:" URI scheme.
 */
export class PodDescribeDocumentProvider extends BaseDocumentProvider {
  /**
   * Store the textual output for a given 'k8s-describe:' URI.
   */
  public setDescribeContent(uri: vscode.Uri, text: string): void {
    this.setContent(uri, text);
  }
}
=== ./src/providers/documents/resourceProvider.ts ===
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';
import { KubernetesService } from '../../services/kubernetes/kubernetes';
import { log, LogLevel } from '../../extension.js';

/**
 * Interface for a K8s resource with minimum required fields
 */
interface K8sResource {
  apiVersion?: string;
  kind: string;
  metadata?: {
    name: string;
    namespace?: string;
    [key: string]: any;
  };
  [key: string]: any;
}

/**
 * File system provider for Kubernetes resources with a custom URI scheme
 * Format: k8s://namespace/kind/name
 */
export class K8sFileSystemProvider implements vscode.FileSystemProvider {
  private _onDidChangeFile = new vscode.EventEmitter<vscode.FileChangeEvent[]>();
  readonly onDidChangeFile = this._onDidChangeFile.event;

  // Map to store original resources
  private originalResources = new Map<string, any>();

  // Map to store file contents for virtual files
  private fileContents = new Map<string, Uint8Array>();

  constructor(private k8sService: KubernetesService) {}

  setFileContent(uri: vscode.Uri, content: Uint8Array): void {
    this.fileContents.set(uri.toString(), content);
  }

  /**
   * Parse a k8s URI to get namespace, kind, and name
   */
  static parseUri(uri: vscode.Uri): { namespace: string; kind: string; name: string } {
    // URI format: k8s:/namespace/kind/name
    const parts = uri.path.split('/').filter(p => p.length > 0);
    if (parts.length !== 3) {
      throw new Error(`Invalid k8s URI format: ${uri}`);
    }
    return {
      namespace: parts[0],
      kind: parts[1],
      name: parts[2]
    };
  }

  /**
   * Create a k8s URI for a resource
   */
  static createUri(namespace: string, kind: string, name: string): vscode.Uri {
    return vscode.Uri.parse(`k8s:/${namespace}/${kind}/${name}`);
  }

  /**
   * Store the original resource for a given URI
   */
  setOriginalResource(uri: vscode.Uri, resource: any): void {
    // Make a deep copy so we don't mutate
    this.originalResources.set(uri.toString(), JSON.parse(JSON.stringify(resource)));
  }

  /**
   * Get the original resource for a given URI
   */
  getOriginalResource(uri: vscode.Uri): any {
    return this.originalResources.get(uri.toString());
  }

  /**
   * Get API version based on resource kind using a pattern
   */
  private getApiVersionForKind(kind: string): string {
    // Standard Kubernetes resources need specific handling
    const k8sResources: Record<string, string> = {
      'Pod': 'v1',
      'Service': 'v1',
      'Deployment': 'apps/v1',
      'ConfigMap': 'v1',
      'Secret': 'v1',
      'Node': 'v1'
    };

    // Check if it's a standard K8s resource
    if (k8sResources[kind]) {
      return k8sResources[kind];
    }

    // For EDA CRDs, follow the pattern: lowercase plural form + ".eda.nokia.com/v1alpha1"
    let plural = kind.toLowerCase();
    if (plural.endsWith('f')) {
      plural = plural.slice(0, -1) + 'ves'; // e.g., MacVrf -> macvrves
    } else if (plural.endsWith('y')) {
      plural = plural.slice(0, -1) + 'ies'; // e.g., Policy -> policies
    } else if (!plural.endsWith('s')) {
      plural += 's'; // e.g., Interface -> interfaces
    }

    return `${plural}.eda.nokia.com/v1alpha1`;
  }

  // -- FileSystemProvider implementation --

  watch(_uri: vscode.Uri, _options: { recursive: boolean; excludes: string[] }): vscode.Disposable {
    // We don't need to watch for external changes as we control all changes
    return new vscode.Disposable(() => {});
  }

  stat(uri: vscode.Uri): vscode.FileStat {
    return {
      type: vscode.FileType.File,
      ctime: Date.now(),
      mtime: Date.now(),
      size: this.fileContents.get(uri.toString())?.length || 0
    };
  }

  readDirectory(_uri: vscode.Uri): [string, vscode.FileType][] {
    // Not supporting directory operations
    return [];
  }

  createDirectory(_uri: vscode.Uri): void {
    // Not supporting directory operations
  }

  async readFile(uri: vscode.Uri): Promise<Uint8Array> {
    const uriString = uri.toString();

    // Return cached content if available
    if (this.fileContents.has(uriString)) {
      return this.fileContents.get(uriString)!;
    }

    try {
      // Get resource info from URI
      const { namespace, kind, name } = K8sFileSystemProvider.parseUri(uri);
      log(`Fetching ${kind}/${name} from namespace ${namespace}...`, LogLevel.INFO);

      // Get YAML directly from Kubernetes service - optimized to use kubectl when possible
      let yamlContent = await this.k8sService.getResourceYaml(kind, name, namespace);

      // Check if the YAML has apiVersion (might be missing in edactl output)
      const hasApiVersion = yamlContent.includes('apiVersion:');

      if (!hasApiVersion) {
        // Add the appropriate apiVersion based on the kind
        const apiVersion = this.getApiVersionForKind(kind);
        yamlContent = `apiVersion: ${apiVersion}\n${yamlContent}`;
      }

      // Store content
      const contentBuffer = Buffer.from(yamlContent, 'utf8');
      this.fileContents.set(uriString, contentBuffer);

      // Try to parse the YAML to get resource for comparison
      try {
        const resource = yaml.load(yamlContent) as K8sResource;
        if (resource && typeof resource === 'object') {
          this.setOriginalResource(uri, resource);
        }
      } catch (parseError) {
        // If we can't parse, create a minimal resource object
        log(`Could not parse YAML: ${parseError}`, LogLevel.DEBUG);
        const minimalResource: K8sResource = {
          kind: kind,
          apiVersion: this.getApiVersionForKind(kind),
          metadata: {
            name: name,
            namespace: namespace
          }
        };
        this.setOriginalResource(uri, minimalResource);
      }

      return contentBuffer;
    } catch (error) {
      log(`Error reading file: ${error}`, LogLevel.ERROR);
      const errorContent = `# Error loading resource: ${error}`;
      const contentBuffer = Buffer.from(errorContent, 'utf8');
      this.fileContents.set(uriString, contentBuffer);
      return contentBuffer;
    }
  }

  writeFile(uri: vscode.Uri, content: Uint8Array, _options: { create: boolean; overwrite: boolean }): void {
    const uriString = uri.toString();
    this.fileContents.set(uriString, content);

    // Notify that the file has changed
    this._onDidChangeFile.fire([{
      type: vscode.FileChangeType.Changed,
      uri
    }]);
  }

  delete(uri: vscode.Uri, _options: { recursive: boolean }): void {
    const uriString = uri.toString();
    this.fileContents.delete(uriString);
    this.originalResources.delete(uriString);
  }

  rename(_oldUri: vscode.Uri, _newUri: vscode.Uri, _options: { overwrite: boolean }): void {
    // Not supporting rename operations
    throw new Error('Rename operation not supported for Kubernetes resources');
  }

  /**
   * Clean up resources when a document is closed
   */
  cleanupDocument(uri: vscode.Uri): void {
    const uriString = uri.toString();
    this.originalResources.delete(uriString);
    this.fileContents.delete(uriString);
  }

  /**
   * Get the current document text as a string
   */
  getContentAsString(uri: vscode.Uri): string {
    const uriString = uri.toString();
    if (this.fileContents.has(uriString)) {
      return Buffer.from(this.fileContents.get(uriString)!).toString('utf8');
    }
    return '';
  }

  /**
   * Check if the current content has changes compared to the original
   */
  async hasChanges(uri: vscode.Uri, bypassChangesCheck: boolean = false): Promise<boolean> {
    // If bypass is requested, always return true
    if (bypassChangesCheck) {
      return true;
    }

    const uriString = uri.toString();
    if (!this.fileContents.has(uriString)) {
      return false;
    }

    const originalResource = this.getOriginalResource(uri);
    if (!originalResource) {
      return true;
    }

    try {
      const currentContent = this.getContentAsString(uri);
      const currentResource = yaml.load(currentContent);

      // Compare the two resources (ignoring metadata fields that change automatically)
      const originalCopy = JSON.parse(JSON.stringify(originalResource));
      const currentCopy = JSON.parse(JSON.stringify(currentResource));

      // Remove fields that change automatically
      const cleanMetadata = (obj: any) => {
        if (obj && obj.metadata) {
          delete obj.metadata.resourceVersion;
          delete obj.metadata.generation;
          delete obj.metadata.creationTimestamp;
          delete obj.metadata.uid;
          delete obj.metadata.managedFields;
        }
      };

      cleanMetadata(originalCopy);
      cleanMetadata(currentCopy);

      return JSON.stringify(originalCopy) !== JSON.stringify(currentCopy);
    } catch (error) {
      log(`Error checking for changes: ${error}`, LogLevel.ERROR);
      return true;
    }
  }
}
=== ./src/providers/documents/resourceViewProvider.ts ===
// Updated src/providers/documents/resourceViewProvider.ts
import * as vscode from 'vscode';
import { BaseDocumentProvider } from './baseDocumentProvider';

/**
 * A read-only provider for the "k8s-view:" scheme, displaying resources in read-only mode.
 */
export class ResourceViewDocumentProvider extends BaseDocumentProvider {
  /**
   * Store the YAML content for a given `k8s-view:` URI.
   */
  public setResourceContent(uri: vscode.Uri, yamlContent: string): void {
    this.setContent(uri, yamlContent);
  }
  
  /**
   * Parse a k8s-view URI to get namespace, kind, and name
   */
  static parseUri(uri: vscode.Uri): { namespace: string; kind: string; name: string } {
    // URI format: k8s-view:/namespace/kind/name
    const parts = uri.path.split('/').filter(p => p.length > 0);
    if (parts.length !== 3) {
      throw new Error(`Invalid k8s-view URI format: ${uri}`);
    }
    return {
      namespace: parts[0],
      kind: parts[1],
      name: parts[2]
    };
  }

  /**
   * Create a k8s-view URI for a resource
   */
  static createUri(namespace: string, kind: string, name: string): vscode.Uri {
    return vscode.Uri.parse(`k8s-view:/${namespace}/${kind}/${name}`);
  }

  /**
   * Override writeFile to explicitly throw NoPermissions
   */
  writeFile(uri: vscode.Uri, content: Uint8Array, options: { create: boolean; overwrite: boolean }): void {
    throw vscode.FileSystemError.NoPermissions("This document is read-only. Use 'Switch to Edit' to modify.");
  }
}
=== ./src/providers/documents/transactionDetailsProvider.ts ===
import * as vscode from 'vscode';
import { BaseDocumentProvider } from './baseDocumentProvider';

/**
 * A read-only provider for "eda-transaction:" URIs that displays
 * EDA transaction details text from "edactl transaction <id>".
 */
export class TransactionDetailsDocumentProvider extends BaseDocumentProvider {
  /**
   * Store the transaction details text for a given "eda-transaction:" URI
   */
  public setTransactionContent(uri: vscode.Uri, text: string): void {
    this.setContent(uri, text);
  }
}
=== ./src/providers/views/common/treeItem.ts ===
import * as vscode from 'vscode';

export class TreeItemBase extends vscode.TreeItem {
  public namespace?: string;
  public resourceType?: string;
  public resourceCategory?: string;
  public resource?: any;
  public crdInfo?: any;

  constructor(
    public readonly label: string,
    public readonly collapsibleState: vscode.TreeItemCollapsibleState,
    public readonly contextValue: string,
    resource?: any
  ) {
    super(label, collapsibleState);
    this.tooltip = label;
    this.resource = resource;
  }
}
=== ./src/providers/views/alarmProvider.ts ===
import * as vscode from 'vscode';
import { EdaAlarm} from '../../services/types';
import { KubernetesService } from '../../services/kubernetes/kubernetes';
import { log, LogLevel, globalTreeFilter } from '../../extension.js';
import { TreeItemBase } from './common/treeItem';
import { resourceStatusService } from '../../extension.js';

/**
 * EdaAlarmProvider displays the list of active alarms from "edactl query .namespace.alarms.current-alarm".
 */
export class EdaAlarmProvider implements vscode.TreeDataProvider<AlarmTreeItem> {
  private _onDidChangeTreeData = new vscode.EventEmitter<AlarmTreeItem | undefined | null | void>();
  readonly onDidChangeTreeData = this._onDidChangeTreeData.event;

  constructor(
    private context: vscode.ExtensionContext,
    private k8sService: KubernetesService
  ) {}

  /**
   * Refresh method, to be called from our extension-level refresh
   */
  refresh(): void {
    log('EdaAlarmProvider: Refresh called', LogLevel.DEBUG);
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: AlarmTreeItem): vscode.TreeItem {
    return element;
  }

  async getChildren(element?: AlarmTreeItem): Promise<AlarmTreeItem[]> {
    // This provider is simple: if there's no element, we show the top-level alarms
    if (element) {
      // We don't do nested children for alarms; each alarm is a leaf
      return [];
    }

    // If there's a global filter, do BFS-like filtering. Otherwise, just list all.
    if (!globalTreeFilter) {
      return this.getAllAlarmItems();
    } else {
      return this.getFilteredAlarmItems(globalTreeFilter);
    }
  }

  /**
   * Load all alarms (no filter).
   */
  private async getAllAlarmItems(): Promise<AlarmTreeItem[]> {
    const alarms = await this.k8sService.getEdaAlarms();
    if (!alarms.length) {
      return [this.noAlarmsItem()];
    }

    return alarms.map((a: EdaAlarm) => this.createAlarmItem(a));
  }

  private async getFilteredAlarmItems(filter: string): Promise<AlarmTreeItem[]> {
    const lowerFilter = filter.toLowerCase();
    const all = await this.k8sService.getEdaAlarms();
    const matches = all.filter((a: EdaAlarm) =>
      a.name.toLowerCase().includes(lowerFilter) ||
      a["namespace.name"]?.toLowerCase().includes(lowerFilter) ||
      a.severity.toLowerCase().includes(lowerFilter) ||
      a.type.toLowerCase().includes(lowerFilter)
    );

    if (!matches.length) {
      return [this.noAlarmsItem(`(no matches for "${filter}")`)];
    }

    return matches.map((a: EdaAlarm) => this.createAlarmItem(a));
  }

  /**
   * Create a single Alarm tree item from EdaAlarm object
   */
  private createAlarmItem(alarm: EdaAlarm): AlarmTreeItem {
    const label = `${alarm.severity.toUpperCase()} - ${alarm.type}`;
    const item = new AlarmTreeItem(label, vscode.TreeItemCollapsibleState.None, 'eda-alarm', alarm);
    item.description = `ns: ${alarm["namespace.name"]}`;
    item.tooltip = [
      `Name: ${alarm.name}`,
      `Description: ${alarm.description}`,
      `Resource: ${alarm.resource}`,
      `Severity: ${alarm.severity}`,
      `Cause: ${alarm.probableCause}`
    ].join('\n');

    // Use the alarm theme icon from statusUtils
    item.iconPath = resourceStatusService.getAlarmThemeIcon(alarm.severity);

    // Set the command to open the alarm details document
    item.command = {
      command: 'vscode-eda.showAlarmDetails',
      title: 'Show Alarm Details',
      arguments: [alarm]
    };

    return item;
  }

  private noAlarmsItem(extraText = ''): AlarmTreeItem {
    const label = extraText ? `No Alarms Found ${extraText}` : `No Alarms Found`;
    const item = new AlarmTreeItem(label, vscode.TreeItemCollapsibleState.None, 'info');

    // Use the standard status icon from statusUtils
    item.iconPath = resourceStatusService.getStatusIcon('gray');

    return item;
  }
}

export class AlarmTreeItem extends TreeItemBase {
  constructor(
    label: string,
    collapsibleState: vscode.TreeItemCollapsibleState,
    contextValue: string,
    public alarm?: EdaAlarm
  ) {
    super(label, collapsibleState, contextValue, alarm);
  }
}
=== ./src/providers/views/deviationProvider.ts ===
import * as vscode from 'vscode';
import { EdaDeviation } from '../../services/types';
import { KubernetesService } from '../../services/kubernetes/kubernetes';
import { log, LogLevel, globalTreeFilter } from '../../extension.js';
import { TreeItemBase } from './common/treeItem';
import { resourceStatusService } from '../../extension.js';

/**
 * EdaDeviationProvider displays the list of deviations from
 * "edactl query .namespace.resources.cr.core_eda_nokia_com.v1.deviation -f json".
 */
export class EdaDeviationProvider implements vscode.TreeDataProvider<DeviationTreeItem> {
  private _onDidChangeTreeData = new vscode.EventEmitter<DeviationTreeItem | undefined | null | void>();
  readonly onDidChangeTreeData = this._onDidChangeTreeData.event;

  // Cache of currently displayed deviations
  private deviations: EdaDeviation[] = [];

  constructor(
    private context: vscode.ExtensionContext,
    private k8sService: KubernetesService
  ) {}

  /**
   * Refresh method, to be called from our extension-level refresh
   */
  refresh(): void {
    log('EdaDeviationProvider: Refresh called', LogLevel.DEBUG);
    this._onDidChangeTreeData.fire();
  }

  /**
   * Update a specific deviation's status
   */
  updateDeviation(name: string, namespace: string, status: string): void {
    log(`Updating deviation ${name} in namespace ${namespace} with status: ${status}`, LogLevel.DEBUG);

    // Find the deviation in our cache
    const deviation = this.deviations.find(d =>
      d.name === name && d["namespace.name"] === namespace
    );

    if (deviation) {
      // Update the deviation's status
      (deviation as any).status = status;

      // Notify tree view of the change for this specific item
      this._onDidChangeTreeData.fire();
    }
  }

  /**
   * Remove a specific deviation from the tree view
   */
  removeDeviation(name: string, namespace: string): void {
    log(`Removing deviation ${name} from namespace ${namespace} from the tree view`, LogLevel.DEBUG);

    // Remove the deviation from our cache
    this.deviations = this.deviations.filter(d =>
      !(d.name === name && d["namespace.name"] === namespace)
    );

    // Notify tree view of the change
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: DeviationTreeItem): vscode.TreeItem {
    return element;
  }

  async getChildren(element?: DeviationTreeItem): Promise<DeviationTreeItem[]> {
    // If there's an element, we've reached a leaf node
    if (element) {
      return [];
    }

    // If there's a global filter, do filtering. Otherwise, list all.
    if (!globalTreeFilter) {
      return this.getAllDeviationItems();
    } else {
      return this.getFilteredDeviationItems(globalTreeFilter);
    }
  }

  /**
   * Load all deviations (no filter).
   */
  private async getAllDeviationItems(): Promise<DeviationTreeItem[]> {
    const deviations = await this.k8sService.getEdaDeviations();

    // Update our cache
    this.deviations = deviations;

    if (!deviations.length) {
      return [this.noDeviationsItem()];
    }

    return deviations.map((d: EdaDeviation) => this.createDeviationItem(d));
  }

  /**
   * Filter deviations by name, namespace, etc.
   */
  private async getFilteredDeviationItems(filter: string): Promise<DeviationTreeItem[]> {
    // If the "Deviations" category itself matches the filter, show all deviations
    if ("deviations".includes(filter.toLowerCase())) {
      return this.getAllDeviationItems();
    }

    const lowerFilter = filter.toLowerCase();
    const all = await this.k8sService.getEdaDeviations();

    // Update our cache
    this.deviations = all;

    const matches = all.filter((d: EdaDeviation) =>
      d.name.toLowerCase().includes(lowerFilter) ||
      d["namespace.name"]?.toLowerCase().includes(lowerFilter) ||
      d.kind?.toLowerCase().includes(lowerFilter)
    );

    if (!matches.length) {
      return [this.noDeviationsItem(`(no matches for "${filter}")`)];
    }

    return matches.map((d: EdaDeviation) => this.createDeviationItem(d));
  }

  /**
   * Create a single Deviation tree item from EdaDeviation object
   */
  private createDeviationItem(deviation: EdaDeviation): DeviationTreeItem {
    const label = deviation.name;
    const item = new DeviationTreeItem(
      label,
      vscode.TreeItemCollapsibleState.None,
      'eda-deviation',
      deviation
    );
    // Show the namespace in 'description'
    item.description = `ns: ${deviation["namespace.name"]}`;

    // Add status if available
    if ((deviation as any).status) {
      item.description += ` (${(deviation as any).status})`;
    }

    item.tooltip = [
      `Name: ${deviation.name}`,
      `Namespace: ${deviation["namespace.name"]}`,
      `Kind: ${deviation.kind || 'Deviation'}`,
      `API Version: ${deviation.apiVersion || 'v1'}`
    ].join('\n');

    // Use theme icon from statusUtils
    item.iconPath = resourceStatusService.getStatusIcon('blue');

    item.command = {
      command: 'vscode-eda.showDeviationDetails',
      title: 'Show Deviation Details',
      arguments: [deviation]
    };

    return item;
  }

  private noDeviationsItem(extraText = ''): DeviationTreeItem {
    const label = extraText ? `No Deviations Found ${extraText}` : `No Deviations Found`;
    const item = new DeviationTreeItem(label, vscode.TreeItemCollapsibleState.None, 'info');

    // Use standard status icon from statusUtils
    item.iconPath = resourceStatusService.getStatusIcon('gray');

    return item;
  }
}

export class DeviationTreeItem extends TreeItemBase {
  constructor(
    label: string,
    collapsibleState: vscode.TreeItemCollapsibleState,
    contextValue: string,
    public deviation?: EdaDeviation
  ) {
    super(label, collapsibleState, contextValue, deviation);
  }
}
=== ./src/providers/views/namespaceProvider.ts ===
import * as vscode from 'vscode';
import * as path from 'path';
import { KubernetesService } from '../../services/kubernetes/kubernetes';
import { log, LogLevel, globalTreeFilter } from '../../extension.js';
import { TreeItemBase } from './common/treeItem';
import { resourceStore, resourceStatusService  } from '../../extension.js';

export class EdaNamespaceProvider implements vscode.TreeDataProvider<NamespaceTreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<NamespaceTreeItem | undefined | null | void>
    = new vscode.EventEmitter<NamespaceTreeItem | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<NamespaceTreeItem | undefined | null | void>
    = this._onDidChangeTreeData.event;

  constructor(
    private context: vscode.ExtensionContext,
    private k8sService: KubernetesService
  ) {
    // Listen for resource store changes
    resourceStore.onDidChangeResources(changes => {
      // Only refresh the tree if there are namespace-related changes
      const namespaceChanges = changes.filter(change =>
        change.item.namespace !== 'eda-system' &&
        change.item.kind !== 'Transaction'
      );

      if (namespaceChanges.length > 0) {
        this.refresh();
      }
    });

    // Listen for namespace reloads
    resourceStore.onDidReloadNamespace(namespace => {
      if (namespace !== 'eda-system') {
        this.refresh();
      }
    });
  }


  // Called by extension or user refresh
  refresh(): void {
    log("EdaNamespaceProvider: Refresh called", LogLevel.DEBUG);
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: NamespaceTreeItem): vscode.TreeItem {
    return element;
  }

  async getChildren(element?: NamespaceTreeItem): Promise<NamespaceTreeItem[]> {
    try {
      // If no filter => use normal lazy approach
      if (!globalTreeFilter) {
        return await this.getChildrenLazy(element);
      }
      // Else do BFS filter approach
      return await this.getChildrenFiltered(element, globalTreeFilter);
    } catch (error) {
      log(`EdaNamespaceProvider: Error loading children: ${error}`, LogLevel.ERROR, true);
      vscode.window.showErrorMessage(`${error}`);
      return [];
    }
  }

  /**
   * Lazy approach from your original code
   */
  private async getChildrenLazy(element?: NamespaceTreeItem): Promise<NamespaceTreeItem[]> {
    if (!element) {
      // root => EDA namespaces (excluding eda-system)
      return this.getNamespaceItems();
    }
    if (element.contextValue === 'namespace') {
      return this.getResourceCategoriesForNamespace(element.label);
    }
    if (element.contextValue === 'resource-category') {
      const ns = element.namespace;
      if (ns) {
        if (element.resourceCategory === 'NPP Pods') {
          return this.getNppPodsForNamespace(ns);
        } else {
          return this.getCrdTypesForGroup(ns, element.resourceCategory!);
        }
      }
    }
    if (element.contextValue === 'crd-type') {
      if (element.namespace && element.crdInfo) {
        return this.getCrdInstances(element.namespace, element.crdInfo);
      }
    }
    return [];
  }

  /**
   * Filter BFS approach:
   *  - If nodes label matches => keep it, and do shallow expansions only if user expands it in the UI
   *  - If nodes label doesnt match => we do a BFS expansion of its children to see if any child matches
   */

  private async getChildrenFiltered(element: NamespaceTreeItem | undefined, filter: string): Promise<NamespaceTreeItem[]> {
    const lowerFilter = filter.toLowerCase();

    // If no element (root level), filter namespaces
    if (!element) {
      const namespaces = await this.getNamespaceItems();
      const result: NamespaceTreeItem[] = [];

      for (const namespace of namespaces) {
        // Direct match on namespace name
        if (namespace.label.toLowerCase().includes(lowerFilter)) {
          result.push(namespace);
          continue;
        }

        // Check if any resources in this namespace match
        if (resourceStore.isNamespaceLoaded(namespace.namespace || '')) {
          const hasMatchingResources = resourceStore.filterResourcesInNamespace(
            namespace.namespace || '', filter
          ).length > 0;

          if (hasMatchingResources) {
            result.push(namespace);
          }
        }
      }

      return result;
    }

    // If we're at a namespace level, filter resource categories
    if (element.contextValue === 'namespace' && element.namespace) {
      // Ensure namespace is loaded
      if (!resourceStore.isNamespaceLoaded(element.namespace)) {
        await resourceStore.loadNamespaceResources(element.namespace);
      }

      // Get all categories
      const allCategories = await this.getResourceCategoriesForNamespace(element.namespace);
      const result: NamespaceTreeItem[] = [];

      // Filter categories based on name or content
      for (const category of allCategories) {
        // Direct match on category name - include the category itself
        if (category.label.toLowerCase().includes(lowerFilter)) {
          result.push(category);
          continue;
        }

        // For NPP Pods
        if (category.resourceCategory === 'NPP Pods') {
          // Check if the "NPP Pods" category name itself contains the filter term
          if ("npp pods".includes(lowerFilter) || "pods".includes(lowerFilter)) {
            const newCategory = this.copyTreeItem(category);
            const nppPods = resourceStore.getNppPodsForNamespace(element.namespace);
            newCategory.description = `${nppPods.length} pods`;
            result.push(newCategory);
            continue;
          }

          const nppPods = resourceStore.getNppPodsForNamespace(element.namespace);
          const matchingPods = nppPods.filter(pod =>
            pod.name.toLowerCase().includes(lowerFilter)
          );

          if (matchingPods.length > 0) {
            const newCategory = this.copyTreeItem(category);
            newCategory.description = `${matchingPods.length} matching pods`;
            result.push(newCategory);
          }
          continue;
        }

        // For CRD groups
        if (category.resourceCategory && category.resourceCategory !== 'NPP Pods') {
          const group = category.resourceCategory;

          // If the category or any variation of its name matches the filter, show all resources
          if (category.resourceCategory.toLowerCase().includes(lowerFilter) ||
              group.toLowerCase().includes(lowerFilter)) {
            const resources = resourceStore.getResourcesForGroup(element.namespace, group);
            if (resources.length > 0) {
              const newCategory = this.copyTreeItem(category);
              newCategory.description = `${resources.length} resources`;
              result.push(newCategory);
            }
            continue;
          }

          // Otherwise, check if any resources in the group match the filter
          const resources = resourceStore.getResourcesForGroup(element.namespace, group);
          const matchingResources = resources.filter(r =>
            r.name.toLowerCase().includes(lowerFilter) ||
            r.kind.toLowerCase().includes(lowerFilter)
          );

          if (matchingResources.length > 0) {
            const newCategory = this.copyTreeItem(category);
            newCategory.description = `${matchingResources.length} matching resources`;
            result.push(newCategory);
          }
        }
      }

      return result;
    }

    // If we're at a resource category level, filter resource kinds/instances
    if (element.contextValue === 'resource-category' && element.namespace) {
      if (element.resourceCategory === 'NPP Pods') {
        // Filter NPP pods
        const nppPods = await this.getNppPodsForNamespace(element.namespace);

        // If "pods" is in the filter, show all pods
        if ("pods".includes(lowerFilter)) {
          return nppPods;
        }

        return nppPods.filter(pod =>
          pod.label.toLowerCase().includes(lowerFilter)
        );
      } else if (element.resourceCategory) {
        // Filter CRD types for group
        const crdTypes = await this.getCrdTypesForGroup(element.namespace, element.resourceCategory);
        const result: NamespaceTreeItem[] = [];

        // If the resourceCategory contains the filter term, show all types
        if (element.resourceCategory.toLowerCase().includes(lowerFilter)) {
          return crdTypes;
        }

        for (const crdType of crdTypes) {
          // Direct match on CRD type name
          if (crdType.label.toLowerCase().includes(lowerFilter)) {
            result.push(crdType);
            continue;
          }

          // Check if any instances match
          if (crdType.crdInfo) {
            const instances = await this.getCrdInstances(element.namespace, crdType.crdInfo);
            const matchingInstances = instances.filter(instance =>
              instance.label.toLowerCase().includes(lowerFilter)
            );

            if (matchingInstances.length > 0) {
              const newType = this.copyTreeItem(crdType);
              newType.description = `${matchingInstances.length} matching instances`;
              result.push(newType);
            }
          }
        }

        return result;
      }
    }

    // If we're at a CRD type level, filter CRD instances
    if (element.contextValue === 'crd-type' && element.namespace && element.crdInfo) {
      const instances = await this.getCrdInstances(element.namespace, element.crdInfo);

      // If the CRD type name contains the filter, show all instances
      if (element.label.toLowerCase().includes(lowerFilter) ||
          element.crdInfo.kind.toLowerCase().includes(lowerFilter)) {
        return instances;
      }

      return instances.filter(instance =>
        instance.label.toLowerCase().includes(lowerFilter)
      );
    }

    // Default: no children or no match
    return [];
  }

  // Helper to clone a tree item
  private copyTreeItem(item: NamespaceTreeItem): NamespaceTreeItem {
    const newItem = new NamespaceTreeItem(
      item.label,
      item.collapsibleState,
      item.contextValue,
      item.resource
    );
    newItem.namespace = item.namespace;
    newItem.resourceCategory = item.resourceCategory;
    newItem.crdInfo = item.crdInfo;
    newItem.tooltip = item.tooltip;
    newItem.description = item.description;
    newItem.iconPath = item.iconPath;
    newItem.command = item.command;
    return newItem;
  }

  /**
   * Original code for retrieving data
   */
  private async getNamespaceItems(): Promise<NamespaceTreeItem[]> {
    log("EdaNamespaceProvider: getNamespaceItems()", LogLevel.DEBUG);
    const namespaces = await this.k8sService.getEdaNamespaces();

    // Process all namespaces in parallel for initial load
    const loadPromises = [];
    for (const ns of namespaces) {
      if (ns !== 'eda-system' && !resourceStore.isNamespaceLoaded(ns)) {
        loadPromises.push(resourceStore.loadNamespaceResources(ns));
      }
    }

    // Wait for all namespace loads to complete
    if (loadPromises.length > 0) {
      await Promise.all(loadPromises);
    }

    // Create tree items
    return namespaces
      .filter(ns => ns !== 'eda-system')
      .map(ns => {
        const item = new NamespaceTreeItem(
          ns,
          vscode.TreeItemCollapsibleState.Collapsed,
          'namespace'
        );
        item.namespace = ns;
        item.tooltip = `Namespace: ${ns}`;
        return item;
      });
  }

  // Update the Resource Categories method
  private async getResourceCategoriesForNamespace(namespace: string): Promise<NamespaceTreeItem[]> {
    log(`EdaNamespaceProvider: getResourceCategoriesForNamespace('${namespace}')`, LogLevel.DEBUG);

    // Ensure namespace is loaded
    if (!resourceStore.isNamespaceLoaded(namespace)) {
      await resourceStore.loadNamespaceResources(namespace);
    }

    const categories: NamespaceTreeItem[] = [];

    // Check for NPP pods directly from the store
    const nppPods = resourceStore.getNppPodsForNamespace(namespace);
    if (nppPods.length > 0) {
      categories.push(this.createResourceCategoryItem('NPP Pods', namespace));
    }

    // Get CRD groups with instances directly from the store
    const groups = resourceStore.getAvailableGroupsInNamespace(namespace);
    for (const group of groups) {
      const friendly = this.makeFriendlyGroupName(group);
      const catItem = this.createResourceCategoryItem(friendly, namespace);
      catItem.resourceCategory = group;
      categories.push(catItem);
    }

    return categories;
  }

  private createResourceCategoryItem(label: string, namespace: string): NamespaceTreeItem {
    const item = new NamespaceTreeItem(
      label,
      vscode.TreeItemCollapsibleState.Collapsed,
      'resource-category'
    );
    item.namespace = namespace;
    item.resourceCategory = label;
    item.tooltip = `${label} in ${namespace}`;
    return item;
  }

  private makeFriendlyGroupName(group: string): string {
    const first = group.split('.')[0];
    if (!first) return group;
    return first.charAt(0).toUpperCase() + first.slice(1);
  }

  private async getNppPodsForNamespace(namespace: string): Promise<NamespaceTreeItem[]> {
    const pods = await this.k8sService.getNppPodsForNamespace(namespace);
    if (pods.length === 0) {
      return [this.createNoResourcesFoundItem('NPP pods')];
    }
    return pods.map(pod => {
      const name = pod.metadata?.name || '';
      const status = pod.status?.phase || 'Unknown';
      const nodeName = name;
      const item = new NamespaceTreeItem(
        nodeName,
        vscode.TreeItemCollapsibleState.None,
        'npp-pod',
        pod
      );
      item.iconPath = resourceStatusService.getResourceStatusIcon(pod);
      item.description = resourceStatusService.getStatusDescription(pod);
      item.tooltip = resourceStatusService.getResourceTooltip(pod);

      item.command = {
        command: 'vscode-eda.viewResource',
        title: 'View Resource',
        arguments: [item]
      };
      return item;
    });
  }

  private async getCrdTypesForGroup(ns: string, group: string): Promise<NamespaceTreeItem[]> {
    const crds = await this.k8sService.getCrdsForGroup(group);
    const instancesSet = await this.k8sService.batchCheckCrdInstances(ns, crds);
    if (instancesSet.size === 0) {
      return [this.createNoResourcesFoundItem(`CRDs in ${this.makeFriendlyGroupName(group)}`)];
    }
    return crds
      .filter(c => instancesSet.has(c.kind))
      .map(crd => {
        const item = new NamespaceTreeItem(
          crd.kind,
          vscode.TreeItemCollapsibleState.Collapsed,
          'crd-type'
        );
        item.namespace = ns;
        item.crdInfo = crd;
        item.tooltip = `Kind: ${crd.kind}\nName: ${crd.name}\nGroup: ${crd.apiGroup}\nNamespace: ${ns}`;
        return item;
      });
  }

  private async getCrdInstances(ns: string, crdInfo: any): Promise<NamespaceTreeItem[]> {
    try {
      const inst = await this.k8sService.getCrdInstances(ns, crdInfo);
      if (inst.length === 0) {
        return [this.createNoResourcesFoundItem(`${crdInfo.kind} instances`)];
      }
      return inst.map(obj => {
        const name = obj.metadata?.name || 'unnamed';
        const item = new NamespaceTreeItem(
          name,
          vscode.TreeItemCollapsibleState.None,
          'crd-instance',
          obj
        );

        item.iconPath = resourceStatusService.getResourceStatusIcon(obj);
        item.description = resourceStatusService.getStatusDescription(obj);
        item.tooltip = resourceStatusService.getResourceTooltip(obj);

        this.createResourceTreeItemCommand(item, obj);
        return item;
      });
    } catch (error) {
      log(`Failed to get CRD Instances for ${crdInfo.kind} in ${ns}: ${error}`, LogLevel.ERROR);
      return [this.createNoResourcesFoundItem(`${crdInfo.kind} instances`)];
    }
  }

  private createNoResourcesFoundItem(name: string): NamespaceTreeItem {
    const item = new NamespaceTreeItem(
      `No ${name} found`,
      vscode.TreeItemCollapsibleState.None,
      'info'
    );

    // Use standard gray status icon
    item.iconPath = resourceStatusService.getStatusIcon('gray');

    return item;
  }

  private createResourceTreeItemCommand(item: NamespaceTreeItem, resource: any): void {
    if (resource && resource.kind && resource.metadata?.name) {
      const ns = resource.metadata.namespace || item.namespace;
      item.command = {
        command: 'vscode-eda.viewResource',
        title: 'View Resource',
        arguments: [{
          kind: resource.kind,
          name: resource.metadata.name,
          namespace: ns
        }]
      };
    }
  }
}

export class NamespaceTreeItem extends TreeItemBase {
  public children?: NamespaceTreeItem[];
}

=== ./src/providers/views/systemProvider.ts ===
import * as vscode from 'vscode';
import { execSync } from 'child_process';
import { KubernetesService } from '../../services/kubernetes/kubernetes';
import { log, LogLevel, globalTreeFilter } from '../../extension.js';
import { TreeItemBase } from './common/treeItem';
import { resourceStatusService } from '../../extension.js';
import { resourceStore } from '../../extension.js';

export class EdaSystemProvider implements vscode.TreeDataProvider<SystemTreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<SystemTreeItem | undefined | null | void>
    = new vscode.EventEmitter<SystemTreeItem | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<SystemTreeItem | undefined | null | void>
    = this._onDidChangeTreeData.event;

  private systemNamespace = 'eda-system';

  constructor(
    private context: vscode.ExtensionContext,
    private k8sService: KubernetesService
  ) {
    // Listen for system namespace changes
    resourceStore.onDidChangeResources(changes => {
      // Only refresh if changes affect the system namespace
      const systemChanges = changes.filter(change =>
        change.item.namespace === 'eda-system'
      );

      if (systemChanges.length > 0) {
        this.refresh();
      }
    });

    // Listen for system namespace reloads
    resourceStore.onDidReloadNamespace(namespace => {
      if (namespace === 'eda-system') {
        this.refresh();
      }
    });
  }

  refresh(): void {
    log("EdaSystemProvider: refresh called", LogLevel.DEBUG);
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: SystemTreeItem): vscode.TreeItem {
    return element;
  }

  async getChildren(element?: SystemTreeItem): Promise<SystemTreeItem[]> {
    if (!globalTreeFilter) {
      // No filter => normal lazy
      return await this.getChildrenLazy(element);
    } else {
      // BFS filter approach
      return await this.getChildrenFiltered(element, globalTreeFilter);
    }
  }

  /**
   * Original lazy approach
   */
  private async getChildrenLazy(element?: SystemTreeItem): Promise<SystemTreeItem[]> {
    if (!element) {
      return this.getSystemResourceCategories();
    }
    if (element.contextValue === 'k8s-category') {
      return this.getKubernetesResourceTypes();
    }
    if (element.contextValue === 'resource-type' && element.resourceType) {
      return this.loadResourceItems(element.resourceType);
    }
    if (element.contextValue === 'eda-category') {
      return this.getEdaCrdGroups();
    }
    if (element.contextValue === 'crd-group' && element.crdGroup) {
      return this.loadCrdTypes(element.crdGroup);
    }
    if (element.contextValue === 'crd-type' && element.crdInfo) {
      return this.loadCrdInstances(element.crdInfo);
    }
    return [];
  }

  /**
   * BFS approach to find matches
   */
  private async getChildrenFiltered(element: SystemTreeItem | undefined, filter: string): Promise<SystemTreeItem[]> {
    const lowerFilter = filter.toLowerCase();

    // If root level, filter the top-level categories
    if (!element) {
      const categories = await this.getSystemResourceCategories();

      // For top-level categories, we need to check if any of their children match
      const result: SystemTreeItem[] = [];

      for (const category of categories) {
        // Direct match on category name
        if (category.label.toLowerCase().includes(lowerFilter)) {
          result.push(category);
          continue;
        }

        // Check children
        let matchingChildren: SystemTreeItem[] = [];

        if (category.contextValue === 'k8s-category') {
          // Get k8s resource types and check if any match
          const resourceTypes = await this.getKubernetesResourceTypes();
          matchingChildren = await this.filterItems(resourceTypes, filter);
        }
        else if (category.contextValue === 'eda-category') {
          // Get CRD groups and check if any match
          const crdGroups = await this.getEdaCrdGroups();
          matchingChildren = await this.filterItems(crdGroups, filter);
        }

        if (matchingChildren.length > 0) {
          const newCategory = this.copySystemTreeItem(category);
          newCategory.description = `${matchingChildren.length} matching items`;
          result.push(newCategory);
        }
      }

      return result;
    }

    // Handle k8s-category
    if (element.contextValue === 'k8s-category') {
      // If "kubernetes" or "resources" is in the filter, show all resource types
      if ("kubernetes".includes(lowerFilter) || "resources".includes(lowerFilter)) {
        return await this.getKubernetesResourceTypes();
      }

      const resourceTypes = await this.getKubernetesResourceTypes();
      return this.filterItems(resourceTypes, filter);
    }

    // Handle eda-category
    if (element.contextValue === 'eda-category') {
      // If "eda" is in the filter, show all EDA resources
      if ("eda".includes(lowerFilter) || "resources".includes(lowerFilter)) {
        return await this.getEdaCrdGroups();
      }

      const crdGroups = await this.getEdaCrdGroups();
      return this.filterItems(crdGroups, filter);
    }

    // Handle resource-type
    if (element.contextValue === 'resource-type' && element.resourceType) {
      if (element.resourceType.toLowerCase().includes(lowerFilter) ||
          element.label.toLowerCase().includes(lowerFilter)) {
        return await this.loadResourceItems(element.resourceType);
      }

      const resources = await this.loadResourceItems(element.resourceType);
      return resources.filter(r =>
        r.label.toLowerCase().includes(lowerFilter)
      );
    }

    // Handle crd-group
    if (element.contextValue === 'crd-group' && element.crdGroup) {
      if (element.crdGroup.toLowerCase().includes(lowerFilter) ||
          element.label.toLowerCase().includes(lowerFilter) ||
          this.makeFriendlyGroupName(element.crdGroup).toLowerCase().includes(lowerFilter)) {
        return await this.loadCrdTypes(element.crdGroup);
      }

      const crdTypes = await this.loadCrdTypes(element.crdGroup);
      const result: SystemTreeItem[] = [];

      for (const crdType of crdTypes) {
        // Direct match on CRD type name
        if (crdType.label.toLowerCase().includes(lowerFilter)) {
          result.push(crdType);
          continue;
        }

        // Check if any instances match
        if (crdType.crdInfo) {
          const instances = await this.loadCrdInstances(crdType.crdInfo);
          const matchingInstances = instances.filter(instance =>
            instance.label.toLowerCase().includes(lowerFilter)
          );

          if (matchingInstances.length > 0) {
            const newType = this.copySystemTreeItem(crdType);
            newType.description = `${matchingInstances.length} matching instances`;
            result.push(newType);
          }
        }
      }

      return result;
    }

    // Handle crd-type
    if (element.contextValue === 'crd-type' && element.crdInfo) {
      if (element.label.toLowerCase().includes(lowerFilter) ||
          element.crdInfo.kind.toLowerCase().includes(lowerFilter)) {
        return await this.loadCrdInstances(element.crdInfo);
      }

      const instances = await this.loadCrdInstances(element.crdInfo);
      return instances.filter(instance =>
        instance.label.toLowerCase().includes(lowerFilter)
      );
    }

    return [];
  }

  // Helper method to filter items and check their children recursively
  private async filterItems(items: SystemTreeItem[], filter: string): Promise<SystemTreeItem[]> {
    const lowerFilter = filter.toLowerCase();
    const result: SystemTreeItem[] = [];

    for (const item of items) {
      // Direct match on item name
      if (item.label.toLowerCase().includes(lowerFilter)) {
        result.push(item);
        continue;
      }

      // Check children
      let hasMatchingChildren = false;

      if (item.contextValue === 'resource-type' && item.resourceType) {
        if (item.resourceType.toLowerCase().includes(lowerFilter)) {
          result.push(item);
          continue;
        }

        const resources = await this.loadResourceItems(item.resourceType);
        hasMatchingChildren = resources.some(r =>
          r.label.toLowerCase().includes(lowerFilter)
        );
      }
      else if (item.contextValue === 'crd-group' && item.crdGroup) {
        if (item.crdGroup.toLowerCase().includes(lowerFilter) ||
            this.makeFriendlyGroupName(item.crdGroup).toLowerCase().includes(lowerFilter)) {
          result.push(item);
          continue;
        }

        const crdTypes = await this.loadCrdTypes(item.crdGroup);
        for (const crdType of crdTypes) {
          if (crdType.label.toLowerCase().includes(lowerFilter)) {
            hasMatchingChildren = true;
            break;
          }
          if (crdType.crdInfo) {
            const instances = await this.loadCrdInstances(crdType.crdInfo);
            if (instances.some(i => i.label.toLowerCase().includes(lowerFilter))) {
              hasMatchingChildren = true;
              break;
            }
          }
        }
      }

      if (hasMatchingChildren) {
        const newItem = this.copySystemTreeItem(item);
        newItem.description = "Has matching resources";
        result.push(newItem);
      }
    }

    return result;
  }

  // Helper to clone a tree item
  private copySystemTreeItem(item: SystemTreeItem): SystemTreeItem {
    const newItem = new SystemTreeItem(
      item.label,
      item.collapsibleState,
      item.contextValue,
      item.resource
    );
    newItem.crdGroup = item.crdGroup;
    newItem.resourceType = item.resourceType;
    newItem.crdInfo = item.crdInfo;
    newItem.tooltip = item.tooltip;
    newItem.description = item.description;
    newItem.iconPath = item.iconPath;
    newItem.command = item.command;
    return newItem;
  }

  /**
   * Original code for normal lazy expansions
   */
  private async getSystemResourceCategories(): Promise<SystemTreeItem[]> {
    return [
      new SystemTreeItem("Kubernetes Resources", vscode.TreeItemCollapsibleState.Expanded, "k8s-category"),
      new SystemTreeItem("EDA Resources", vscode.TreeItemCollapsibleState.Expanded, "eda-category")
    ];
  }

  private async getKubernetesResourceTypes(): Promise<SystemTreeItem[]> {
    // Ensure system namespace is loaded
    if (!resourceStore.isNamespaceLoaded(this.systemNamespace)) {
      await resourceStore.loadNamespaceResources(this.systemNamespace);
    }

    // Get available resource types directly from store
    const resourceTypes = ['Pods', 'Services', 'Deployments', 'ConfigMaps', 'Secrets']
      .filter(rt => {
        if (rt === 'Pods') {
          return resourceStore.getResourcesByKind(this.systemNamespace, 'Pod').length > 0;
        }
        if (rt === 'Services') {
          return resourceStore.getResourcesByKind(this.systemNamespace, 'Service').length > 0;
        }
        if (rt === 'Deployments') {
          return resourceStore.getResourcesByKind(this.systemNamespace, 'Deployment').length > 0;
        }
        if (rt === 'ConfigMaps') {
          return resourceStore.getResourcesByKind(this.systemNamespace, 'ConfigMap').length > 0;
        }
        if (rt === 'Secrets') {
          return resourceStore.getResourcesByKind(this.systemNamespace, 'Secret').length > 0;
        }
        return true; // fallback
      });

    return resourceTypes.map(rt => {
      const item = new SystemTreeItem(
        rt,
        vscode.TreeItemCollapsibleState.Collapsed,
        'resource-type'
      );
      item.resourceType = rt;
      item.tooltip = `${rt} in ${this.systemNamespace}`;
      return item;
    });
  }

  private async loadResourceItems(rt: string): Promise<SystemTreeItem[]> {
    log(`System: loadResourceItems('${rt}')`, LogLevel.DEBUG);

    // Ensure system namespace is loaded
    if (!resourceStore.isNamespaceLoaded(this.systemNamespace)) {
      await resourceStore.loadNamespaceResources(this.systemNamespace);
    }

    let resources: any[] = [];

    switch (rt) {
      case 'Pods':
        resources = resourceStore.getResourcesByKind(this.systemNamespace, 'Pod').map(item => item.resource);
        break;
      case 'Services':
        resources = resourceStore.getResourcesByKind(this.systemNamespace, 'Service').map(item => item.resource);
        break;
      case 'Deployments':
        resources = resourceStore.getResourcesByKind(this.systemNamespace, 'Deployment').map(item => item.resource);
        break;
      case 'ConfigMaps':
        resources = resourceStore.getResourcesByKind(this.systemNamespace, 'ConfigMap').map(item => item.resource);
        break;
      case 'Secrets':
        resources = resourceStore.getResourcesByKind(this.systemNamespace, 'Secret').map(item => item.resource);
        break;
      default:
        return this.renderGenericResources(rt);
    }

    // Render the resources using the unified approach
    return this.renderResources(resources, rt.toLowerCase().endsWith('s') ? rt.slice(0, -1).toLowerCase() : rt.toLowerCase());
  }

  private async getEdaCrdGroups(): Promise<SystemTreeItem[]> {
    log("System: getEdaCrdGroups()", LogLevel.DEBUG);

    // Ensure system namespace is loaded
    if (!resourceStore.isNamespaceLoaded(this.systemNamespace)) {
      await resourceStore.loadNamespaceResources(this.systemNamespace);
    }

    // Get available groups directly from store
    const groups = resourceStore.getAvailableGroupsInNamespace(this.systemNamespace);

    const items: SystemTreeItem[] = [];
    for (const group of groups) {
      const friendly = this.makeFriendlyGroupName(group);
      const it = new SystemTreeItem(
        friendly,
        vscode.TreeItemCollapsibleState.Collapsed,
        'crd-group'
      );
      it.crdGroup = group;
      it.tooltip = `${friendly} in ${this.systemNamespace}`;
      items.push(it);
    }

    if (!items.length) {
      return [this.noItems("EDA resources")];
    }

    return items;
  }

  private async loadCrdTypes(group: string): Promise<SystemTreeItem[]> {
    const crds = await this.k8sService.getCrdsForGroup(group);
    const instSet = await this.k8sService.batchCheckCrdInstances(this.systemNamespace, crds);
    if (instSet.size === 0) {
      return [this.noItems(`CRDs in ${this.makeFriendlyGroupName(group)}`)];
    }
    return crds
      .filter(crd => instSet.has(crd.kind))
      .map(crd => {
        const item = new SystemTreeItem(
          crd.kind,
          vscode.TreeItemCollapsibleState.Collapsed,
          'crd-type'
        );
        item.crdInfo = crd;
        item.tooltip = `Kind: ${crd.kind}\nName: ${crd.name}\nGroup: ${crd.apiGroup}\nNamespace: ${this.systemNamespace}`;
        return item;
      });
  }

  private async loadCrdInstances(crdInfo: any): Promise<SystemTreeItem[]> {
    log(`System: loadCrdInstances(${crdInfo.kind})`, LogLevel.DEBUG);
    try {
      const items = await this.k8sService.getCrdInstances(this.systemNamespace, crdInfo);
      if (!items.length) {
        return [this.noItems(`${crdInfo.kind} instances`)];
      }
      return items.map(obj => {
        const name = obj.metadata?.name || 'unnamed';
        const it = new SystemTreeItem(
          name,
          vscode.TreeItemCollapsibleState.None,
          'crd-instance',
          obj
        );
        // Delegate to resourceStatusService
        it.iconPath    = resourceStatusService.getResourceStatusIcon(obj);
        it.description = resourceStatusService.getStatusDescription(obj);
        it.tooltip     = resourceStatusService.getResourceTooltip(obj);

        this.createResourceTreeItemCommand(it, obj);
        return it;
      });
    } catch (err) {
      log(`System: error loading CRD instances for ${crdInfo.kind}: ${err}`, LogLevel.ERROR);
      return [this.noItems(`${crdInfo.kind} instances`)];
    }
  }

  private async renderGenericResources(resourceType: string): Promise<SystemTreeItem[]> {
    try {
      const kind = resourceType.endsWith('s') ? resourceType.slice(0, -1) : resourceType;
      const cmd = `${this.k8sService.getKubectlPath()} get ${resourceType.toLowerCase()} -n ${this.systemNamespace} -o json`;
      const output = execSync(cmd, { encoding: 'utf-8' });
      const resources = JSON.parse(output).items || [];
      if (!resources.length) {
        return [this.noItems(resourceType.toLowerCase())];
      }
      return resources.map((resource: any) => {
        const name = resource.metadata?.name || 'unnamed';
        // Ensure `kind` is set so resourceStatusService can properly detect it
        resource.kind = kind;

        const it = new SystemTreeItem(
          name,
          vscode.TreeItemCollapsibleState.None,
          resourceType.toLowerCase(),
          resource
        );
        // Delegate to resourceStatusService
        it.iconPath    = resourceStatusService.getResourceStatusIcon(resource);
        it.description = resourceStatusService.getStatusDescription(resource);
        it.tooltip     = resourceStatusService.getResourceTooltip(resource);

        this.createResourceTreeItemCommand(it, resource);
        return it;
      });
    } catch (error) {
      log(`System: error rendering ${resourceType}: ${error}`, LogLevel.ERROR);
      return [this.noItems(resourceType.toLowerCase())];
    }
  }

  private renderResources(resources: any[], contextValue: string): SystemTreeItem[] {
    if (!resources.length) {
      return [this.noItems(contextValue + 's')];
    }
    return resources.map(r => {
      const name = r.metadata?.name || 'unnamed';
      // Ensure resource has a kind for the status service
      if (!r.kind) {
        r.kind = this.getResourceKindFromContextValue(contextValue);
      }

      const it = new SystemTreeItem(
        name,
        vscode.TreeItemCollapsibleState.None,
        contextValue,
        r
      );

      // Delegate everything to resourceStatusService
      it.iconPath    = resourceStatusService.getResourceStatusIcon(r);
      it.description = resourceStatusService.getStatusDescription(r);
      it.tooltip     = resourceStatusService.getResourceTooltip(r);

      this.createResourceTreeItemCommand(it, r);
      return it;
    });
  }

  private noItems(msg: string): SystemTreeItem {
    const it = new SystemTreeItem(
      `No ${msg} found`,
      vscode.TreeItemCollapsibleState.None,
      'info'
    );
    // Just a gray icon to indicate "no items"
    it.iconPath = resourceStatusService.getStatusIcon('gray');
    return it;
  }

  private makeFriendlyGroupName(group: string): string {
    const first = group.split('.')[0];
    if (!first) return group;
    return first.charAt(0).toUpperCase() + first.slice(1);
  }

  private createResourceTreeItemCommand(item: SystemTreeItem, resource: any): void {
    if (resource) {
      const kind = resource.kind || this.getResourceKindFromContextValue(item.contextValue);
      const name = resource.metadata?.name;
      if (kind && name) {
        item.command = {
          command: 'vscode-eda.viewResource',
          title: 'View Resource',
          arguments: [{
            kind: kind,
            name: name,
            namespace: this.systemNamespace
          }]
        };
      }
    }
  }

  private getResourceKindFromContextValue(val: string): string {
    switch (val) {
      case 'pod': return 'Pod';
      case 'service': return 'Service';
      case 'deployment': return 'Deployment';
      case 'configmap': return 'ConfigMap';
      case 'secret': return 'Secret';
      default: return val.charAt(0).toUpperCase() + val.slice(1);
    }
  }
}

export class SystemTreeItem extends TreeItemBase {
  public crdGroup?: string;
//  public resourceType?: string;
  public children?: SystemTreeItem[];
}

=== ./src/providers/views/transactionProvider.ts ===
import * as vscode from 'vscode';
import { KubernetesService } from '../../services/kubernetes/kubernetes';
import { edaOutputChannel, LogLevel, log } from '../../extension.js';
import { TreeItemBase } from './common/treeItem';
import { resourceStatusService } from '../../extension.js';

export class EdaTransactionProvider implements vscode.TreeDataProvider<TransactionTreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<TransactionTreeItem | undefined | null | void> = new vscode.EventEmitter<TransactionTreeItem | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<TransactionTreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

  constructor(
    private context: vscode.ExtensionContext,
    private k8sService: KubernetesService
  ) {
  }

  refresh(): void {
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: TransactionTreeItem): vscode.TreeItem {
    return element;
  }

  async getChildren(element?: TransactionTreeItem): Promise<TransactionTreeItem[]> {
    if (element) {
      return [];
    }
    return this.getTransactionItems();
  }

  private async getTransactionItems(): Promise<TransactionTreeItem[]> {
    log(`Loading transactions for the transaction tree...`, LogLevel.DEBUG);
    const transactions = await this.k8sService.getEdaTransactions();

    // Sort transactions by ID (assuming higher ID = newer transaction)
    // This will display the newest transactions at the top
    transactions.sort((a, b) => {
      // Try numeric comparison first (most reliable if IDs are numeric)
      const idA = parseInt(a.id, 10);
      const idB = parseInt(b.id, 10);

      if (!isNaN(idA) && !isNaN(idB)) {
        return idB - idA; // Sort in descending order (newest first)
      }

      // If parsing as numbers fails, compare as strings
      return b.id.localeCompare(a.id);
    });

    return transactions.map(t => {
      const label = `${t.id} - ${t.username}`;
      const item = new TransactionTreeItem(
        label,
        vscode.TreeItemCollapsibleState.None,
        'transaction',
        t
      );
      if (t.result === 'OK') {
        item.description = `${t.age} - ${t.description || 'No description'}`;
      } else {
        item.description = `FAILED - ${t.age}`;
      }
      item.tooltip =
        `ID: ${t.id}\n` +
        `Result: ${t.result}\n` +
        `Age: ${t.age}\n` +
        `Detail Level: ${t.detail}\n` +
        `Dry Run: ${t.dryRun || 'No'}\n` +
        `Username: ${t.username}\n` +
        `Description: ${t.description || 'No description'}`;

      const success = t.result === 'OK';

      // Use transaction icon from statusUtils
      item.iconPath = resourceStatusService.getTransactionIcon(success);

      item.command = {
        command: 'vscode-eda.showTransactionDetails',
        title: 'Show Transaction Details',
        arguments: [t.id]
      };
      return item;
    });
  }
}

export class TransactionTreeItem extends TreeItemBase {}
=== ./src/providers/schema.ts ===
// src/providers/schemaProvider.ts
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import * as yaml from 'js-yaml';
import { KubernetesService } from '../services/kubernetes/kubernetes';
import { log, LogLevel } from '../extension.js';
import { K8sFileSystemProvider } from './documents/resourceProvider';

/**
 * Provides JSON schema support for Kubernetes CRDs
 */
export class SchemaProvider {
  private schemaCacheDir: string;
  private disposables: vscode.Disposable[] = [];
  private schemaCache = new Map<string, string>(); // Maps kind to schema file path

  constructor(private k8sService: KubernetesService) {
    // Create a directory for storing CRD schemas
    this.schemaCacheDir = path.join(os.tmpdir(), 'vscode-k8s-schemas');
    if (!fs.existsSync(this.schemaCacheDir)) {
      fs.mkdirSync(this.schemaCacheDir, { recursive: true });
    }
  }

  /**
   * Register the schema provider
   */
  public register(context: vscode.ExtensionContext): void {
    // Register command to refresh schemas
    this.disposables.push(
      vscode.commands.registerCommand('k8s.refreshSchemas', async () => {
        await this.updateSchemas();
      })
    );

    // Register document events
    this.disposables.push(
      vscode.workspace.onDidOpenTextDocument(this.handleDocument.bind(this)),
      vscode.workspace.onDidSaveTextDocument(this.handleDocument.bind(this))
    );

    // Initially update schemas
    this.updateSchemas().then(() => {
      // Apply schemas to all currently open documents
      vscode.workspace.textDocuments.forEach(this.handleDocument.bind(this));
    });

    // Add all disposables to context
    context.subscriptions.push(...this.disposables);

    log('Registered schema provider for YAML validation', LogLevel.INFO, true);
  }

  /**
   * Handle document events
   */
  private async handleDocument(document: vscode.TextDocument): Promise<void> {
    if (document.languageId !== 'yaml') {
      return;
    }

    try {
      // Check if this is a k8s document
      if (document.uri.scheme === 'k8s') {
        // Parse the k8s URI to get kind
        const parts = K8sFileSystemProvider.parseUri(document.uri);
        if (parts.kind) {
          await this.associateSchemaWithKind(document, parts.kind);
          return;
        }
      }

      // Otherwise try to parse the YAML to find kind
      const content = document.getText();
      try {
        const parsed = yaml.load(content) as any;
        if (parsed && parsed.kind) {
          await this.associateSchemaWithKind(document, parsed.kind);
        }
      } catch (e) {
        // Silently ignore YAML parsing errors
      }
    } catch (error) {
      log(`Error handling document: ${error}`, LogLevel.ERROR);
    }
  }

  /**
   * Associate schema with a document for a specific kind
   */
  private async associateSchemaWithKind(document: vscode.TextDocument, kind: string): Promise<void> {
    // Check if we have a schema for this kind
    if (!this.schemaCache.has(kind)) {
      // Try to get and cache the schema
      const schema = await this.getOrCreateSchemaForKind(kind);
      if (!schema) {
        log(`No schema available for kind: ${kind}`, LogLevel.WARN);
        return;
      }
    }

    // Get the schema file path
    const schemaPath = this.schemaCache.get(kind);
    if (!schemaPath) {
      return;
    }

    // Convert to file URI
    const schemaUri = vscode.Uri.file(schemaPath).toString();

    // Add schema comment to the document - this is the most reliable way
    await this.addSchemaComment(document, schemaUri);

    log(`Associated schema for ${kind} with document ${document.uri.toString()}`, LogLevel.DEBUG);
  }

  /**
   * Add schema comment to document
   */
  private async addSchemaComment(document: vscode.TextDocument, schemaUri: string): Promise<void> {
    try {
      // Check if already has schema comment
      const firstLine = document.lineAt(0).text;
      if (firstLine.includes('# yaml-language-server:')) {
        // If already has schema comment, check if it needs to be updated
        if (firstLine.includes(schemaUri)) {
          return; // Already has correct schema
        }

        // Update existing schema comment
        const edit = new vscode.WorkspaceEdit();
        edit.replace(
          document.uri,
          new vscode.Range(0, 0, 0, firstLine.length),
          `# yaml-language-server: $schema=${schemaUri}`
        );
        await vscode.workspace.applyEdit(edit);
        return;
      }

      // Add schema comment at the beginning
      const edit = new vscode.WorkspaceEdit();
      edit.insert(
        document.uri,
        new vscode.Position(0, 0),
        `# yaml-language-server: $schema=${schemaUri}\n`
      );
      await vscode.workspace.applyEdit(edit);
    } catch (error) {
      log(`Error adding schema comment: ${error}`, LogLevel.ERROR);
    }
  }

  /**
   * Get or create schema for a kind
   */
  private async getOrCreateSchemaForKind(kind: string): Promise<string | null> {
    try {
      // Check if we already have this schema
      if (this.schemaCache.has(kind)) {
        return this.schemaCache.get(kind) || null;
      }

      // Get schema from K8s service
      const schema = await this.k8sService.getCrdSchemaForKind(kind);
      if (!schema) {
        return null;
      }

      // Convert to proper JSON Schema
      const jsonSchema = this.convertToJsonSchema(schema, kind);

      // Save to file
      const schemaFileName = `${kind.toLowerCase()}.json`;
      const schemaFilePath = path.join(this.schemaCacheDir, schemaFileName);

      fs.writeFileSync(schemaFilePath, JSON.stringify(jsonSchema, null, 2));

      // Cache the schema file path
      this.schemaCache.set(kind, schemaFilePath);

      return schemaFilePath;
    } catch (error) {
      log(`Error getting schema for kind ${kind}: ${error}`, LogLevel.ERROR);
      return null;
    }
  }

  /**
   * Convert CRD schema to proper JSON Schema
   */
  private convertToJsonSchema(crdSchema: any, kind: string): any {
    // Create a proper JSON Schema
    const jsonSchema = {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "type": "object",
      "title": `Schema for ${kind}`,
      "description": crdSchema.description || `Schema for Kubernetes ${kind} resource`,
      "required": ["apiVersion", "kind", "metadata"],
      "additionalProperties": false, // Disallow unknown top-level fields
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "The API version for this resource"
        },
        "kind": {
          "type": "string",
          "enum": [kind],
          "description": "The resource kind"
        },
        "metadata": {
          "type": "object",
          "required": ["name"],
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the resource"
            },
            "namespace": {
              "type": "string",
              "description": "Namespace of the resource"
            },
            "labels": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "description": "Labels attached to the resource"
            },
            "annotations": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "description": "Annotations attached to the resource"
            }
          }
        },
        "spec": this.strictifySchema(crdSchema.properties?.spec || {}),
        "status": this.strictifySchema(crdSchema.properties?.status || {})
      }
    };

    return jsonSchema;
  }

  /**
   * Make schema strict by disallowing additional properties recursively
   */
  private strictifySchema(schema: any): any {
    if (!schema || typeof schema !== 'object') {
      return schema;
    }

    // If this is an object schema, add additionalProperties: false
    if (schema.type === 'object') {
      const result = { ...schema, additionalProperties: false };

      // Process properties recursively
      if (result.properties && typeof result.properties === 'object') {
        const newProperties: any = {};

        for (const key in result.properties) {
          newProperties[key] = this.strictifySchema(result.properties[key]);
        }

        result.properties = newProperties;
      }

      return result;
    }

    // If this is an array schema, process the items
    if (schema.type === 'array' && schema.items) {
      return {
        ...schema,
        items: this.strictifySchema(schema.items)
      };
    }

    // Handle anyOf, allOf, oneOf
    for (const key of ['anyOf', 'allOf', 'oneOf']) {
      if (schema[key] && Array.isArray(schema[key])) {
        const newSchema = { ...schema };
        newSchema[key] = schema[key].map((s: any) => this.strictifySchema(s));
        return newSchema;
      }
    }

    // For other types, just return as is
    return schema;
  }

  /**
   * Update all schemas from cluster
   */
  public async updateSchemas(): Promise<void> {
    try {
      log('Updating CRD schemas...', LogLevel.INFO);

      // Get all CRDs
      const crds = await this.k8sService.getCRDs();
      if (!crds || crds.length === 0) {
        log('No CRDs found in the cluster', LogLevel.WARN);
        return;
      }

      log(`Found ${crds.length} CRDs in the cluster`, LogLevel.INFO);

      // Process each CRD
      for (const crd of crds) {
        try {
          const kind = crd.spec?.names?.kind;
          if (!kind) {
            continue;
          }

          // Extract schema
          const schema = this.extractSchemaFromCRD(crd);
          if (!schema) {
            continue;
          }

          // Convert to JSON Schema
          const jsonSchema = this.convertToJsonSchema(schema, kind);

          // Save to file
          const schemaFileName = `${kind.toLowerCase()}.json`;
          const schemaFilePath = path.join(this.schemaCacheDir, schemaFileName);

          fs.writeFileSync(schemaFilePath, JSON.stringify(jsonSchema, null, 2));

          // Cache the schema file path
          this.schemaCache.set(kind, schemaFilePath);

          log(`Cached schema for ${kind}`, LogLevel.DEBUG);
        } catch (error) {
          log(`Error processing CRD ${crd.metadata?.name}: ${error}`, LogLevel.ERROR);
        }
      }

      // Update all open documents
      vscode.workspace.textDocuments.forEach(this.handleDocument.bind(this));

      log('CRD schemas updated successfully', LogLevel.INFO);
    } catch (error) {
      log(`Error updating schemas: ${error}`, LogLevel.ERROR);
    }
  }

  /**
   * Extract schema from CRD
   */
  private extractSchemaFromCRD(crd: any): any {
    try {
      // Find the schema
      let schema = null;

      if (crd.spec?.versions && Array.isArray(crd.spec.versions)) {
        // Find the version marked as storage or the first one
        const version = crd.spec.versions.find((v: any) => v.storage === true) ||
                        crd.spec.versions[0];

        if (version?.schema?.openAPIV3Schema) {
          schema = version.schema.openAPIV3Schema;
        }
      }

      if (!schema) {
        // Legacy format
        if (crd.spec?.validation?.openAPIV3Schema) {
          schema = crd.spec.validation.openAPIV3Schema;
        }
      }

      return schema;
    } catch (error) {
      log(`Error extracting schema from CRD: ${error}`, LogLevel.ERROR);
      return null;
    }
  }

  /**
   * Dispose all resources
   */
  public dispose(): void {
    for (const disposable of this.disposables) {
      disposable.dispose();
    }
    this.disposables = [];
  }
}

=== ./src/services/kubernetes/clusterManager.ts ===
// src/services/kubernetes/clusterManager.ts
import * as vscode from 'vscode';
import { BaseK8sService } from './baseK8sService';
import { log, LogLevel } from '../../extension.js';

export class ClusterManager {
  private statusBarItem: vscode.StatusBarItem;
  private k8sService: BaseK8sService;

  constructor(k8sService: BaseK8sService) {
    this.k8sService = k8sService;
    this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
    this.statusBarItem.command = 'vscode-eda.switchCluster';
    this.statusBarItem.tooltip = 'Click to switch Kubernetes cluster';
    this.updateStatusBar();
    this.statusBarItem.show();
  }

  /**
   * Update the status bar item with the current cluster name
   */
  public updateStatusBar(): void {
    const currentContext = this.k8sService.getCurrentContext();

    // Get the cluster name associated with this context
    const clusterName = this.getClusterNameForContext(currentContext);

    // Update text with the new format
    this.statusBarItem.text = `$(kubernetes) EDA: ${currentContext}`;

    // Update tooltip with both context and cluster name
    this.statusBarItem.tooltip = `Context: ${currentContext}\nCluster: ${clusterName}\n\nClick to switch Kubernetes cluster`;
  }

  /**
   * Get all available cluster contexts
   */
  public getAvailableContexts(): string[] {
    return this.k8sService.getAvailableContexts();
  }

  /**
   * Switch to a different cluster context
   */
  public async switchContext(contextName: string): Promise<boolean> {
    try {
      await this.k8sService.useContext(contextName);
      this.updateStatusBar();
      return true;
    } catch (error) {
      log(`Failed to switch to cluster context ${contextName}: ${error}`, LogLevel.ERROR, true);
      return false;
    }
  }

/**
 * Get the cluster name for the given context
 */
private getClusterNameForContext(contextName: string): string {
  try {
    // This assumes k8sService has access to the KubeConfig
    const contexts = (this.k8sService as any).kc.getContexts();
    const context = contexts.find((ctx: any) => ctx.name === contextName);

    if (context && context.context && context.context.cluster) {
      return context.context.cluster;
    }

    return "Unknown";
  } catch (error) {
    log(`Error getting cluster name for context ${contextName}: ${error}`, LogLevel.ERROR);
    return "Unknown";
  }
}

  /**
   * Dispose the status bar item
   */
  public dispose(): void {
    this.statusBarItem.dispose();
  }
}
=== ./src/services/kubernetes/toolboxService.ts ===
// src/k8s/toolboxService.ts
import { BaseK8sService } from './baseK8sService';
import { LogLevel, log } from '../../extension.js';
import { executeKubectl } from '../../utils/resourceUtils';
import { cache } from '../../utils/cacheUtils';

export class ToolboxService extends BaseK8sService {
  constructor() {
    super();
  }

  /**
   * Find the toolbox pod name, cached for 60 seconds.
   */
  private async findToolboxPodCached(): Promise<string> {
    return cache.getOrFetch<string>(
      'toolbox',
      'pod-name',
      async () => {
        log(`Looking for eda-toolbox pod in namespace '${this.toolboxNamespace}'...`, LogLevel.INFO);

        // 1) Attempt multiple label selectors
        const labelSelectors = [
          'eda.nokia.com/app=eda-toolbox',
          'app=eda-toolbox',
          'app.kubernetes.io/name=eda-toolbox',
        ];
        for (const selector of labelSelectors) {
          const pods = await this.k8sApi.listNamespacedPod({
            namespace: this.toolboxNamespace,
            labelSelector: selector
          });
          if (pods.items.length > 0) {
            const podName = pods.items[0].metadata!.name!;
            log(`Found toolbox pod: ${podName} using selector: ${selector}`, LogLevel.INFO);
            return podName;
          }
        }

        // 2) If label search fails, try name-based search
        const allPods = await this.k8sApi.listNamespacedPod({ 
          namespace: this.toolboxNamespace 
        });
        for (const pod of allPods.items) {
          const name = pod.metadata!.name!;
          if (name.includes('toolbox') || name.includes('eda-toolbox')) {
            log(`Found toolbox pod by name: ${name}`, LogLevel.INFO);
            return name;
          }
        }

        throw new Error(`No toolbox pod found in namespace ${this.toolboxNamespace}`);
      },
      {
        ttl: 60000, // e.g. 1 minute
        description: 'toolbox pod',
      }
    );
  }

  /**
   * Execute a command in the toolbox pod
   */
  async executeCommandInToolbox(
    command: string,
    ignoreNoResources: boolean = false
  ): Promise<string> {
    try {
      const podName = await this.findToolboxPodCached();
      log(`Executing in toolbox pod '${podName}': ${command}`, LogLevel.DEBUG);

      // Use our new kubectl helper
      try {
        const output = executeKubectl(
          this.kubectlPath,
          ['exec', '-n', this.toolboxNamespace, podName, '--', ...command.split(' ')],
          { encoding: 'utf-8' }
        );
        return output;
      } catch (execError: any) {
        // "no resources found" special handling
        if (
          ignoreNoResources &&
          (execError.stderr?.includes('no resources found') ||
            execError.stdout?.includes('no resources found'))
        ) {
          log(`No resources found for: ${command}`, LogLevel.DEBUG);
          return '';
        }
        log(`Error executing command in toolbox: ${execError}`, LogLevel.ERROR, true);
        if (execError.stdout) {
          return execError.stdout;
        }
        throw execError;
      }
    } catch (error) {
      log(`Failed to execute command in eda-toolbox: ${error}`, LogLevel.ERROR, true);
      return '';
    }
  }

  /**
   * Reset the toolbox cache (pod-name).
   */
  resetToolboxCache() {
    cache.clear('toolbox');
  }
}

=== ./src/services/kubernetes/baseK8sService.ts ===
// src/k8s/baseK8sService.ts
import { KubeConfig, CoreV1Api, AppsV1Api, ApiextensionsV1Api, CustomObjectsApi } from '@kubernetes/client-node';
import * as vscode from 'vscode';
import { execSync } from 'child_process';
import { LogLevel, log } from '../../extension.js';
import { cache } from '../../utils/cacheUtils';

export class BaseK8sService {
  protected kc: KubeConfig;
  protected k8sApi: CoreV1Api;
  protected k8sAppsApi: AppsV1Api;
  protected k8sApiext: ApiextensionsV1Api;
  protected k8sCustomObjects: CustomObjectsApi;

  protected namespace: string;
  protected toolboxNamespace: string = 'eda-system';
  protected kubectlPath: string;

  private _onDidChangeContext = new vscode.EventEmitter<string>();
  readonly onDidChangeContext = this._onDidChangeContext.event;

  // Common cache TTL
  protected cacheTtl = 15000; // 15s

  constructor() {
    this.kc = new KubeConfig();
    try {
      this.kc.loadFromDefault();
    } catch (error) {
      vscode.window.showErrorMessage(`Failed to load Kubernetes configuration: ${error}`);
    }

    this.k8sApi = this.kc.makeApiClient(CoreV1Api);
    this.k8sAppsApi = this.kc.makeApiClient(AppsV1Api);
    this.k8sApiext = this.kc.makeApiClient(ApiextensionsV1Api);
    this.k8sCustomObjects = this.kc.makeApiClient(CustomObjectsApi);

    this.namespace = 'eda-system';

    // Cache the path to kubectl once
    this.kubectlPath = this.findKubectlPath();
  }

  // Helper to find kubectl
  private findKubectlPath(): string {
    try {
      return execSync('which kubectl', { encoding: 'utf-8' }).trim();
    } catch (error) {
      // If "which" command fails, default to 'kubectl'
      return 'kubectl';
    }
  }

  // Set namespace for resource operations
  public setNamespace(namespace: string, shouldLog: boolean = true): void {
    this.namespace = namespace;
    if (shouldLog) {
      log(`BaseK8sService: set resource namespace to '${namespace}'`, LogLevel.INFO);
    }
  }

  // Get current namespace
  public getCurrentNamespace(): string {
    return this.namespace;
  }

  // Get kubectl path for direct usage
  public getKubectlPath(): string {
    return this.kubectlPath;
  }

  /**
   * Get the current Kubernetes context name
   */
  public getCurrentContext(): string {
    try {
      return this.kc.getCurrentContext() || 'unknown-context';
    } catch (error) {
      log(`Error getting current context: ${error}`, LogLevel.ERROR);
      return 'unknown-context';
    }
  }

  /**
   * Get all available Kubernetes contexts
   */
  public getAvailableContexts(): string[] {
    try {
      return this.kc.getContexts().map(context => context.name);
    } catch (error) {
      log(`Error getting available contexts: ${error}`, LogLevel.ERROR);
      return [];
    }
  }

  /**
   * Switch to a different Kubernetes context
   */
  public async useContext(contextName: string): Promise<void> {
    try {
      log(`Switching to Kubernetes context '${contextName}'`, LogLevel.INFO, true);
  
      // Make sure the context exists
      const contexts = this.getAvailableContexts();
      if (!contexts.includes(contextName)) {
        throw new Error(`Context '${contextName}' not found in kubeconfig`);
      }
  
      // Use kubectl to change the context (this will update kubeconfig file)
      execSync(`${this.kubectlPath} config use-context ${contextName}`, { encoding: 'utf-8' });
      
      // Reload the kubeconfig from disk to sync our in-memory state
      this.kc = new KubeConfig();
      this.kc.loadFromDefault();
  
      // Recreate the API clients with the new context
      this.k8sApi = this.kc.makeApiClient(CoreV1Api);
      this.k8sAppsApi = this.kc.makeApiClient(AppsV1Api);
      this.k8sApiext = this.kc.makeApiClient(ApiextensionsV1Api);
      this.k8sCustomObjects = this.kc.makeApiClient(CustomObjectsApi);
  
      // Clear all caches
      cache.clearAll();
      log('Clearing all caches after context switch', LogLevel.INFO);
  
      // Emit an event to notify that context has changed
      this._onDidChangeContext.fire(contextName);
  
      log(`Successfully switched to context '${contextName}'`, LogLevel.INFO, true);
    } catch (error) {
      log(`Failed to switch to context '${contextName}': ${error}`, LogLevel.ERROR, true);
      throw error;
    }
  }


}
=== ./src/services/kubernetes/crdService.ts ===
import { V1CustomResourceDefinition } from '@kubernetes/client-node';
import { execSync } from 'child_process';
import { BaseK8sService } from './baseK8sService';
import { CrdInfo } from '../types';
import { LogLevel, log } from '../../extension.js';
import { fetchResources, executeKubectl } from '../../utils/resourceUtils';
import { cache } from '../../utils/cacheUtils';

export class CrdService extends BaseK8sService {
  constructor() {
    super();
    // Pre-fetch all CRDs to build cache in background
    this.prefetchAllCrds();
  }

  // Pre-fetch all CRDs in background
  private async prefetchAllCrds(): Promise<void> {
    try {
      log('Pre-fetching all cluster CRDs in background...', LogLevel.DEBUG);
      this.getAllCrds().catch(err => {
        log(`Error pre-fetching CRDs: ${err}`, LogLevel.ERROR);
      });
    } catch (error) {
      log(`Error pre-fetching CRDs: ${error}`, LogLevel.ERROR);
    }
  }

  // Retrieve all CRDs at once and cache them using the new cache helper
  async getAllCrds(): Promise<V1CustomResourceDefinition[]> {
    return cache.getOrFetch<V1CustomResourceDefinition[]>(
      'allCrds',
      'cluster-wide',
      async () => {
        log(`Fetching all CRDs cluster-wide...`, LogLevel.INFO);
        const response = await this.k8sApiext.listCustomResourceDefinition();
        const items = response.items;
        log(`Found ${items.length} CRDs in the cluster`, LogLevel.INFO);
        return items;
      },
      {
        ttl: 3600000, // one hour TTL for CRDs
        description: 'CRDs cluster-wide',
        namespace: 'cluster-wide'
      }
    );
  }

  public async getCrdYamlForKind(kind: string): Promise<string> {
    // Step 1: Find the CRD name (e.g. "interfaces.interfaces.eda.nokia.com")
    const allCrds = await this.getAllCrds();
    const crdMatch = allCrds.find(c => c.spec?.names?.kind === kind);
    if (!crdMatch || !crdMatch.metadata?.name) {
      throw new Error(`Could not find a CRD whose kind = ${kind}`);
    }
    const crdName = crdMatch.metadata.name;

    // Step 2: Use our new kubectl helper to fetch the YAML
    try {
      log(`Fetching CRD YAML for ${crdName}`, LogLevel.DEBUG);
      return executeKubectl(
        this.kubectlPath,
        ['get', 'crd', crdName, '-o', 'yaml', '--show-managed-fields=false'],
        { encoding: 'utf-8' }
      );
    } catch (err: any) {
      log(`Error executing kubectl get crd: ${err}`, LogLevel.ERROR, true);
      throw new Error(`Failed to retrieve CRD for kind ${kind}: ${err.message}`);
    }
  }

  // Return all CRD groups that match "eda.nokia.com"
  async getAvailableCrdGroups(): Promise<string[]> {
    const crds = await this.getAllCrds();
    const groups = new Set<string>();
    for (const crd of crds) {
      if (crd.spec?.group?.includes('eda.nokia.com')) {
        groups.add(crd.spec.group);
      }
    }
    log(`Found ${groups.size} EDA-related CRD groups`, LogLevel.DEBUG);
    return Array.from(groups);
  }

  /**
   * Get all Custom Resource Definitions in the cluster using API
   */
  public async getCRDs(): Promise<any[]> {
    try {
      log('Getting CRDs from cluster using API...', LogLevel.INFO);
      const response = await this.k8sApiext.listCustomResourceDefinition();
      if (!response.items || !Array.isArray(response.items)) {
        log('No CRDs found in the cluster', LogLevel.WARN);
        return [];
      }
      return response.items;
    } catch (error) {
      log(`Error getting CRDs: ${error}`, LogLevel.ERROR);
      return [];
    }
  }

  // Add this at the top of CrdService class
  private crdGroupCache = new Map<string, CrdInfo[]>();

  async getCrdsForGroup(group: string, skipLogging: boolean = false): Promise<CrdInfo[]> {
    // Check cache first
    if (this.crdGroupCache.has(group)) {
      // Only log once in a while, not every call
      if (!skipLogging) {
        log(`Using cached ${this.crdGroupCache.get(group)!.length} CRDs in group '${group}'`, LogLevel.DEBUG);
      }
      return this.crdGroupCache.get(group)!;
    }

    const crds = await this.getAllCrds();
    const result = crds
      .filter(crd => crd.spec?.group === group)
      .map(crd => {
        const version = crd.spec?.versions?.find(v => v.served)?.name || 'v1';
        return {
          name: crd.metadata?.name || '',
          apiGroup: crd.spec?.group || '',
          kind: crd.spec?.names?.kind || '',
          version: version
        };
      });
    
    // Log only on cache miss
    log(`Found ${result.length} CRDs in group '${group}'`, LogLevel.DEBUG);
    
    // Store in cache
    this.crdGroupCache.set(group, result);
    return result;
  }

  // NEW: Check multiple CRDs in parallel using Promise.all
  async batchCheckCrdInstances(namespace: string, crds: CrdInfo[]): Promise<Set<string>> {
    log(`Batch checking ${crds.length} CRDs for instances in namespace ${namespace}`, LogLevel.DEBUG);
    const result = new Set<string>();

    const promises = crds.map(async (crd) => {
      const hasInstances = await this.hasCrdInstances(namespace, crd);
      if (hasInstances) {
        result.add(crd.kind);
      }
    });

    await Promise.all(promises);
    return result;
  }

  // Check if a CRD has instances in a namespace using the new cache helper
  async hasCrdInstances(namespace: string, crd: CrdInfo): Promise<boolean> {
    const cacheKey = `${namespace}|${crd.kind}|exists`;
    return cache.getOrFetch<boolean>(
      cacheKey,
      namespace,
      async () => {
        try {
          const resource = crd.name.split('.')[0]; // e.g. "fabrics"
          const response = await this.k8sCustomObjects.listNamespacedCustomObject({
            group: crd.apiGroup,
            version: crd.version,
            namespace,
            plural: resource
          });
          const items = (response.body as any).items;
          return Array.isArray(items) && items.length > 0;
        } catch (error) {
          // If error is 404, it means the resource type doesn't exist in this namespace
          return false;
        }
      },
      {
        ttl: this.cacheTtl,
        description: `existence check for ${crd.kind} in ${namespace}`,
        namespace: namespace
      }
    );
  }

  private async fetchCrdInstances(namespace: string, crd: CrdInfo): Promise<any[]> {
    try {
      log(`Fetching instances of ${crd.kind} in ${namespace} via K8s API`, LogLevel.DEBUG);
      const resource = crd.name.split('.')[0]; // e.g. "fabrics"
      const response = await this.k8sCustomObjects.listNamespacedCustomObject({
        group: crd.apiGroup,
        version: crd.version,
        namespace,
        plural: resource
      });
      const items = (response.body as any).items || [];
      log(`Found ${items.length} instances of ${crd.kind} in ${namespace}`, LogLevel.DEBUG);
      return items;
    } catch (error) {
      if ((error as any).statusCode === 404) {
        log(`No instances of ${crd.kind} found in ${namespace}`, LogLevel.DEBUG);
        return [];
      }
      log(`Error fetching instances of ${crd.kind} in ${namespace}: ${error}`, LogLevel.ERROR);
      return [];
    }
  }

  // Get CRD instances for a specific CRD type and namespace using the new cache helper.
  async getCrdInstances(namespace: string, crd: CrdInfo): Promise<any[]> {
    // Always bypass cache for system namespace
    const isSystemNamespace = namespace === 'eda-system';
    const cacheKey = `${namespace}|${crd.kind}`;
    if (isSystemNamespace) {
      log(`Getting CRD instances for ${crd.kind} in system namespace using K8s API (uncached)`, LogLevel.DEBUG);
      return this.fetchCrdInstances(namespace, crd);
    }
    return cache.getOrFetch<any[]>(
      cacheKey,
      namespace,
      () => this.fetchCrdInstances(namespace, crd),
      {
        ttl: this.cacheTtl,
        description: `instances of ${crd.kind} in ${namespace}`,
        namespace: namespace
      }
    );
  }

  // Helper to check if a resource kind is an EDA CRD
  async isEdaCrd(kind: string): Promise<boolean> {
    try {
      const crds = await this.getAllCrds();
      return crds.some(crd =>
        crd.spec?.names?.kind === kind &&
        crd.spec?.group?.includes('eda.nokia.com')
      );
    } catch (error) {
      log(`Error checking if ${kind} is an EDA CRD: ${error}`, LogLevel.ERROR);
      return false;
    }
  }

  /**
   * Get the JSON schema for a specific CRD kind
   */
  public async getCrdSchemaForKind(kind: string): Promise<any> {
    try {
      log(`Retrieving schema for CRD kind: ${kind}`, LogLevel.INFO);
      const crd = await this.getCrdDefinitionForKind(kind);
      if (!crd) {
        log(`No CRD found for kind: ${kind}`, LogLevel.WARN);
        return null;
      }
      // Look for the schema in the CRD
      let schema = null;
      // Modern v1 CRDs store schema in versions array
      if (crd.spec?.versions && crd.spec.versions.length > 0) {
        // Find the served version (or first if none marked as served)
        const version = crd.spec.versions.find(v => v.served === true) || crd.spec.versions[0];
        log(`Using CRD version: ${version.name} for kind: ${kind}`, LogLevel.DEBUG);
        // v1 CRDs have schema in version.schema.openAPIV3Schema
        if (version.schema?.openAPIV3Schema) {
          schema = version.schema.openAPIV3Schema;
          log(`Found schema in version.schema.openAPIV3Schema for kind: ${kind}`, LogLevel.DEBUG);
        }
      }
      // If we couldn't find a schema and the CRD has the older format field directly on spec
      if (!schema && (crd.spec as any).validation?.openAPIV3Schema) {
        schema = (crd.spec as any).validation.openAPIV3Schema;
        log(`Found schema in spec.validation.openAPIV3Schema for kind: ${kind}`, LogLevel.DEBUG);
      }
      if (!schema) {
        log(`No schema found in CRD for kind: ${kind}`, LogLevel.WARN);
        return null;
      }
      log(`Successfully retrieved schema for CRD kind: ${kind}`, LogLevel.INFO);
      return schema;
    } catch (error) {
      log(`Failed to get schema for kind ${kind}: ${error}`, LogLevel.ERROR);
      return null;
    }
  }

  // Retrieve the full CRD object for a given Kind
  public async getCrdDefinitionForKind(kind: string): Promise<V1CustomResourceDefinition> {
    const allCrds = await this.getAllCrds();
    const crd = allCrds.find(crd => crd.spec?.names?.kind === kind);
    if (!crd) {
      throw new Error(`No CRD found for kind: ${kind}`);
    }
    return crd;
  }

  // Clear CRD cache
  public clearCrdCache(): void {
    cache.clear('crds');
    cache.clear('crd-instances');
    cache.clear('crd-instance-exists');
  }
}

=== ./src/services/kubernetes/edaService.ts ===
// src/k8s/edaService.ts
import { V1Pod } from '@kubernetes/client-node';
import { EdaTransaction, EdaAlarm, EdaDeviation } from '../types';
import { BaseK8sService } from './baseK8sService';
import { ToolboxService } from './toolboxService';
import { LogLevel, log } from '../../extension.js';
import { cache } from '../../utils/cacheUtils';

export class EdaService extends BaseK8sService {
  // We no longer store local "edaNamespacesCache" or "edaTransactionsCache".
  // All caching is handled by `cache.getOrFetch(...)`.

  private toolboxService: ToolboxService;

  constructor(toolboxService: ToolboxService) {
    super();
    this.toolboxService = toolboxService;
  }

  /**
   * Get EDA namespaces - prefer edactl, fallback to label-based search. Cached.
   */
  async getEdaNamespaces(): Promise<string[]> {
    return cache.getOrFetch<string[]>(
      'eda-service',
      'namespaces',
      async () => {
        try {
          // 1) Attempt: edactl namespace
          const output = await this.toolboxService.executeCommandInToolbox('edactl namespace', true);
          if (output && output.trim().length > 0) {
            const namespaces = output
              .split('\n')
              .map(line => line.trim())
              .filter(line => line.length > 0);
            log(`Found ${namespaces.length} EDA namespaces via edactl`, LogLevel.DEBUG);
            return namespaces;
          }

          // 2) Fallback: label-based search
          log('No output from edactl, using label-based search...', LogLevel.INFO);
          const allNamespaces = await this.k8sApi.listNamespace();
          const edaNamespaces = allNamespaces.items
            .filter(ns => {
              const name = ns.metadata?.name || '';
              const labels = ns.metadata?.labels || {};
              return (
                labels['eda.nokia.com/managed'] === 'true' ||
                labels['eda-managed'] === 'true' ||
                labels['app.kubernetes.io/part-of'] === 'eda' ||
                name.startsWith('eda-') ||
                name === 'eda'
              );
            })
            .map(ns => ns.metadata!.name!);

          // Add known EDA namespaces
          ['eda', 'eda-system'].forEach(known => {
            if (!edaNamespaces.includes(known)) {
              edaNamespaces.push(known);
            }
          });
          log(`Found ${edaNamespaces.length} EDA namespaces via label search`, LogLevel.INFO);
          return edaNamespaces;
        } catch (error) {
          log(`Failed to get EDA namespaces: ${error}`, LogLevel.ERROR, true);
          return [];
        }
      },
      {
        ttl: this.cacheTtl,
        description: 'EDA namespaces',
      }
    );
  }

  /**
  * Get current alarms from "edactl query .namespace.alarms.current-alarm -f json"
  */
  async getEdaAlarms(): Promise<EdaAlarm[]> {
    return cache.getOrFetch<EdaAlarm[]>(
      'eda-service',
      'alarms',
      async () => {
        log(`Fetching EDA alarms via "edactl query .namespace.alarms.current-alarm -f json"...`, LogLevel.DEBUG);
        try {
          // 1) Run the command in the toolbox:
          const output = await this.toolboxService.executeCommandInToolbox(
            'edactl query .namespace.alarms.current-alarm -f json'
          );
          if (!output || !output.trim().length) {
            return [];
          }

          // 2) Parse JSON array
          //    If the output is JSON lines, or a single JSON array, adapt accordingly.
          const alarms = JSON.parse(output) as EdaAlarm[];
          log(`Found ${alarms.length} alarms from edactl output`, LogLevel.DEBUG);

          return alarms;
        } catch (err) {
          log(`Failed to get EDA alarms: ${err}`, LogLevel.ERROR, true);
          return [];
        }
      },
      {
        ttl: this.cacheTtl,
        description: 'EDA alarms',
      }
    );
  }

  async getEdaDeviations(): Promise<EdaDeviation[]> {
    return cache.getOrFetch<EdaDeviation[]>(
      'eda-service',
      'deviations',
      async () => {
        log(`Fetching EDA deviations via 'edactl query .namespace.resources.cr.core_eda_nokia_com.v1.deviation -f json'...`, LogLevel.DEBUG);
        try {
          const output = await this.toolboxService.executeCommandInToolbox(
            'edactl query .namespace.resources.cr.core_eda_nokia_com.v1.deviation -f json'
          );
          if (!output || !output.trim().length) {
            return [];
          }
          const deviations = JSON.parse(output) as EdaDeviation[];
          log(`Found ${deviations.length} deviations from edactl output`, LogLevel.DEBUG);
          return deviations;
        } catch (err) {
          log(`Failed to get EDA deviations: ${err}`, LogLevel.ERROR, true);
          return [];
        }
      },
      {
        ttl: this.cacheTtl,
        description: 'EDA deviations',
      }
    );
  }
  

  /**
   * Get EDA transactions via edactl transaction. Cached.
   */
  async getEdaTransactions(): Promise<EdaTransaction[]> {
    return cache.getOrFetch<EdaTransaction[]>(
      'eda-service',
      'transactions',
      async () => {
        log(`Fetching EDA transactions via 'edactl transaction'...`, LogLevel.DEBUG);
        try {
          const output = await this.toolboxService.executeCommandInToolbox('edactl transaction');
          if (!output || output.trim().length === 0) {
            return [];
          }

          const lines = output.split('\n').filter(line => line.trim().length > 0);
          if (lines.length <= 1) {
            return [];
          }

          const headerRow = lines[0];
          const idPos = headerRow.indexOf('ID');
          const resultPos = headerRow.indexOf('Result');
          const agePos = headerRow.indexOf('Age');
          const detailPos = headerRow.indexOf('Detail');
          const dryRunPos = headerRow.indexOf('DryRun');
          const usernamePos = headerRow.indexOf('Username');
          const descriptionPos = headerRow.indexOf('Description');

          const transactions: EdaTransaction[] = [];
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i];
            if (line.length < usernamePos) {
              continue;
            }
            const id = line.substring(idPos, resultPos).trim();
            const result = line.substring(resultPos, agePos).trim();
            const age = line.substring(agePos, detailPos).trim();
            const detail = line.substring(detailPos, dryRunPos).trim();
            const dryRun = line.substring(dryRunPos, usernamePos).trim();
            const username = line.substring(
              usernamePos,
              descriptionPos > 0 ? descriptionPos : line.length
            ).trim();
            const description = descriptionPos > 0 ? line.substring(descriptionPos).trim() : '';
            transactions.push({ id, result, age, detail, dryRun, username, description });
          }
          log(`Found ${transactions.length} transactions from edactl output`, LogLevel.DEBUG);
          return transactions;
        } catch (error) {
          log(`Failed to get EDA transactions: ${error}`, LogLevel.ERROR, true);
          return [];
        }
      },
      {
        ttl: this.cacheTtl,
        description: 'EDA transactions',
      }
    );
  }

  /**
   * Get EDA transaction details for a given ID
   */
  async getEdaTransactionDetails(id: string): Promise<string> {
    log(`Fetching EDA transaction details for '${id}'...`, LogLevel.INFO);
    try {
      const output = await this.toolboxService.executeCommandInToolbox(`edactl transaction ${id}`);
      return output || `No details available for this transaction`;
    } catch (error) {
      log(`Failed to get transaction details for ID ${id}: ${error}`, LogLevel.ERROR, true);
      return `Error retrieving transaction details for ID ${id}: ${error}`;
    }
  }

  /**
   * Specifically clear the transaction cache
   */
  public clearTransactionCache(): void {
    // Clear only the transactions key from the eda-service cache group
    cache.remove('eda-service', 'transactions');
    log('Transaction cache cleared', LogLevel.DEBUG);
  }

  /**
   * Revert a transaction using its commit hash
   */
  async revertTransaction(commitHash: string): Promise<string> {
    log(`Reverting transaction with commit hash ${commitHash}...`, LogLevel.INFO);
    try {
      const output = await this.toolboxService.executeCommandInToolbox(`edactl git revert ${commitHash}`);
      return output;
    } catch (error) {
      log(`Failed to revert transaction with commit hash ${commitHash}: ${error}`, LogLevel.ERROR, true);
      throw error;
    }
  }

  /**
   * Restore a transaction using its commit hash
   */
  async restoreTransaction(commitHash: string): Promise<string> {
    log(`Restoring transaction with commit hash ${commitHash}...`, LogLevel.INFO);
    try {
      const output = await this.toolboxService.executeCommandInToolbox(`edactl git restore ${commitHash}`);
      return output;
    } catch (error) {
      log(`Failed to restore transaction with commit hash ${commitHash}: ${error}`, LogLevel.ERROR, true);
      throw error;
    }
  }

  /**
   * Get NPP pods for a given EDA namespace
   */

  async getNppPodsForNamespace(edaNamespace: string): Promise<V1Pod[]> {
    try {
      const prefix = `eda-npp-${edaNamespace}`;
      const response = await this.k8sApi.listNamespacedPod({ namespace: this.toolboxNamespace });
      const filteredPods = response.items.filter(pod => {
        const podName = pod.metadata?.name || '';
        return podName.startsWith(prefix);
      });
      return filteredPods;
    } catch (error) {
      log(`Failed to get NPP pods for namespace '${edaNamespace}': ${error}`, LogLevel.ERROR, true);
      return [];
    }
  }

  /**
   * Try to get the resource via edactl for known EDA CRDs
   */
  async getEdaResourceYaml(
    kind: string,
    name: string,
    namespace?: string,
    isEdaCrd: boolean = true
  ): Promise<string> {
    const ns = namespace || this.namespace;
    try {
      if (isEdaCrd) {
        log(`Using edactl for EDA CRD ${kind}/${name} in namespace ${ns}`, LogLevel.INFO);
        const edaResource = kind.charAt(0).toLowerCase() + kind.slice(1);
        const edaOutput = await this.toolboxService.executeCommandInToolbox(
          `edactl get ${edaResource} ${name} -n ${ns} -o yaml`,
          true
        );
        if (edaOutput && edaOutput.trim().length > 0) {
          return edaOutput;
        }
      }
      // fallback
      log(`EDA resource not found with edactl, falling back to kubectl`, LogLevel.DEBUG);
      return '';
    } catch (error: any) {
      log(`Error getting EDA resource YAML: ${error}`, LogLevel.ERROR);
      return '';
    }
  }

  /**
   * Reset local caches (now just clearing the group in our global cache)
   */
  resetNamespaceCache() {
    // If you want to nuke the 'eda-service' group from the cache:
    cache.clear('eda-service');
  }
}

=== ./src/services/kubernetes/k8sResourcesService.ts ===
import { V1Pod, V1Service, V1Deployment, V1ConfigMap, V1Secret, V1Node } from '@kubernetes/client-node';
import * as yaml from 'js-yaml';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
import { execSync } from 'child_process';
import { BaseK8sService } from './baseK8sService';
import { LogLevel, log } from '../../extension.js';
import { fetchResources, executeKubectl } from '../../utils/resourceUtils';
import { cache } from '../../utils/cacheUtils';

export class K8sResourcesService extends BaseK8sService {
  constructor() {
    super();
  }

  // Standard Kubernetes resource retrieval using the k8s client library
  async getPods(namespace?: string): Promise<V1Pod[]> {
    const ns = namespace || this.namespace;
    return cache.getOrFetch<V1Pod[]>(
      'pods',
      ns,
      () => fetchResources<V1Pod>(
        () => this.k8sApi.listNamespacedPod({ namespace: ns }),
        'Pods',
        { namespace: ns }
      ),
      {
        ttl: this.cacheTtl,
        description: `pods in namespace '${ns}'`,
        namespace: ns,
      }
    );
  }

  // Using the new caching pattern for services as well
  async getServices(namespace?: string): Promise<V1Service[]> {
    const ns = namespace || this.namespace;
    return cache.getOrFetch<V1Service[]>(
      'services',
      ns,
      () =>
        fetchResources<V1Service>(
          () => this.k8sApi.listNamespacedService({ namespace: ns }),
          'Services',
          { namespace: ns }
        ),
      {
        ttl: this.cacheTtl,
        description: `services in namespace '${ns}'`,
        namespace: ns,
      }
    );
  }

  // Updated getDeployments using cache.getOrFetch
  async getDeployments(namespace?: string): Promise<V1Deployment[]> {
    const ns = namespace || this.namespace;
    return cache.getOrFetch<V1Deployment[]>(
      'deployments',
      ns,
      () =>
        fetchResources<V1Deployment>(
          () => this.k8sAppsApi.listNamespacedDeployment({ namespace: ns }),
          'Deployments',
          { namespace: ns }
        ),
      {
        ttl: this.cacheTtl,
        description: `deployments in namespace '${ns}'`,
        namespace: ns,
      }
    );
  }

  // Updated getConfigMaps using cache.getOrFetch
  async getConfigMaps(namespace?: string): Promise<V1ConfigMap[]> {
    const ns = namespace || this.namespace;
    return cache.getOrFetch<V1ConfigMap[]>(
      'configmaps',
      ns,
      () =>
        fetchResources<V1ConfigMap>(
          () => this.k8sApi.listNamespacedConfigMap({ namespace: ns }),
          'ConfigMaps',
          { namespace: ns }
        ),
      {
        ttl: this.cacheTtl,
        description: `configmaps in namespace '${ns}'`,
        namespace: ns,
      }
    );
  }

  // Updated getSecrets using cache.getOrFetch
  async getSecrets(namespace?: string): Promise<V1Secret[]> {
    const ns = namespace || this.namespace;
    return cache.getOrFetch<V1Secret[]>(
      'secrets',
      ns,
      () =>
        fetchResources<V1Secret>(
          () => this.k8sApi.listNamespacedSecret({ namespace: ns }),
          'Secrets',
          { namespace: ns }
        ),
      {
        ttl: this.cacheTtl,
        description: `secrets in namespace '${ns}'`,
        namespace: ns,
      }
    );
  }

  // Updated getNodes using cache.getOrFetch with 'cluster-wide' namespace
  async getNodes(): Promise<V1Node[]> {
    return cache.getOrFetch<V1Node[]>(
      'nodes',
      'cluster-wide',
      () =>
        fetchResources<V1Node>(
          () => this.k8sApi.listNode(),
          'Nodes',
          { namespace: 'cluster-wide' }
        ),
      {
        ttl: this.cacheTtl,
        description: 'cluster nodes',
        namespace: 'cluster-wide',
      }
    );
  }

  // Special method for getting system resources using kubectl directly
  async getSystemResources(resourceType: string): Promise<any[]> {
    log(
      `Explicitly fetching ${resourceType} from system namespace via kubectl/K8s API`,
      LogLevel.INFO
    );

    // Save current namespace
    const prevNamespace = this.namespace;

    try {
      // Set namespace to eda-system for this operation
      this.setNamespace('eda-system');

      // Use kubectl directly for eda-system resources to avoid edactl
      switch (resourceType.toLowerCase()) {
        case 'pods':
          return await this.getPods('eda-system');
        case 'deployments':
          return await this.getDeployments('eda-system');
        case 'services':
          return await this.getServices('eda-system');
        case 'configmaps':
          return await this.getConfigMaps('eda-system');
        case 'secrets':
          return await this.getSecrets('eda-system');
        default:
          log(`Unknown system resource type: ${resourceType}`, LogLevel.WARN);
          return [];
      }
    } catch (error) {
      log(
        `Error fetching system resources (${resourceType}): ${error}`,
        LogLevel.ERROR
      );
      return [];
    } finally {
      // Restore previous namespace
      this.setNamespace(prevNamespace);
    }
  }

  // Get a resource in YAML format - optimized to use kubectl directly
  async getResourceYaml(
    kind: string,
    name: string,
    namespace?: string
  ): Promise<string> {
    const ns = namespace || this.namespace;

    try {
      log(
        `Getting ${kind}/${name} in namespace ${ns} using kubectl...`,
        LogLevel.DEBUG
      );

      // Use our new helper function
      return executeKubectl(
        this.kubectlPath,
        ['get', kind.toLowerCase(), name, '-n', ns, '-o', 'yaml'],
        { encoding: 'utf-8' }
      );
    } catch (error: any) {
      log(`Error getting resource YAML: ${error}`, LogLevel.ERROR);
      return `# Error loading resource: ${error.message || error}`;
    }
  }

  // Apply a Kubernetes resource using kubectl
  async applyResource(resource: any, dryRun: boolean = false): Promise<string> {
    // Validate that the resource has the required fields
    if (
      !resource.kind ||
      !resource.apiVersion ||
      !resource.metadata ||
      !resource.metadata.name
    ) {
      throw new Error(
        'Invalid resource: missing required fields (kind, apiVersion, metadata.name)'
      );
    }

    // Determine the namespace
    const namespace = resource.metadata.namespace || this.namespace;
    const isSystemNamespace = namespace === 'eda-system';

    // For system namespace, always explicitly use kubectl
    if (isSystemNamespace) {
      log(
        `Applying system resource ${resource.kind}/${resource.metadata.name} using kubectl only`,
        LogLevel.INFO
      );
    }

    // Convert resource to YAML
    const resourceYaml = yaml.dump(resource);

    // Create a temporary file with the YAML content
    const tmpDir = os.tmpdir();
    const tmpFile = path.join(tmpDir, `resource-${Date.now()}.yaml`);

    try {
      // Write the resource to a temporary file
      fs.writeFileSync(tmpFile, resourceYaml);

      // Use kubectl directly for applying
      let command = `${this.kubectlPath} apply -f ${tmpFile} --namespace ${namespace}`;
      if (dryRun) {
        command += ' --dry-run=server';
      }
      command += ' -o yaml';

      log(
        `Applying ${resource.kind}/${resource.metadata.name} with kubectl...`,
        LogLevel.INFO
      );
      const output = execSync(command, { encoding: 'utf-8' });

      log(
        `Successfully ${dryRun ? 'validated' : 'applied'} ${
          resource.kind
        }/${resource.metadata.name}`,
        LogLevel.INFO
      );
      return output;
    } catch (error: any) {
      log(`Error applying resource: ${error.message}`, LogLevel.ERROR, true);
      throw error;
    } finally {
      // Clean up the temporary file
      try {
        if (fs.existsSync(tmpFile)) {
          fs.unlinkSync(tmpFile);
        }
      } catch (cleanupError) {
        log(
          `Warning: Could not delete temporary file ${tmpFile}: ${cleanupError}`,
          LogLevel.WARN
        );
      }
    }
  }

  // Delete a pod
  public async deletePod(namespace: string, podName: string): Promise<void> {
    try {
      log(`Deleting pod '${podName}' in namespace '${namespace}'`, LogLevel.INFO);
      // Use K8s API directly for better performance
      await this.k8sApi.deleteNamespacedPod({ name: podName, namespace });
      log(`Successfully deleted pod '${podName}'`, LogLevel.INFO);
      this.resetPodCache();
    } catch (error: any) {
      const errorMsg = `Failed to delete Pod ${podName} in namespace ${namespace}: ${
        error.body?.message || error.message || error
      }`;
      log(errorMsg, LogLevel.ERROR, true);
      throw new Error(errorMsg);
    }
  }

  /**
   * Return the textual output of "kubectl describe pod -n {ns} {podName}"
   * as a string. We do not store it in a terminal; we just return it here.
   */
  public getPodDescribeOutput(namespace: string, podName: string): string {
    try {
      const cmd = `${this.kubectlPath} describe pod -n ${namespace} ${podName}`;
      const output = execSync(cmd, { encoding: 'utf-8' });
      return output;
    } catch (err: any) {
      const msg = `Failed to describe pod ${podName} in namespace ${namespace}: ${err.message}`;
      throw new Error(msg);
    }
  }

  public async getAvailableResourceTypes(namespace: string): Promise<string[]> {
    try {
      log(`Getting available resource types in namespace ${namespace}...`, LogLevel.INFO);

      // Return a static list of common resource types instead of an expensive kubectl call
      const resourceTypes = [
        'Pods',
        'Services',
        'Deployments',
        'ConfigMaps',
        'Secrets',
      ];

      log(`Using ${resourceTypes.length} common resource types`, LogLevel.DEBUG);
      return resourceTypes;
    } catch (error) {
      log(`Error getting resource types: ${error}`, LogLevel.ERROR);
      return ['Pods', 'Services', 'Deployments', 'ConfigMaps', 'Secrets']; // Fallback
    }
  }

  // Reset pod cache using the new cache system
  resetPodCache() {
    cache.clear('pods');
  }

  // Clear all caches
  clearAllCaches() {
    cache.clear('pods');
    cache.clear('services');
    cache.clear('deployments');
    cache.clear('configMaps');
    cache.clear('secrets');
    cache.clear('nodes');
  }
}

=== ./src/services/kubernetes/kubernetes.ts ===
// src/k8s/kubernetesService.ts - Facade implementing the original interface
//import * as k8s from '@kubernetes/client-node';
import { V1Pod, V1Service, V1Deployment, V1ConfigMap, V1Secret, V1Node, V1CustomResourceDefinition } from '@kubernetes/client-node';
import { BaseK8sService } from './baseK8sService';
import { K8sResourcesService } from './k8sResourcesService';
import { CrdService } from './crdService';
import { ToolboxService } from './toolboxService';
import { EdaService } from './edaService';
import { EdaTransaction, EdaAlarm, EdaDeviation, CrdInfo } from '../types';
import { LogLevel, log } from '../../extension.js';

export class KubernetesService extends BaseK8sService {
  private resourcesService: K8sResourcesService;
  private crdService: CrdService;
  private toolboxService: ToolboxService;
  private edaService: EdaService;

  constructor() {
    super();
    // Initialize component services
    this.resourcesService = new K8sResourcesService();
    this.crdService = new CrdService();
    this.toolboxService = new ToolboxService();
    this.edaService = new EdaService(this.toolboxService);

    log('KubernetesService initialized with all component services', LogLevel.INFO);
  }

  // Override setNamespace to propagate to all services
  public setNamespace(namespace: string): void {
    // Only log once at the main service level
    super.setNamespace(namespace, true);

    // Propagate to child services without additional logging
    this.resourcesService.setNamespace(namespace, false);
    this.crdService.setNamespace(namespace, false);
    this.toolboxService.setNamespace(namespace, false);
    this.edaService.setNamespace(namespace, false);
  }

  // ----- Delegating methods to appropriate services -----

  // Standard K8s resources - delegated to resourcesService
  async getPods(namespace?: string): Promise<V1Pod[]> {
    return this.resourcesService.getPods(namespace);
  }

  async getServices(namespace?: string): Promise<V1Service[]> {
    return this.resourcesService.getServices(namespace);
  }

  async getDeployments(namespace?: string): Promise<V1Deployment[]> {
    return this.resourcesService.getDeployments(namespace);
  }

  async getConfigMaps(namespace?: string): Promise<V1ConfigMap[]> {
    return this.resourcesService.getConfigMaps(namespace);
  }

  async getSecrets(namespace?: string): Promise<V1Secret[]> {
    return this.resourcesService.getSecrets(namespace);
  }

  async getNodes(): Promise<V1Node[]> {
    return this.resourcesService.getNodes();
  }

  async getSystemResources(resourceType: string): Promise<any[]> {
    return this.resourcesService.getSystemResources(resourceType);
  }

  public async deletePod(namespace: string, podName: string): Promise<void> {
    return this.resourcesService.deletePod(namespace, podName);
  }

  public getPodDescribeOutput(namespace: string, podName: string): string {
    return this.resourcesService.getPodDescribeOutput(namespace, podName);
  }

  // CRD-related methods - delegated to crdService
  async getAllCrds(): Promise<V1CustomResourceDefinition[]> {
    return this.crdService.getAllCrds();
  }

  public async getCrdYamlForKind(kind: string): Promise<string> {
    return this.crdService.getCrdYamlForKind(kind);
  }

  async getAvailableCrdGroups(): Promise<string[]> {
    return this.crdService.getAvailableCrdGroups();
  }

  public async getCRDs(): Promise<any[]> {
    return this.crdService.getCRDs();
  }

  async getCrdsForGroup(group: string): Promise<CrdInfo[]> {
    return this.crdService.getCrdsForGroup(group);
  }

  async batchCheckCrdInstances(namespace: string, crds: CrdInfo[]): Promise<Set<string>> {
    return this.crdService.batchCheckCrdInstances(namespace, crds);
  }

  async hasCrdInstances(namespace: string, crd: CrdInfo): Promise<boolean> {
    return this.crdService.hasCrdInstances(namespace, crd);
  }

  async getCrdInstances(namespace: string, crd: CrdInfo): Promise<any[]> {
    return this.crdService.getCrdInstances(namespace, crd);
  }

  async isEdaCrd(kind: string): Promise<boolean> {
    return this.crdService.isEdaCrd(kind);
  }

  public async getCrdSchemaForKind(kind: string): Promise<any> {
    return this.crdService.getCrdSchemaForKind(kind);
  }

  public async getCrdDefinitionForKind(kind: string): Promise<V1CustomResourceDefinition> {
    return this.crdService.getCrdDefinitionForKind(kind);
  }

  // Toolbox methods - delegated to toolboxService
  async executeCommandInToolbox(command: string, ignoreNoResources: boolean = false): Promise<string> {
    return this.toolboxService.executeCommandInToolbox(command, ignoreNoResources);
  }

  // EDA methods - delegated to edaService
  async getEdaNamespaces(): Promise<string[]> {
    return this.edaService.getEdaNamespaces();
  }

  async getEdaAlarms(): Promise<EdaAlarm[]> {
    return this.edaService.getEdaAlarms();
  }

  async getEdaDeviations(): Promise<EdaDeviation[]> {
    return this.edaService.getEdaDeviations();
  }

  async getEdaTransactions(): Promise<EdaTransaction[]> {
    return this.edaService.getEdaTransactions();
  }

  async getEdaTransactionDetails(id: string): Promise<string> {
    return this.edaService.getEdaTransactionDetails(id);
  }

  /**
   * Clears the transaction cache to force fresh data on next request
   */
  public clearTransactionCache(): void {
    // Clear the transaction cache in EdaService
    this.edaService.clearTransactionCache();
  }

  /**
   * Revert a transaction using edactl git revert with the given commit hash
   */
  async revertTransaction(commitHash: string): Promise<string> {
    return this.edaService.revertTransaction(commitHash);
  }

  /**
   * Restore a transaction using edactl git with the given commit hash
   */
  async restoreTransaction(commitHash: string): Promise<string> {
    return this.edaService.restoreTransaction(commitHash);
  }

  async getNppPodsForNamespace(edaNamespace: string): Promise<V1Pod[]> {
    return this.edaService.getNppPodsForNamespace(edaNamespace);
  }

  public async getAvailableResourceTypes(namespace: string): Promise<string[]> {
    return this.resourcesService.getAvailableResourceTypes(namespace);
  }

  // Methods that combine services
  async getResourceYaml(kind: string, name: string, namespace?: string): Promise<string> {
    const ns = namespace || this.namespace;

    try {
      // For transaction-focused operations, use edactl (special case)
      if (kind.toLowerCase() === 'transaction') {
        return this.edaService.getEdaTransactionDetails(name);
      }

      // First, try to determine if this is an EDA CRD - if so, use edactl for it
      const isEdaCrd = await this.crdService.isEdaCrd(kind);

      if (isEdaCrd) {
        const edaYaml = await this.edaService.getEdaResourceYaml(kind, name, ns, isEdaCrd);
        if (edaYaml && edaYaml.trim().length > 0) {
          return edaYaml;
        }
      }

      // For non-EDA resources or if edactl fails, use kubectl via resourcesService
      return this.resourcesService.getResourceYaml(kind, name, ns);
    } catch (error: any) {
      log(`Error getting resource YAML: ${error}`, LogLevel.ERROR);
      return `# Error loading resource: ${error.message || error}`;
    }
  }

  async applyResource(resource: any, dryRun: boolean = false): Promise<string> {
    return this.resourcesService.applyResource(resource, dryRun);
  }

  // Cache management methods
  resetPodCache() {
    this.resourcesService.resetPodCache();
  }

  clearAllCaches() {
    this.resourcesService.clearAllCaches();
    this.crdService.clearCrdCache();
    this.toolboxService.resetToolboxCache();
    this.edaService.resetNamespaceCache();
  }
}
=== ./src/services/store/resourceStore.ts ===
// src/services/resourceStore.ts
import * as vscode from 'vscode';
import { KubernetesService } from '../kubernetes/kubernetes';
import { log, LogLevel, measurePerformance } from '../../extension.js';

export interface ResourceStoreItem {
  kind: string;
  name: string;
  namespace: string;
  apiGroup?: string;
  resource: any; // The actual K8s resource object
  resourceVersion?: string;
  lastUpdated: number; // Timestamp
}

export interface ResourceChange {
  type: 'added' | 'modified' | 'deleted';
  item: ResourceStoreItem;
}

/**
 * Central store for all Kubernetes resources across namespaces
 */
export class ResourceStore {
  private _onDidChangeResources = new vscode.EventEmitter<ResourceChange[]>();
  readonly onDidChangeResources = this._onDidChangeResources.event;

  private _onDidReloadNamespace = new vscode.EventEmitter<string>();
  readonly onDidReloadNamespace = this._onDidReloadNamespace.event;

  // Main store of all resources
  // Structure: namespace -> kind -> name -> resource
  private store: Map<string, Map<string, Map<string, ResourceStoreItem>>> = new Map();

  // Tracks which namespaces have been loaded
  private loadedNamespaces: Set<string> = new Set();

  // Cached CRD group information
  private crdGroups: Map<string, string[]> = new Map(); // group -> kinds[]

  // Last refresh time per namespace
  private lastRefreshTime: Map<string, number> = new Map();

  constructor(private k8sService: KubernetesService) {}

  /**
   * Gets all resources for a namespace
   */
  public getResourcesForNamespace(namespace: string): ResourceStoreItem[] {
    const result: ResourceStoreItem[] = [];
    const nsStore = this.store.get(namespace);
    if (!nsStore) return result;

    for (const kindMap of nsStore.values()) {
      for (const resource of kindMap.values()) {
        result.push(resource);
      }
    }

    return result;
  }

  /**
   * Gets resources by kind for a namespace
   */
  public getResourcesByKind(namespace: string, kind: string): ResourceStoreItem[] {
    const result: ResourceStoreItem[] = [];
    const nsStore = this.store.get(namespace);
    if (!nsStore) return result;

    const kindMap = nsStore.get(kind);
    if (!kindMap) return result;

    return Array.from(kindMap.values());
  }

  /**
   * Gets all resources for a specific CRD group in a namespace
   */
  public getResourcesForGroup(namespace: string, group: string): ResourceStoreItem[] {
    const result: ResourceStoreItem[] = [];
    const kinds = this.crdGroups.get(group) || [];

    for (const kind of kinds) {
      result.push(...this.getResourcesByKind(namespace, kind));
    }

    return result;
  }

  /**
   * Gets a specific resource by namespace, kind, and name
   */
  public getResource(namespace: string, kind: string, name: string): ResourceStoreItem | undefined {
    return this.store.get(namespace)?.get(kind)?.get(name);
  }

  /**
   * Returns if a specific kind is available in a namespace
   */
  public hasResourceKind(namespace: string, kind: string): boolean {
    const kindMap = this.store.get(namespace)?.get(kind);
    return !!kindMap && kindMap.size > 0;
  }

  /**
   * Returns all resource kinds available in a namespace
   */
  public getAvailableKinds(namespace: string): string[] {
    const nsStore = this.store.get(namespace);
    if (!nsStore) return [];

    return Array.from(nsStore.keys());
  }

  /**
   * Returns all CRD groups that have instances in a namespace
   */
  public getAvailableGroupsInNamespace(namespace: string): string[] {
    const result = new Set<string>();
    const nsStore = this.store.get(namespace);
    if (!nsStore) return [];

    // For each group, check if any of its kinds exist in the namespace
    for (const [group, kinds] of this.crdGroups.entries()) {
      for (const kind of kinds) {
        if (this.hasResourceKind(namespace, kind)) {
          result.add(group);
          break;
        }
      }
    }

    return Array.from(result);
  }

  /**
   * Returns all NPP pods for a namespace
   */
  public getNppPodsForNamespace(namespace: string): ResourceStoreItem[] {
    // NPP pods follow a naming pattern: eda-npp-<namespace>-<node>
    const prefix = `eda-npp-${namespace}`;
    const result: ResourceStoreItem[] = [];

    const systemPods = this.getResourcesByKind('eda-system', 'Pod');
    for (const pod of systemPods) {
      if (pod.name.startsWith(prefix)) {
        result.push(pod);
      }
    }

    return result;
  }

  /**
   * Filter resources in a namespace by search text
   */
  public filterResourcesInNamespace(namespace: string, searchText: string): ResourceStoreItem[] {
    if (!searchText) return this.getResourcesForNamespace(namespace);

    const lowerSearch = searchText.toLowerCase();
    return this.getResourcesForNamespace(namespace).filter(item =>
      item.name.toLowerCase().includes(lowerSearch) ||
      item.kind.toLowerCase().includes(lowerSearch)
    );
  }

  /**
   * Check if a namespace has been loaded
   */
  public isNamespaceLoaded(namespace: string): boolean {
    return this.loadedNamespaces.has(namespace);
  }

  /**
   * Get all loaded namespaces
   */
  public getLoadedNamespaces(): Set<string> {
    return this.loadedNamespaces;
  }

  /**
   * Initialize the CRD group information
   */
  public async initCrdGroups(): Promise<void> {
    try {
      log('Initializing CRD group information...', LogLevel.INFO);
      const groups = await this.k8sService.getAvailableCrdGroups();

      // Clear existing data
      this.crdGroups.clear();

      // Fetch each group and its kinds
      for (const group of groups) {
        const crds = await this.k8sService.getCrdsForGroup(group);
        const kinds = crds.map(crd => crd.kind);
        this.crdGroups.set(group, kinds);
      }

      log(`Initialized ${this.crdGroups.size} CRD groups with associated kinds`, LogLevel.INFO);
    } catch (error) {
      log(`Error initializing CRD groups: ${error}`, LogLevel.ERROR);
    }
  }

  /**
   * Load or refresh all resources for a namespace (bulk fetch)
   */
  public async loadNamespaceResources(namespace: string): Promise<string> {
    return measurePerformance(async () => {
      try {
        // Create namespace store if needed
        if (!this.store.has(namespace)) {
          this.store.set(namespace, new Map());
        }

        // Track existing resources to detect deletions
        const existingResources = new Map<string, ResourceStoreItem>();
        const nsStore = this.store.get(namespace)!;
        for (const kindMap of nsStore.values()) {
          for (const [name, resource] of kindMap.entries()) {
            existingResources.set(`${resource.kind}/${name}`, resource);
          }
        }

        // Create empty resources lists
        const changes: ResourceChange[] = [];

        // Load standard Kubernetes resources
        await Promise.all([
          this.loadK8sResourceType(namespace, 'Pod', changes, existingResources),
          this.loadK8sResourceType(namespace, 'Service', changes, existingResources),
          this.loadK8sResourceType(namespace, 'Deployment', changes, existingResources),
          this.loadK8sResourceType(namespace, 'ConfigMap', changes, existingResources),
          this.loadK8sResourceType(namespace, 'Secret', changes, existingResources)
        ]);


        // Add NPP pods if this is not the system namespace
        await Promise.all([
          Promise.all(
            Array.from(this.crdGroups.entries()).map(([group, kinds]) =>
              this.loadCrdGroup(namespace, group, kinds, changes, existingResources)
            )
          ),
          namespace !== 'eda-system' ? this.loadNppPods(namespace, changes, existingResources) : Promise.resolve()
        ]);

        // Handle deletions
        for (const resource of existingResources.values()) {
          // Remove from store
          const kindMap = nsStore.get(resource.kind);
          if (kindMap) {
            kindMap.delete(resource.name);
            if (kindMap.size === 0) {
              nsStore.delete(resource.kind);
            }
          }

          // Add to changes
          changes.push({
            type: 'deleted',
            item: resource
          });
        }

        // Mark namespace as loaded
        this.loadedNamespaces.add(namespace);
        this.lastRefreshTime.set(namespace, Date.now());

        // Notify listeners
        if (changes.length > 0) {
          this._onDidChangeResources.fire(changes);
        }

        // Always fire the reload event for the namespace
        this._onDidReloadNamespace.fire(namespace);

      // Return a meaningful result for the log message
      return `Loaded ${changes.length} resources for namespace '${namespace}'`;
    } catch (error) {
      log(`Error loading namespace resources: ${error}`, LogLevel.ERROR);
      throw error;
    }
  }, `Loading all resources for namespace '${namespace}'`, LogLevel.INFO, true);
}


  /**
   * Load standard Kubernetes resources of a specific type
   */
  private async loadK8sResourceType(
    namespace: string,
    kind: string,
    changes: ResourceChange[],
    existingResources: Map<string, ResourceStoreItem>
  ): Promise<void> {
    try {
      let resources: any[] = [];

      // Get resources based on type
      switch (kind) {
        case 'Pod':
          resources = await this.k8sService.getPods(namespace);
          break;
        case 'Service':
            resources = await this.k8sService.getServices(namespace);
            break;
        case 'Deployment':
          resources = await this.k8sService.getDeployments(namespace);
          break
        case 'ConfigMap':
          resources = await this.k8sService.getConfigMaps(namespace);
          break
        case 'Secret':
          resources = await this.k8sService.getSecrets(namespace);
      }

      // Process resources
      await this.processResources(namespace, kind, resources, changes, existingResources);
    } catch (error) {
      log(`Error loading ${kind} resources in ${namespace}: ${error}`, LogLevel.ERROR);
    }
  }

  /**
   * Load CRD resources for a specific group
   */
  private async loadCrdGroup(
    namespace: string,
    group: string,
    kinds: string[],
    changes: ResourceChange[],
    existingResources: Map<string, ResourceStoreItem>
  ): Promise<void> {
    try {
      // Get CRD info for ALL kinds in the group at once
      const allCrdInfos = await this.k8sService.getCrdsForGroup(group);

      // Process kinds in parallel with Promise.all
      await Promise.all(kinds.map(async kind => {
        // Find the matching CRD info from our single batch call
        const crdInfo = allCrdInfos.find(crd => crd.kind === kind);
        if (!crdInfo) return;

        // Get instances and process them
        const resources = await this.k8sService.getCrdInstances(namespace, crdInfo);
        await this.processResources(namespace, kind, resources, changes, existingResources);
      }));
    } catch (error) {
      log(`Error loading CRD group ${group} in ${namespace}: ${error}`, LogLevel.ERROR);
    }
  }

  /**
   * Load NPP pods for a namespace
   */
  private async loadNppPods(
    namespace: string,
    changes: ResourceChange[],
    existingResources: Map<string, ResourceStoreItem>
  ): Promise<void> {
    try {
      const nppPods = await this.k8sService.getNppPodsForNamespace(namespace);

      // NPP pods are special - they're in the system namespace but we present them
      // as part of the user namespace. We'll still store them in system namespace,
      // but we need to track them separately for this namespace.

      // Process each pod
      for (const pod of nppPods) {
        const name = pod.metadata?.name || '';
        const resourceVersion = pod.metadata?.resourceVersion || '';

        // Create a resource store item for this pod
        const item: ResourceStoreItem = {
          kind: 'Pod',
          name,
          namespace: 'eda-system', // Store in actual namespace
          resource: pod,
          resourceVersion,
          lastUpdated: Date.now()
        };

        // Check if this is a new/modified resource
        const key = `Pod/${name}`;
        const existing = existingResources.get(key);

        if (!existing) {
          // New resource
          this.addToStore('eda-system', 'Pod', name, item);
          changes.push({ type: 'added', item });
        } else if (existing.resourceVersion !== resourceVersion) {
          // Modified resource
          this.addToStore('eda-system', 'Pod', name, item);
          changes.push({ type: 'modified', item });
        }

        // Remove from existing resources map
        existingResources.delete(key);
      }
    } catch (error) {
      log(`Error loading NPP pods for ${namespace}: ${error}`, LogLevel.ERROR);
    }
  }

  /**
   * Process a list of resources and add them to the store
   */
  private async processResources(
    namespace: string,
    kind: string,
    resources: any[],
    changes: ResourceChange[],
    existingResources: Map<string, ResourceStoreItem>
  ): Promise<void> {
    if (!resources || !Array.isArray(resources)) return;

    const nsStore = this.store.get(namespace)!;

    // Create kind map if needed
    if (!nsStore.has(kind)) {
      nsStore.set(kind, new Map());
    }

    // Process each resource
    for (const resource of resources) {
      const name = resource.metadata?.name || '';
      const resourceVersion = resource.metadata?.resourceVersion || '';

      // Skip if name is empty
      if (!name) continue;

      // Create a resource store item
      const item: ResourceStoreItem = {
        kind,
        name,
        namespace,
        resource,
        resourceVersion,
        lastUpdated: Date.now()
      };

      // Check if this is a new/modified resource
      const key = `${kind}/${name}`;
      const existing = existingResources.get(key);

      if (!existing) {
        // New resource
        this.addToStore(namespace, kind, name, item);
        changes.push({ type: 'added', item });
      } else if (existing.resourceVersion !== resourceVersion) {
        // Modified resource
        this.addToStore(namespace, kind, name, item);
        changes.push({ type: 'modified', item });
      }

      // Remove from existing resources map
      existingResources.delete(key);
    }
  }

  /**
   * Add a resource to the store
   */
  private addToStore(namespace: string, kind: string, name: string, item: ResourceStoreItem): void {
    if (!this.store.has(namespace)) {
      this.store.set(namespace, new Map());
    }

    const nsStore = this.store.get(namespace)!;
    if (!nsStore.has(kind)) {
      nsStore.set(kind, new Map());
    }

    const kindMap = nsStore.get(kind)!;
    kindMap.set(name, item);
  }

  /**
   * Get CRD info for a kind
   */
  private async getCrdInfoForKind(kind: string): Promise<any> {
    try {
      // Use our cached mapping instead of calling getCrdsForGroup repeatedly
      for (const [group, kinds] of this.crdGroups.entries()) {
        if (kinds.includes(kind)) {
          // Get the cached CRD infos for this group
          const crds = await this.k8sService.getCrdsForGroup(group);
          return crds.find(crd => crd.kind === kind);
        }
      }
      return null;
    } catch (error) {
      log(`Error getting CRD info for kind ${kind}: ${error}`, LogLevel.ERROR);
      return null;
    }
  }

  /**
   * Reset and refresh all resources and views
   * Used after operations like switching clusters
   */
  public async refreshAll(): Promise<void> {
    try {
      log('Starting full refresh of all resources...', LogLevel.INFO, true);

      // Clear current store
      this.clear();

      // IMPORTANT: Get namespaces fresh from the new context
      const namespaces = await this.k8sService.getEdaNamespaces();

      // Reinitialize everything
      await this.initCrdGroups();

      // Load eda-system first, then other known EDA namespaces
      await this.loadNamespaceResources('eda-system');

      for (const ns of namespaces) {
        if (ns !== 'eda-system') {
          await this.loadNamespaceResources(ns);
        }
      }

      // Fire events
      this._onDidChangeResources.fire([]);

      for (const namespace of this.loadedNamespaces) {
        this._onDidReloadNamespace.fire(namespace);
      }

      log('Full resource refresh completed successfully', LogLevel.INFO, true);
    } catch (error) {
      log(`Error during full refresh: ${error}`, LogLevel.ERROR, true);
      throw error;
    }
  }

  /**
   * Clear all stored data
   */
  public clear(): void {
    this.store.clear();
    this.loadedNamespaces.clear();
    this.lastRefreshTime.clear();
  }

  /**
   * Get last refresh time for a namespace
   */
  public getLastRefreshTime(namespace: string): number {
    return this.lastRefreshTime.get(namespace) || 0;
  }
}
=== ./src/services/resourceStatusService.ts ===
// src/services/resourceStatusService.ts
import * as vscode from 'vscode';
import * as path from 'path';
import { LogLevel, log } from '../extension.js';
import { KubernetesService } from './kubernetes/kubernetes';

/**
 * Service for handling resource status information, icons, and tooltips
 * This centralizes all status-related functionality across the extension
 * Incorporates and replaces functionality from statusUtils
 */
export class ResourceStatusService {
  // Maps for caching status icons
  private statusIconCache: Map<string, vscode.Uri> = new Map();
  private transactionIconCache: Map<string, vscode.Uri> = new Map();

  // Store CRD status schemas for improved status handling
  private crdStatusSchemas: Map<string, any> = new Map();
  private initialized: boolean = false;

  // Extension context for resource loading
  private extensionContext?: vscode.ExtensionContext;

  constructor(private k8sService: KubernetesService) {}

  /**
   * Initialize the service with extension context and loading CRD status schemas
   * This should be called during extension activation
   */
  public async initialize(context: vscode.ExtensionContext): Promise<void> {
    if (this.initialized) return;

    try {
      this.extensionContext = context;
      await this.loadCrdStatusSchemas();
      this.initialized = true;
      log('ResourceStatusService initialized successfully', LogLevel.INFO);
    } catch (error) {
      log(`Failed to initialize ResourceStatusService: ${error}`, LogLevel.ERROR);
    }
  }

  /**
   * Load status schemas for all CRDs
   */
  private async loadCrdStatusSchemas(): Promise<void> {
    try {
      const crds = await this.k8sService.getCRDs();
      log(`Loading status schemas for ${crds.length} CRDs...`, LogLevel.INFO);

      for (const crd of crds) {
        const kind = crd.spec?.names?.kind;
        if (!kind) continue;

        // Extract schema from CRD
        const schema = this.extractStatusSchema(crd);
        if (schema) {
          this.crdStatusSchemas.set(kind, schema);
        }
      }

      log(`Loaded status schemas for ${this.crdStatusSchemas.size} CRDs`, LogLevel.INFO);
    } catch (error) {
      log(`Failed to load CRD status schemas: ${error}`, LogLevel.ERROR);
    }
  }

  /**
   * Extract status schema from CRD definition
   */
  private extractStatusSchema(crd: any): any {
    try {
      // Find the schema section
      let schema = null;

      if (crd.spec?.versions && Array.isArray(crd.spec.versions)) {
        // Find the version marked as storage or the first one
        const version = crd.spec.versions.find((v: any) => v.storage === true) ||
                      crd.spec.versions[0];

        if (version?.schema?.openAPIV3Schema?.properties?.status) {
          schema = version.schema.openAPIV3Schema.properties.status;
        }
      }

      // Check for legacy format if schema is still null
      if (!schema && crd.spec) {
        const specObj = crd.spec as Record<string, any>;
        if ('validation' in specObj &&
            specObj.validation &&
            typeof specObj.validation === 'object' &&
            'openAPIV3Schema' in specObj.validation &&
            specObj.validation.openAPIV3Schema &&
            typeof specObj.validation.openAPIV3Schema === 'object' &&
            'properties' in specObj.validation.openAPIV3Schema &&
            specObj.validation.openAPIV3Schema.properties &&
            typeof specObj.validation.openAPIV3Schema.properties === 'object' &&
            'status' in specObj.validation.openAPIV3Schema.properties) {

          schema = specObj.validation.openAPIV3Schema.properties.status;
        }
      }

      return schema;
    } catch (error) {
      log(`Error extracting status schema: ${error}`, LogLevel.ERROR);
      return null;
    }
  }

  // --- Status Icon Methods (from statusUtils) ---

  /**
   * Get status icon based on indicator color (green, red, yellow, gray)
   * This is the primary icon function that should be used for most resources
   */
  public getStatusIcon(indicator: string): vscode.Uri {
    if (!this.extensionContext) {
      throw new Error('ResourceStatusService not properly initialized with context');
    }

    const validIndicators = ['green', 'red', 'yellow', 'gray'];
    const actualIndicator = validIndicators.includes(indicator) ? indicator : 'gray';

    // Use cached icon if available
    if (this.statusIconCache.has(actualIndicator)) {
      return this.statusIconCache.get(actualIndicator)!;
    }

    // Create and cache the icon
    const iconUri = vscode.Uri.file(
      this.extensionContext.asAbsolutePath(path.join('resources', 'status', `status-${actualIndicator}.svg`))
    );

    this.statusIconCache.set(actualIndicator, iconUri);
    return iconUri;
  }

  /**
   * Get transaction icon based on success/failure
   * Only used for transaction items
   */
  public getTransactionIcon(success: boolean): vscode.Uri {
    if (!this.extensionContext) {
      throw new Error('ResourceStatusService not properly initialized with context');
    }

    const status = success ? 'green' : 'red';

    // Use cached icon if available
    if (this.transactionIconCache.has(status)) {
      return this.transactionIconCache.get(status)!;
    }

    // Create and cache the icon
    const iconUri = vscode.Uri.file(
      this.extensionContext.asAbsolutePath(path.join('resources', 'status', `transaction-${status}.svg`))
    );

    this.transactionIconCache.set(status, iconUri);
    return iconUri;
  }

  /**
   * Get a ThemeIcon for a status color (for tree items that use ThemeIcon)
   */
  public getThemeStatusIcon(indicator: string): vscode.ThemeIcon {
    switch (indicator) {
      case 'red':
        return new vscode.ThemeIcon('error', new vscode.ThemeColor('charts.red'));
      case 'yellow':
        return new vscode.ThemeIcon('warning', new vscode.ThemeColor('charts.yellow'));
      case 'green':
        return new vscode.ThemeIcon('check', new vscode.ThemeColor('charts.green'));
      case 'blue':
        return new vscode.ThemeIcon('info', new vscode.ThemeColor('charts.blue'));
      case 'gray':
      default:
        return new vscode.ThemeIcon('circle-outline');
    }
  }

  /**
   * Get a ThemeIcon for alarm severities (for tree items that use ThemeIcon)
   */
  public getAlarmThemeIcon(severity: string): vscode.ThemeIcon {
    const level = severity.toUpperCase();
    switch (level) {
      case 'CRITICAL':
        return new vscode.ThemeIcon('error', new vscode.ThemeColor('charts.red'));
      case 'MAJOR':
        return new vscode.ThemeIcon('warning', new vscode.ThemeColor('charts.orange'));
      case 'WARNING':
        return new vscode.ThemeIcon('warning', new vscode.ThemeColor('charts.yellow'));
      case 'MINOR':
        return new vscode.ThemeIcon('info', new vscode.ThemeColor('charts.blue'));
      case 'INFO':
        return new vscode.ThemeIcon('info', new vscode.ThemeColor('charts.green'));
      default:
        return new vscode.ThemeIcon('question');
    }
  }

  /**
   * Map severity/status/health to a standard indicator color
   * (green, red, yellow, gray)
   */
  public getStatusIndicator(status: string | undefined, health: number | undefined): string {
    if (!status && health === undefined) return 'gray';

    if (status) {
      const s = status.toLowerCase();
      if (['up', 'running', 'active'].includes(s)) return 'green';
      if (['down', 'failed', 'error'].includes(s)) return 'red';
      if (['degraded', 'warning'].includes(s)) return 'yellow';
    }

    if (health !== undefined) {
      if (health > 90) return 'green';
      if (health > 50) return 'yellow';
      return 'red';
    }

    return 'gray';
  }

  /**
   * Get alarm status indicator color based on severity
   */
  public getAlarmStatusIndicator(severity: string): string {
    const level = (severity || '').toUpperCase();
    switch (level) {
      case 'CRITICAL': return 'red';
      case 'MAJOR': return 'yellow';
      case 'WARNING': return 'yellow';
      case 'MINOR': return 'gray';
      case 'INFO': return 'green';
      default: return 'gray';
    }
  }

  // --- Resource Status Methods ---

  /**
   * Get status icon for a resource
   * @param resource Kubernetes resource object
   * @returns URI to the status icon
   */
  public getResourceStatusIcon(resource: any): vscode.Uri {
    const indicator = this.getResourceStatusIndicator(resource);
    return this.getStatusIcon(indicator);
  }

  /**
   * Get status icon as ThemeIcon for a resource
   * @param resource Kubernetes resource object
   * @returns ThemeIcon representing the resource status
   */
  public getResourceThemeStatusIcon(resource: any): vscode.ThemeIcon {
    const indicator = this.getResourceStatusIndicator(resource);
    return this.getThemeStatusIcon(indicator);
  }

  /**
   * Get status indicator string (green, yellow, red, gray) for a resource
   * @param resource Kubernetes resource object
   * @returns Status indicator string
   */
  public getResourceStatusIndicator(resource: any): string {
    if (!resource) return 'gray';

    const kind = resource.kind;

    // Handle standard Kubernetes resources
    if (this.isStandardK8sResource(kind)) {
      return this.getStandardK8sResourceStatus(resource);
    }

    // Handle custom resources
    return this.getCustomResourceStatus(resource);
  }

  /**
   * Get description text for status display
   * This extracts a short status description for display in tree views
   * @param resource Kubernetes resource object
   * @returns Short status description
   */
  public getStatusDescription(resource: any): string {
    if (!resource) return '';

    const kind = resource.kind;

    switch (kind) {
      case 'Pod':
        return resource.status?.phase || '';

      case 'Deployment':
        const ready = resource.status?.readyReplicas || 0;
        const desired = resource.spec?.replicas || 0;
        return `${ready}/${desired}`;

      case 'Service':
        return resource.spec?.type || 'ClusterIP';

      case 'ConfigMap':
        const dataCount = Object.keys(resource.data || {}).length;
        return `${dataCount} items`;

      case 'Secret':
        return resource.type || 'Opaque';
    }

    // For custom resources
    if (resource.status) {
      let desc = '';

      // Common status fields for EDA resources
      if (resource.status.operationalState) {
        desc += `State: ${resource.status.operationalState}`;
      }

      if (resource.status.health !== undefined) {
        desc += (desc ? ', ' : '') + `Health: ${resource.status.health}%`;
      }

      if (resource.status.state) {
        desc += (desc ? ', ' : '') + `State: ${resource.status.state}`;
      }

      // Look for other important status fields defined in schema
      if (!desc && this.crdStatusSchemas.has(kind)) {
        const schema = this.crdStatusSchemas.get(kind);
        if (schema && schema.properties) {
          // Use priority fields if defined in schema
          const priorityFields = ['phase', 'status', 'condition', 'ready'];
          for (const field of priorityFields) {
            if (resource.status[field] !== undefined) {
              desc += (desc ? ', ' : '') + `${this.formatFieldName(field)}: ${resource.status[field]}`;
            }
          }
        }
      }

      return desc;
    }

    return '';
  }

  /**
   * Get tooltip text for a resource
   * @param resource Kubernetes resource object
   * @returns Tooltip text with detailed resource info
   */
  public getResourceTooltip(resource: any): string {
    if (!resource) return '';

    const kind = resource.kind;
    const name = resource.metadata?.name || 'Unnamed';
    const namespace = resource.metadata?.namespace || 'default';

    let tooltip = `Name: ${name}\nKind: ${kind}\nNamespace: ${namespace}`;

    // Add API Version if available
    if (resource.apiVersion) {
      tooltip += `\nAPI Version: ${resource.apiVersion}`;
    }

    // Add resource UID if available
    if (resource.metadata?.uid) {
      tooltip += `\nUID: ${resource.metadata.uid}`;
    }

    // Add creation timestamp if available
    if (resource.metadata?.creationTimestamp) {
      tooltip += `\nCreated: ${resource.metadata.creationTimestamp}`;
    }

    // Add status fields
    if (resource.status) {
      const statusFields = this.extractStatusFields(resource.status, kind);
      if (statusFields.length > 0) {
        tooltip += '\n\nStatus:';
        for (const field of statusFields) {
          tooltip += `\n ${field.label}: ${field.value}`;
        }
      }
    }

    return tooltip;
  }

  /**
   * Extract relevant status fields based on resource kind and schema
   */
  private extractStatusFields(status: any, kind: string): { label: string, value: string }[] {
    const fields: { label: string, value: string }[] = [];
    if (!status) return fields;
  
    // Handle standard resource kinds as before
    switch (kind) {
      case 'Pod':
        if (status.phase) fields.push({ label: 'Phase', value: status.phase });
        if (status.podIP) fields.push({ label: 'Pod IP', value: status.podIP });
        if (status.hostIP) fields.push({ label: 'Host IP', value: status.hostIP });
        if (status.startTime) fields.push({ label: 'Started', value: status.startTime });
        if (status.containerStatuses && Array.isArray(status.containerStatuses)) {
          for (const container of status.containerStatuses) {
            const ready = container.ready ? 'Ready' : 'Not Ready';
            const restartCount = container.restartCount || 0;
            fields.push({
              label: `Container ${container.name}`,
              value: `${ready}, Restarts: ${restartCount}`
            });
          }
        }
        break;
  
      case 'Deployment':
        if (status.replicas !== undefined) fields.push({ label: 'Replicas', value: `${status.replicas}` });
        if (status.readyReplicas !== undefined) fields.push({ label: 'Ready', value: `${status.readyReplicas}` });
        if (status.updatedReplicas !== undefined) fields.push({ label: 'Updated', value: `${status.updatedReplicas}` });
        if (status.availableReplicas !== undefined) fields.push({ label: 'Available', value: `${status.availableReplicas}` });
        if (status.conditions && Array.isArray(status.conditions)) {
          for (const condition of status.conditions) {
            fields.push({
              label: `Condition ${condition.type}`,
              value: `${condition.status} - ${condition.message || 'No message'}`
            });
          }
        }
        break;
  
      case 'Service':
        if (status.loadBalancer?.ingress && Array.isArray(status.loadBalancer.ingress)) {
          for (const ingress of status.loadBalancer.ingress) {
            if (ingress.ip) {
              fields.push({ label: 'LoadBalancer IP', value: ingress.ip });
            }
            if (ingress.hostname) {
              fields.push({ label: 'LoadBalancer Hostname', value: ingress.hostname });
            }
          }
        }
        break;
  
      default:
        // For custom resources, we ignore the schema and extract only the actual status values.
        // We only add fields if the value is a primitive type (or a very simple object).
        for (const [key, value] of Object.entries(status)) {
          if (value === undefined || value === null) {
            continue;
          }
          // If the value is a primitive, use it directly.
          if (['string', 'number', 'boolean'].includes(typeof value)) {
            fields.push({ label: this.formatFieldName(key), value: String(value) });
          }
          // If the value is an object, try to extract a simple value.
          else if (typeof value === 'object') {
            // If it has a 'value' property that is primitive, use that.
            if ('value' in value && ['string', 'number', 'boolean'].includes(typeof value.value)) {
              fields.push({ label: this.formatFieldName(key), value: String(value.value) });
            }
            // Otherwise, if the object has only one key, use that single property.
            else if (Object.keys(value).length === 1) {
              const innerKey = Object.keys(value)[0];
              const innerVal = (value as Record<string, any>)[innerKey];
              if (['string', 'number', 'boolean'].includes(typeof innerVal)) {
                fields.push({ label: this.formatFieldName(key), value: String(innerVal) });
              }
            }
            // Otherwise, skip complex objects.
          }
        }
        break;
    }
    return fields;
  }
  

  /**
   * Format a camelCase or snake_case field name to Title Case with spaces
   */
  private formatFieldName(name: string): string {
    // Handle camelCase
    const spacedName = name.replace(/([A-Z])/g, ' $1');

    // Handle snake_case
    const withoutUnderscores = spacedName.replace(/_/g, ' ');

    // Title case
    return withoutUnderscores
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  }

  /**
   * Check if a resource kind is a standard Kubernetes resource
   */
  private isStandardK8sResource(kind: string): boolean {
    const standardResources = [
      'Pod', 'Service', 'Deployment', 'ConfigMap', 'Secret',
      'Node', 'Job', 'CronJob', 'DaemonSet', 'StatefulSet',
      'ReplicaSet', 'Ingress', 'PersistentVolumeClaim', 'PersistentVolume'
    ];

    return standardResources.includes(kind);
  }

  /**
   * Get status indicator for standard Kubernetes resources
   */
  private getStandardK8sResourceStatus(resource: any): string {
    if (!resource) return 'gray';

    const kind = resource.kind;
    const status = resource.status;

    if (!status) return 'gray';

    switch (kind) {
      case 'Pod':
        const phase = status.phase?.toLowerCase();
        if (phase === 'running') return 'green';
        if (phase === 'pending') return 'yellow';
        if (['failed', 'unknown', 'error'].includes(phase)) return 'red';
        break;

      case 'Deployment':
        const desired = resource.spec?.replicas || 0;
        const ready = status.readyReplicas || 0;

        if (desired === 0) return 'gray';
        if (ready === desired) return 'green';
        if (ready > 0) return 'yellow';
        return 'red';

      case 'Service':
        // Services are typically always "green" if they exist
        return 'green';

      case 'Node':
        // Check node conditions
        const conditions = status.conditions || [];
        const readyCondition = conditions.find((c: any) => c.type === 'Ready');

        if (readyCondition && readyCondition.status === 'True') return 'green';
        return 'red';

      case 'ConfigMap':
      case 'Secret':
        // Always green for these types
        return 'green';
    }

    return 'gray';
  }

  /**
   * Get status indicator for custom resources, with generic support for keys containing "status" or "state"
   */
  private getCustomResourceStatus(resource: any): string {
    if (!resource || !resource.status) return 'gray';
  
    // Explicit checks for new conditions
    if (resource.status.operational === true) {
      return 'green';
    }
    if (resource.status.operational === false) {
      return 'red';
    }
    if (resource.status.error === "" && resource.status.reachable === true) {
      return 'green';
    }
  
    // Existing specific checks
    if (resource.status.operationalState) {
      const state = resource.status.operationalState.toLowerCase();
      if (['up', 'running', 'active'].includes(state)) return 'green';
      if (['down', 'failed', 'error'].includes(state)) return 'red';
      if (['degraded', 'warning'].includes(state)) return 'yellow';
    }
  
    if (resource.status.health !== undefined) {
      const health = Number(resource.status.health);
      if (health > 90) return 'green';
      if (health > 50) return 'yellow';
      return 'red';
    }
  
    if (resource.status.state) {
      const state = resource.status.state.toLowerCase();
      if (['up', 'running', 'active', 'ready'].includes(state)) return 'green';
      if (['down', 'failed', 'error'].includes(state)) return 'red';
      if (['degraded', 'warning', 'pending'].includes(state)) return 'yellow';
    }
  
    if (resource.status.phase) {
      const phase = resource.status.phase.toLowerCase();
      if (['active', 'succeeded', 'ready', 'running', 'available'].includes(phase)) return 'green';
      if (['pending', 'initializing', 'provisioning'].includes(phase)) return 'yellow';
      if (['failed', 'error', 'terminating'].includes(phase)) return 'red';
    }
  
    if (resource.status.ready === true) return 'green';
    if (resource.status.ready === false) return 'red';
  
    if (resource.status.conditions && Array.isArray(resource.status.conditions)) {
      const readyCondition = resource.status.conditions.find((c: any) =>
        c.type === 'Ready' || c.type === 'Available' || c.type === 'Healthy'
      );
      if (readyCondition) {
        if (readyCondition.status === 'True') return 'green';
        if (readyCondition.status === 'False') return 'red';
        return 'yellow';
      }
      const errorCondition = resource.status.conditions.find((c: any) =>
        (c.type === 'Error' || c.type === 'Failed') && c.status === 'True'
      );
      if (errorCondition) return 'red';
    }
  
    // Generic check: scan for keys containing "status" or "state" (skip keys like "details")
    const genericIndicators: string[] = [];
    for (const key in resource.status) {
      const keyLower = key.toLowerCase();
      if (
        (keyLower.includes("status") || keyLower.includes("state")) &&
        !keyLower.includes("details") &&
        typeof resource.status[key] === "string"
      ) {
        genericIndicators.push(this.mapStatusTextToIndicator(resource.status[key]));
      }
    }
  
    if (genericIndicators.length > 0) {
      // Prioritize explicit failures or warnings
      if (genericIndicators.includes('red')) {
        return 'red';
      } else if (genericIndicators.includes('yellow')) {
        return 'yellow';
      } else {
        // If no bad indicators, default to green
        return 'green';
      }
    }
  
    // If a status exists but none of the keys provided an indicator, default to green.
    return 'green';
  }
  
  

  /**
   * Helper function that maps a status string to a standard indicator color.
   */
  private mapStatusTextToIndicator(text: string): string {
    const t = text.toLowerCase();
    if (
      t.includes('ready') ||
      t.includes('up') ||
      t.includes('running') ||
      t.includes('active') ||
      t.includes('success') ||
      t.includes('available') ||
      t.includes('synced') ||      // added for "node-state": "Synced"
      t.includes('connected')       // added for "npp-state": "Connected"
    ) {
      return 'green';
    }
    if (t.includes('failed') || t.includes('error') || t.includes('down')) {
      return 'red';
    }
    if (t.includes('degraded') || t.includes('warning') || t.includes('pending')) {
      return 'yellow';
    }
    return 'gray';
  }

  /**
   * Refresh CRD status schemas
   * This should be called when CRDs are updated
   */
  public async refreshStatusSchemas(): Promise<void> {
    this.crdStatusSchemas.clear();
    await this.loadCrdStatusSchemas();
  }
}
=== ./src/services/types.ts ===
// src/services/types.ts
// EDA transaction interface
export interface EdaTransaction {
  id: string;
  result: string;
  age: string;
  detail: string;
  dryRun: string;
  username: string;
  description: string;
}

// Interface for CRD information
export interface CrdInfo {
  name: string;     // e.g. "fabrics.eda.nokia.com"
  apiGroup: string; // e.g. "eda.nokia.com"
  kind: string;     // e.g. "Fabric"
  version: string;  // e.g. "v1alpha1"
}

export interface EdaAlarm {
  "clusterSpecific": string;
  "description": string;
  "group": string;
  "jspath": string;
  "kind": string;
  "name": string;
  "namespace.name": string;
  "parentAlarm": string;
  "probableCause": string;
  "remedialAction": string;
  "resource": string;
  "severity": string;           // e.g. "critical"
  "sourceGroup": string;
  "sourceKind": string;
  "sourceResource": string;
  "type": string;
}

export interface EdaDeviation {
  apiVersion: string;
  kind: string;
  name: string;
  "namespace.name": string;
}

// Interface for the deviation specification
export interface DeviationSpec {
  nodeEndpoint: string;
  path: string;
  associatedCrs?: any[];
  intendedValues?: string;
  runningValues?: string;
  operation?: string;
  accepted?: boolean;
}

// Interface for the full deviation object
export interface DeviationResource {
  apiVersion: string;
  kind: string;
  metadata: {
    name: string;
    namespace: string;
    [key: string]: any;
  };
  spec: DeviationSpec;
}

export interface CrdVersion {
  name: string;
  served?: boolean;
  storage?: boolean;
  schema?: {
    openAPIV3Schema?: any;
  };
}

/**
 * Interface for a K8s resource with minimum required fields
 */
export interface K8sResource {
  apiVersion?: string;
  kind: string;
  metadata?: {
    name: string;
    namespace?: string;
    [key: string]: any;
  };
  [key: string]: any;
}
=== ./src/extension.ts ===
// src/extension.ts

import * as vscode from 'vscode';
import { EdaNamespaceProvider } from './providers/views/namespaceProvider';
import { EdaSystemProvider } from './providers/views/systemProvider';
import { EdaTransactionProvider } from './providers/views/transactionProvider';
import { KubernetesService } from './services/kubernetes/kubernetes';
import { K8sFileSystemProvider } from './providers/documents/resourceProvider';
import { CrdDefinitionFileSystemProvider } from './providers/documents/crdDefinitionProvider';
import { PodDescribeDocumentProvider } from './providers/documents/podDescribeProvider';
import { TransactionDetailsDocumentProvider } from './providers/documents/transactionDetailsProvider';
import { SchemaProvider } from './providers/schema';
import { ResourceStore } from './services/store/resourceStore';
import { EdaAlarmProvider } from './providers/views/alarmProvider';
import { EdaDeviationProvider } from './providers/views/deviationProvider';
import { AlarmDetailsDocumentProvider } from './providers/documents/alarmDetailsProvider';
import { DeviationDetailsDocumentProvider } from './providers/documents/deviationDetailsProvider';
import { ResourceViewDocumentProvider } from './providers/documents/resourceViewProvider';
import { ClusterManager } from './services/kubernetes/clusterManager';
import { ResourceStatusService } from './services/resourceStatusService';

import * as cmd from './commands/index';

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

export let edaOutputChannel: vscode.OutputChannel;
export let k8sFileSystemProvider: K8sFileSystemProvider;
export let k8sService: KubernetesService;
export let currentLogLevel: LogLevel = LogLevel.INFO;
export let resourceStore: ResourceStore;
export let edaAlarmProvider: EdaAlarmProvider;
export let edaDeviationProvider: EdaDeviationProvider
export let alarmDetailsProvider: AlarmDetailsDocumentProvider;
export let deviationDetailsProvider: DeviationDetailsDocumentProvider;
export let edaTransactionProvider: EdaTransactionProvider;
export let registerResourceViewCommands: ResourceViewDocumentProvider;
export let clusterManager: ClusterManager;
export let resourceStatusService: ResourceStatusService;

// The global text filter that only applies to Namespaces & System
export let globalTreeFilter: string = '';

export function log(
  message: string,
  level: LogLevel = LogLevel.INFO,
  forceLog: boolean = false,
  elapsedTime?: number
): void {
  if (level >= currentLogLevel || forceLog) {
    const prefix = LogLevel[level].padEnd(5);
    const timestamp = new Date().toISOString().replace('T', ' ').replace('Z', '');

    let logMessage = `[${timestamp}] [${prefix}] ${message}`;

    // Add elapsed time for INFO logs when provided
    if (level === LogLevel.INFO && elapsedTime !== undefined) {
      logMessage += ` (took ${elapsedTime}ms)`;
    }

    edaOutputChannel.appendLine(logMessage);
  }
}

// Add a helper function for performance measurement
export function measurePerformance<T>(
  operation: () => Promise<T>,
  description: string,
  logLevel: LogLevel = LogLevel.INFO,
  forceLog: boolean = false
): Promise<T> {
  const startTime = Date.now();

  return operation().then(result => {
    const elapsedTime = Date.now() - startTime;
    let logMessage = description;

    // If the result is a string, use it as the message
    if (typeof result === 'string') {
      logMessage = result;
    }

    log(logMessage, logLevel, forceLog, elapsedTime);
    return result;
  }).catch(error => {
    const elapsedTime = Date.now() - startTime;
    log(`${description} - Failed: ${error}`, LogLevel.ERROR, true, elapsedTime);
    throw error;
  });
}

export async function activate(context: vscode.ExtensionContext) {
  console.log('Activating EDA extension');
  edaOutputChannel = vscode.window.createOutputChannel('EDA');

  const config = vscode.workspace.getConfiguration('vscode-eda');
  currentLogLevel = config.get<LogLevel>('logLevel', LogLevel.INFO);

  log('EDA extension activating...', LogLevel.INFO, true);


  k8sService = new KubernetesService();
  resourceStore = new ResourceStore(k8sService);

  // Initialize cluster manager
  clusterManager = new ClusterManager(k8sService);
  context.subscriptions.push(clusterManager);

  // Initialize the resource store
  log('Initializing resource store...', LogLevel.INFO, true);
  await resourceStore.initCrdGroups();
  await resourceStore.loadNamespaceResources('eda-system');

  // Initialize the resource status service
  log('Initializing resource status service...', LogLevel.INFO, true);
  resourceStatusService = new ResourceStatusService(k8sService);
  await resourceStatusService.initialize(context);

  k8sFileSystemProvider = new K8sFileSystemProvider(k8sService);
  context.subscriptions.push(
    vscode.workspace.registerFileSystemProvider('k8s', k8sFileSystemProvider, { isCaseSensitive: true })
  );

  const crdFsProvider = new CrdDefinitionFileSystemProvider();
  context.subscriptions.push(
    vscode.workspace.registerFileSystemProvider('crd', crdFsProvider, { isCaseSensitive: true })
  );

  const resourceViewProvider = new ResourceViewDocumentProvider();
  context.subscriptions.push(
    vscode.workspace.registerFileSystemProvider('k8s-view', resourceViewProvider, {
      isCaseSensitive: true
    })
  );

  const podDescribeProvider = new PodDescribeDocumentProvider();
  context.subscriptions.push(
    vscode.workspace.registerFileSystemProvider('k8s-describe', podDescribeProvider, { isCaseSensitive: true })
  );

  edaAlarmProvider = new EdaAlarmProvider(context, k8sService);
  vscode.window.registerTreeDataProvider('edaAlarms', edaAlarmProvider);

  edaDeviationProvider = new EdaDeviationProvider(context, k8sService);
  vscode.window.registerTreeDataProvider('edaDeviations', edaDeviationProvider);

  const transactionDetailsProvider = new TransactionDetailsDocumentProvider();
  context.subscriptions.push(
    vscode.workspace.registerFileSystemProvider('eda-transaction', transactionDetailsProvider, { isCaseSensitive: true })
  );

  const edaNamespaceProvider = new EdaNamespaceProvider(context, k8sService);
  const edaSystemProvider = new EdaSystemProvider(context, k8sService);
  edaTransactionProvider = new EdaTransactionProvider(context, k8sService);

  vscode.window.registerTreeDataProvider('edaNamespaces', edaNamespaceProvider);
  vscode.window.registerTreeDataProvider('edaSystem', edaSystemProvider);
  vscode.window.registerTreeDataProvider('edaTransactions', edaTransactionProvider);

  log('Registering Schema Provider...', LogLevel.INFO, true);
  const schemaProvider = new SchemaProvider(k8sService);
  schemaProvider.register(context);

  // Register commands
  cmd.registerClusterCommands(context, k8sService, clusterManager, resourceStore);
  cmd.registerRefreshCommands(context);
  cmd.registerViewCommands(context, k8sService, crdFsProvider, transactionDetailsProvider);
  cmd.registerPodCommands(context, k8sService, podDescribeProvider);
  cmd.registerResourceViewCommands(context, k8sService, resourceViewProvider);
  cmd.registerSwitchToEditCommand(context);
  cmd.registerResourceEditCommands(context, k8sService, k8sFileSystemProvider, {
    namespaceProvider: edaNamespaceProvider,
    systemProvider: edaSystemProvider,
    transactionProvider: edaTransactionProvider
  });
  cmd.registerResourceCreateCommand(context, k8sService, k8sFileSystemProvider);
  cmd.registerDeviationCommands(context, k8sService);
  cmd.registerTransactionCommands(context, k8sService);

  // Filter command: Just set the globalTreeFilter, then refresh
  const filterTreeCommand = vscode.commands.registerCommand('vscode-eda.filterTree', async () => {
    const input = await vscode.window.showInputBox({
      placeHolder: 'Filter by resource name...',
      prompt: 'Enter partial text. If empty, filter is cleared. Searching is lazy BFS on demand.'
    });
    if (input !== undefined) {
      globalTreeFilter = input.trim();

      // Refresh
      edaNamespaceProvider.refresh();
      edaSystemProvider.refresh();
    }
  });
  context.subscriptions.push(filterTreeCommand);

    // Create provider instances
    alarmDetailsProvider = new AlarmDetailsDocumentProvider();
    deviationDetailsProvider = new DeviationDetailsDocumentProvider();

    context.subscriptions.push(
      vscode.workspace.registerFileSystemProvider('eda-alarm', alarmDetailsProvider, { isCaseSensitive: true }),
      vscode.workspace.registerFileSystemProvider('eda-deviation', deviationDetailsProvider, { isCaseSensitive: true })
    );

  const clearFilterCommand = vscode.commands.registerCommand('vscode-eda.clearFilter', () => {
    // Reset the global filter variable
    globalTreeFilter = '';

    // Refresh the views so that the filter is cleared from the UI
    edaNamespaceProvider.refresh();
    edaSystemProvider.refresh();

    vscode.window.showInformationMessage('Filter cleared');
  });
  context.subscriptions.push(clearFilterCommand);


  console.log('EDA extension activated');
  edaOutputChannel.appendLine('EDA extension activated');
}

export function deactivate() {
  console.log('EDA extension deactivated');
  edaOutputChannel?.appendLine('EDA extension deactivated');
  edaOutputChannel?.dispose();
  clusterManager?.dispose();
}
